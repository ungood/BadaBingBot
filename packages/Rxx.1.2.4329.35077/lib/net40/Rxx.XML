<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Rxx</name>
  </assembly>
  <members>
    <member name="T:System.Diagnostics.Contracts.ContractArgumentValidatorAttribute">
      <summary>
            Enables factoring legacy if-then-throw into separate methods for reuse and full control over
            thrown exception and arguments
            </summary>
    </member>
    <member name="T:System.Diagnostics.Contracts.ContractAbbreviatorAttribute">
      <summary>
            Enables writing abbreviations for contracts that get copied to other methods
            </summary>
    </member>
    <member name="T:System.Diagnostics.Contracts.ContractOptionAttribute">
      <summary>
            Allows setting contract and tool options at assembly, type, or method granularity.
            </summary>
    </member>
    <member name="T:Rxx.ComponentReflection">
      <summary>
            Provides methods for accessing an object's members through the <see cref="T:System.ComponentModel.TypeDescriptor" /> and 
            <see cref="T:System.ComponentModel.PropertyDescriptor" /> classes.
            </summary>
      <remarks>
        <para>
            The benefits of using <see cref="T:System.ComponentModel.TypeDescriptor" /> instead of direct reflection is that types can define
            what members they expose in various ways, even dynamically at runtime via component services, for classes
            that implement <see cref="T:System.ComponentModel.IComponent" />, or through self-description via the 
            <see cref="T:System.ComponentModel.ICustomTypeDescriptor" /> interface.
            </para>
        <para>
            This is much more powerful than direct reflection is alone, but it's not a replacment and shouldn't be 
            used everywhere.  Before using this API instead of direct reflection, consider whether allowing types
            to describe themselves or applications to describe their types is actually the desired behavior when
            reflecting.
            </para>
      </remarks>
      <seealso href="http://msdn.microsoft.com/en-us/library/system.componentmodel.typedescriptor.aspx">
            TypeDescriptor Class, Remarks
            </seealso>
    </member>
    <member name="T:Rxx.Parsers.IParser`2">
      <summary>
            Represents a parser over an enumerable sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})">
      <summary>
            Iterates the specified enumerable sequence and applies the parser's grammar, which is defined in 
            terms of the <see cref="P:Rxx.Parsers.IParser`2.Next" /> parser, to generate matches.
            </summary>
      <param name="source">The enumerable sequence to parse.</param>
      <returns>An enumerable sequence of parse results that contain information about the matches.</returns>
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.IParser`2.Next">
      <summary>
            Gets a parser with a grammar that matches the next element in the source sequence.
            </summary>
      <remarks>
            A parser's grammar is defined in terms of grammar rules, each of which is defined in terms of the <see cref="P:Rxx.Parsers.IParser`2.Next" /> parser
            or another rule.
            </remarks>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.IParseResult`1">
      <summary>
            Represents a single result of a parse operation over a sequence.
            </summary>
      <typeparam name="TValue">The type of the parse result's <see cref="P:Rxx.Parsers.IParseResult`1.Value" />.</typeparam>
    </member>
    <member name="P:Rxx.Parsers.IParseResult`1.Value">
      <summary>
            Gets the projection of the matched elements in a sequence.
            </summary>
    </member>
    <member name="P:Rxx.Parsers.IParseResult`1.Length">
      <summary>
            Gets the number of elements in a sequence that were consumed to generate the <see cref="P:Rxx.Parsers.IParseResult`1.Value" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.ILookAheadParseResult`1">
      <summary>
            Represents a possible result of a parse operation over a sequence, depending upon whether a subsequent parser matches.
            </summary>
      <remarks>
        <para>
            This type of result is used by lazy quantifiers.  It does not represent <em>look-ahead</em> as in the Regular
            Expression sense.  That kind of look-ahead can be expressed using a normal <c>SelectMany</c> query by simply applying 
            the <c>NonGreedy</c> operator to the first parser.  That will effectively allow the first parser to look-ahead for a 
            match from the current position of the cursor, without consuming the results.  The second parser is then executed from 
            the same starting position as the first parser, but only when the first parser matches.
            </para>
        <para>
            Instead, this type of result allows quantifiers to end lazily by asking <c>SelectMany</c> if the second parser matches 
            after each successful match from the quantified parser, starting at the end of the current match.  Essentially, it's like 
            adding <c>NonGreedy</c> to each individual match instead of adding it to the entire quantified parser.  Behaviorally, it's 
            a special kind of result that indicates to <c>SelectMany</c> to look ahead at the second parser and notify the result 
            whether it's successful or not, without yielding.
            </para>
        <alert type="implementors">
            The <see cref="M:Rxx.Parsers.ILookAheadParseResult`1.OnCompleted(System.Boolean)" /> implementation must only accept a single call, specifying <see langword="true" /> to 
            indicate that the look-ahead succeeded and that the parse result can be captured by the parser that generated it; 
            otherwise, <see langword="false" /> should be specified.  The specified value must be buffered and replayed to all 
            observers.
            </alert>
        <alert type="warning">
            When developing custom parser operators, there is no need to use the <see cref="T:System.IObservable`1" />
            implementation of <see cref="T:Rxx.Parsers.ILookAheadParseResult`1" />.  In other words, do not call 
            <strong>Subscribe</strong> or <strong>OnCompleted</strong>.  Look-aheads are handled by the infrastructure, so simply 
            treat this type of result like a normal <see cref="T:Rxx.Parsers.IParseResult`1" />.
            </alert>
      </remarks>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.ILookAheadParseResult`1.OnCompleted(System.Boolean)">
      <summary>
            Completes the look-ahead operation and notifies subscribers.
            </summary>
      <param name="success">
        <see langword="True" /> to indicate that the look-ahead succeeded and that the parse result can 
            be captured by the parser that generated it; otherwise, <see langword="false" />.</param>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:Rxx.Parsers.ILookAheadParseResult`1.OnCompleted(System.Boolean)" /> has already been called on this parse result.</exception>
    </member>
    <member name="T:System.Linq.ICursor`1">
      <summary>
            Represents a shared enumerable sequence that replays values from a current index that can be moved,
            along with support for optimized branching.
            </summary>
      <remarks>
        <alert type="implementors">
            The contracts of <see cref="T:System.Linq.ICursor`1" /> rely on some of the properties being immutable.
            The <see cref="P:System.Linq.ICursor`1.IsForwardOnly" /> property must be immutable.  Furthermore, the <see cref="P:System.Linq.ICursor`1.IsSequenceTerminated" /> property 
            must be <see langword="false" /> until the sequence terminates, at which time it must return <see langword="true" /> and then 
            hold that value indefinitely.
            </alert>
      </remarks>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <threadsafety instance="false" />
    </member>
    <member name="M:System.Linq.ICursor`1.Move(System.Int32)">
      <summary>
            Changes the current index of the cursor to the element at the specified number of elements forward or backward.
            </summary>
      <param name="count">The number of elements to move after the current index if the specified count is positive
            or before the current index if the specified count is negative.</param>
      <remarks>
        <para>
            The specified <paramref name="count" /> may be a negative number only if <see cref="P:System.Linq.ICursor`1.IsForwardOnly" /> is <see langword="false" />.
            </para>
        <alert type="implementors">
            If the specified <paramref name="count" /> is greater than the length from the current element to the latest
            element in the sequence, then the cursor must virtualize itself by skipping subsequent elements until the position 
            of the cursor is reached.
            </alert>
      </remarks>
      <seealso cref="P:System.Linq.ICursor`1.IsForwardOnly" />
      <requires>!IsForwardOnly || count &gt;= 0</requires>
      <requires>!AtEndOfSequence || count &lt;= 0</requires>
      <requires>CurrentIndex + count &gt;= 0</requires>
      <requires>!IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures>IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures>IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="M:System.Linq.ICursor`1.Branch">
      <summary>
            Returns a new cursor that starts at the current position of this cursor and is tied to the lifetime of this cursor.
            </summary>
      <remarks>
        <alert type="implementors">
          <see cref="M:System.Linq.ICursor`1.Branch" /> provides a means for cursor authors to optimize branches so that they can share the same state.
            </alert>
      </remarks>
      <returns>A new cursor that starts at the current position of this cursor.</returns>
      <ensures>Contract.Result&lt;ICursor&lt;T&gt;&gt;() != null</ensures>
      <ensures>IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures>IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures>AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="M:System.Linq.ICursor`1.Reset">
      <summary>
            Clears any buffered elements, branches and state, and ensures that a subsequent iteration will re-enumerate the source sequence.
            </summary>
      <ensures>IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures>CurrentIndex == 0</ensures>
      <ensures>LatestIndex == -1</ensures>
      <ensures>!IsSequenceTerminated</ensures>
    </member>
    <member name="P:System.Linq.ICursor`1.IsForwardOnly">
      <summary>
            Gets a value indicating whether the cursor only moves forward.
            </summary>
      <remarks>
        <alert type="implementors">
          <see cref="P:System.Linq.ICursor`1.IsForwardOnly" /> must be immutable.  Contracts of <see cref="T:System.Linq.ICursor`1" /> members depend upon it.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the cursor only moves forward; otherwise, <see langword="false" />.</value>
      <seealso cref="M:System.Linq.ICursor`1.Move(System.Int32)" />
    </member>
    <member name="P:System.Linq.ICursor`1.CurrentIndex">
      <summary>
            Gets the zero-based index of the element in the sequence at which the cursor is positioned after 
            <see cref="M:System.Linq.ICursor`1.Move(System.Int32)" /> is called.
            </summary>
      <remarks>
        <para>
          <see cref="P:System.Linq.ICursor`1.CurrentIndex" /> starts and remains at 0 until it is changed by the <see cref="M:System.Linq.ICursor`1.Move(System.Int32)" /> method.  A value of 0 indicates
            that the cursor is positioned at the end of an empty sequence.  If the sequence generates one or more values, then 0 indicates
            that the cursor is positioned at the beginning of the sequence.  Subscribing to a cursor that has not moved replays all values in 
            the sequence, if any.
            </para>
        <para>
            The valid range of values for <see cref="P:System.Linq.ICursor`1.CurrentIndex" /> changes depending upon whether the sequence has terminated.
            If the sequence has not terminated, then <see cref="P:System.Linq.ICursor`1.CurrentIndex" /> can be any value that is greater than or equal to zero, 
            even if that value is greater than <see cref="P:System.Linq.ICursor`1.LatestIndex" />; however, once the sequence has terminated, 
            <see cref="P:System.Linq.ICursor`1.CurrentIndex" /> cannot be moved past one more than the <see cref="P:System.Linq.ICursor`1.LatestIndex" />.  This final position 
            indicates that the cursor is at the end of the sequence.  Enumerating a cursor that is positioned at the end of the sequence 
            causes only the termination notification to be yielded, without replaying any values.
            </para>
        <para>
            If <see cref="P:System.Linq.ICursor`1.CurrentIndex" /> is moved past the latest element in the sequence, as indicated by the value of 
            <see cref="P:System.Linq.ICursor`1.LatestIndex" />, then the existing values in the sequence will not be replayed to new subscriptions; 
            furthermore, any new values with indices that are less than <see cref="P:System.Linq.ICursor`1.CurrentIndex" /> will also be excluded from
            new subscriptions.
            </para>
        <alert type="implementors">
            If the current index is positioned ahead of the latest element in the sequence and the sequence 
            subsequently ends, then the current index must automatically be changed to <see cref="P:System.Linq.ICursor`1.LatestIndex" /> + 1 to indicate 
            that the current index is at the end of the sequence.  Consumers can check whether <see cref="P:System.Linq.ICursor`1.CurrentIndex" /> has changed 
            during the <strong>OnCompleted</strong> notification.
            </alert>
      </remarks>
      <value>The zero-based index of the element in the sequence on which the cursor is positioned after 
            <see cref="M:System.Linq.ICursor`1.Move(System.Int32)" /> is called; otherwise, -1.</value>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures>!IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
    </member>
    <member name="P:System.Linq.ICursor`1.LatestIndex">
      <summary>
            Gets the zero-based index of the last known element in the sequence.
            </summary>
      <value>The zero-based index of the last known element in the sequence; -1 until the sequence produces an element, if any.
            If the sequence has terminated, then the value is the index of the last element in the sequence.</value>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="P:System.Linq.ICursor`1.AtEndOfSequence">
      <summary>
            Gets a value indicating whether the cursor is positioned at the end of the sequence.
            </summary>
      <remarks>
        <alert type="note">
            When <see cref="P:System.Linq.ICursor`1.AtEndOfSequence" /> returns <see langword="false" /> it does not indicate that the sequence has 
            not terminated.  It only indicates that the cursor is not currently positioned at the end of the sequence,
            regardless of whether the sequence has actually terminated or not.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the sequence has terminated and the cursor is currently positioned at the end of the sequence;
            otherwise, <see langword="false" />.</value>
      <seealso cref="P:System.Linq.ICursor`1.IsSequenceTerminated" />
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="P:System.Linq.ICursor`1.IsSequenceTerminated">
      <summary>
            Gets a value indicating whether the sequence has terminated.
            </summary>
      <remarks>
        <alert type="note">
            When <see cref="P:System.Linq.ICursor`1.IsSequenceTerminated" /> returns <see langword="true" /> it does not indicate that the cursor is at the
            end of the sequence.  It only indicates that the sequence has terminated, regardless of whether the cursor is actually 
            positioned at the end of the sequence or not.
            </alert>
        <alert type="implementors">
          <see cref="P:System.Linq.ICursor`1.IsSequenceTerminated" /> must be immutable when it returns <see langword="true" />.  Contracts of 
            <see cref="T:System.Linq.ICursor`1" /> members depend upon it.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the sequence has terminated; otherwise, <see langword="false" />.</value>
      <seealso cref="P:System.Linq.ICursor`1.AtEndOfSequence" />
    </member>
    <member name="T:Rxx.Parsers.Reactive.IObservableParser`2">
      <summary>
            Represents a parser over an observable sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})">
      <summary>
            Subscribes to the specified observable sequence and applies the parser's grammar, which is defined in 
            terms of the <see cref="P:Rxx.Parsers.Reactive.IObservableParser`2.Next" /> parser, to generate matches asynchronously.
            </summary>
      <param name="source">The observable sequence to parse.</param>
      <returns>An observable sequence of parse results that contain information about the matches.</returns>
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IObservableParser`2.Next">
      <summary>
            Gets a parser with a grammar that matches the next element in the source sequence.
            </summary>
      <remarks>
            A parser's grammar is defined in terms of grammar rules, each of which is defined in terms of the <see cref="P:Rxx.Parsers.Reactive.IObservableParser`2.Next" /> parser
            or another rule.
            </remarks>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:System.Reactive.IObservableCursor`1">
      <summary>
            Represents a shared observable sequence that replays values from a current index that can be moved,
            along with support for optimized branching.
            </summary>
      <remarks>
        <alert type="implementors">
            The contracts of <see cref="T:System.Reactive.IObservableCursor`1" /> rely on some of the properties being immutable.
            The <see cref="P:System.Reactive.IObservableCursor`1.IsSynchronized" /> and <see cref="P:System.Reactive.IObservableCursor`1.IsForwardOnly" /> properties must be immutable.  Furthermore, 
            the <see cref="P:System.Reactive.IObservableCursor`1.IsSequenceTerminated" /> property must be <see langword="false" /> until the sequence terminates, 
            at which time it must return <see langword="true" /> and then hold that value indefinitely.
            </alert>
      </remarks>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <threadsafety instance="false" />
    </member>
    <member name="M:System.Reactive.IObservableCursor`1.Move(System.Int32)">
      <summary>
            Changes the current index of the cursor to the element at the specified number of elements forward or backward.
            </summary>
      <param name="count">The number of elements to move after the current index if the specified count is positive
            or before the current index if the specified count is negative.</param>
      <remarks>
        <para>
            The specified <paramref name="count" /> may be a negative number only if <see cref="P:System.Reactive.IObservableCursor`1.IsForwardOnly" /> is <see langword="false" />.
            </para>
        <alert type="implementors">
            If the specified <paramref name="count" /> is greater than the length from the current element to the latest
            element in the sequence, then the cursor must virtualize itself by skipping subsequent elements until the position 
            of the cursor is reached.
            </alert>
      </remarks>
      <seealso cref="P:System.Reactive.IObservableCursor`1.IsForwardOnly" />
      <requires>!IsForwardOnly || count &gt;= 0</requires>
      <requires>IsSynchronized || !AtEndOfSequence || count &lt;= 0</requires>
      <requires>IsSynchronized || CurrentIndex + count &gt;= 0</requires>
      <requires>IsSynchronized || !IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures>IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures>IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures>IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="M:System.Reactive.IObservableCursor`1.Branch">
      <summary>
            Returns a new cursor that starts at the current position of this cursor and is tied to the lifetime of this cursor.
            </summary>
      <remarks>
        <alert type="implementors">
          <see cref="M:System.Reactive.IObservableCursor`1.Branch" /> provides a means for cursor authors to optimize branches so that they can share the same state.
            </alert>
      </remarks>
      <returns>A new cursor that starts at the current position of this cursor.</returns>
      <ensures>Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;() != null</ensures>
      <ensures>IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures>IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures>IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures>IsSynchronized || AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSynchronized == IsSynchronized</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures>IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures>IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures>IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures>IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)">
      <summary>
            Notifies the provider that an observer is to receive the specified maximum number of <strong>OnNext</strong> notifications.
            </summary>
      <remarks>
        <para>
            This overload to <see cref="M:System.IObservable`1.Subscribe(System.IObserver{`0})" /> behaves similarly except that it has a 
            <paramref name="count" /> parameter that specifies the maximum number of elements that may be pushed to the
            <paramref name="observer" />.  Essentially, it provides an optimized alternative to <see cref="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)" />.
            </para>
        <para>
            The <paramref name="count" /> parameter applies to cursors because they typically will buffer data from the source 
            sequence and replay it to subscribers, starting from the current index and continuing to the latest value that has 
            been buffered.  When a subscriber only wants to view a range of data, then <see cref="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)" /> is often 
            added to the query to specify the number of notifications that are desired; however, the <see cref="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)" /> 
            operator cannot cancel the notifications that are being replayed from the cursor, so it simply drops any additional 
            notifications that exceed the specified limit.  The specified <paramref name="observer" /> will not observe the 
            additional notifications, although the overhead of replaying an entire buffered sequence to the 
            <see cref="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)" /> operator could have a noticeable impact on the performance of your code.  By implementing
            <see cref="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" />, replayed notifications can be stopped  when the specified <paramref name="count" />
            is reached.
            </para>
      </remarks>
      <param name="observer">The object that is to receive notifications.</param>
      <param name="count">The maximum number of elements to be observed.</param>
      <returns>The observer's interface that enables resources to be disposed.</returns>
      <requires>observer != null</requires>
      <requires>count &gt;= 0</requires>
      <ensures>IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures>IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="P:System.Reactive.IObservableCursor`1.IsSynchronized">
      <summary>
            Gets a value indicating whether the cursor's methods and properties can be used concurrently by multiple threads.
            </summary>
      <remarks>
        <alert type="implementors">
          <see cref="P:System.Reactive.IObservableCursor`1.IsSynchronized" /> must be immutable.  Contracts of <see cref="T:System.Reactive.IObservableCursor`1" /> members depend upon it.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the cursor is safe for multi-threaded operations; otherwise, <see langword="false" />.</value>
    </member>
    <member name="P:System.Reactive.IObservableCursor`1.IsForwardOnly">
      <summary>
            Gets a value indicating whether the cursor only moves forward.
            </summary>
      <remarks>
        <alert type="implementors">
          <see cref="P:System.Reactive.IObservableCursor`1.IsForwardOnly" /> must be immutable.  Contracts of <see cref="T:System.Reactive.IObservableCursor`1" /> members depend upon it.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the cursor only moves forward; otherwise, <see langword="false" />.</value>
      <seealso cref="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" />
    </member>
    <member name="P:System.Reactive.IObservableCursor`1.CurrentIndex">
      <summary>
            Gets the zero-based index of the element in the sequence at which the cursor is positioned after 
            <see cref="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" /> is called.
            </summary>
      <remarks>
        <para>
          <see cref="P:System.Reactive.IObservableCursor`1.CurrentIndex" /> starts and remains at 0 until it is changed by the <see cref="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" /> method.  A value of 0 indicates
            that the cursor is positioned at the end of an empty sequence.  If the sequence generates one or more values, then 0 indicates
            that the cursor is positioned at the beginning of the sequence.  Subscribing to a cursor that has not moved replays all values in 
            the sequence, if any.
            </para>
        <para>
            The valid range of values for <see cref="P:System.Reactive.IObservableCursor`1.CurrentIndex" /> changes depending upon whether the sequence has terminated.
            If the sequence has not terminated, then <see cref="P:System.Reactive.IObservableCursor`1.CurrentIndex" /> can be any value that is greater than or equal to zero, 
            even if that value is greater than <see cref="P:System.Reactive.IObservableCursor`1.LatestIndex" />; however, once the sequence has terminated, 
            <see cref="P:System.Reactive.IObservableCursor`1.CurrentIndex" /> cannot be moved past one more than the <see cref="P:System.Reactive.IObservableCursor`1.LatestIndex" />.  This final position 
            indicates that the cursor is at the end of the sequence.  Calling <see cref="M:System.IObservable`1.Subscribe(System.IObserver{`0})" /> on a cursor that is 
            positioned at the end of the sequence causes only the termination notification to be pushed, without replaying any values.
            </para>
        <para>
            If <see cref="P:System.Reactive.IObservableCursor`1.CurrentIndex" /> is moved past the latest element in the sequence, as indicated by the value of 
            <see cref="P:System.Reactive.IObservableCursor`1.LatestIndex" />, then the existing values in the sequence will not be replayed to new subscriptions; 
            furthermore, any new values with indices that are less than <see cref="P:System.Reactive.IObservableCursor`1.CurrentIndex" /> will also be excluded from
            new subscriptions.
            </para>
        <alert type="implementors">
            If the current index is positioned ahead of the latest element in the sequence and the sequence 
            subsequently ends, then the current index must automatically be changed to <see cref="P:System.Reactive.IObservableCursor`1.LatestIndex" /> + 1 to indicate 
            that the current index is at the end of the sequence.  Consumers can check whether <see cref="P:System.Reactive.IObservableCursor`1.CurrentIndex" /> has changed 
            during the <strong>OnCompleted</strong> notification.
            </alert>
      </remarks>
      <value>The zero-based index of the element in the sequence on which the cursor is positioned after 
            <see cref="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" /> is called; otherwise, -1.</value>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures>IsSynchronized || !IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.IObservableCursor`1.LatestIndex">
      <summary>
            Gets the zero-based index of the last known element in the sequence.
            </summary>
      <value>The zero-based index of the last known element in the sequence; -1 until the sequence produces an element, if any.
            If the sequence has terminated, then the value is the index of the last element in the sequence.</value>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.IObservableCursor`1.AtEndOfSequence">
      <summary>
            Gets a value indicating whether the cursor is positioned at the end of the sequence.
            </summary>
      <remarks>
        <alert type="note">
            When <see cref="P:System.Reactive.IObservableCursor`1.AtEndOfSequence" /> returns <see langword="false" /> it does not indicate that the sequence has 
            not terminated.  It only indicates that the cursor is not currently positioned at the end of the sequence,
            regardless of whether the sequence has actually terminated or not.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the sequence has terminated and the cursor is currently positioned at the end of the sequence;
            otherwise, <see langword="false" />.</value>
      <seealso cref="P:System.Reactive.IObservableCursor`1.IsSequenceTerminated" />
      <getter>
        <ensures>!Contract.Result&lt;bool&gt;() || IsSequenceTerminated</ensures>
        <ensures>IsSynchronized || Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.IObservableCursor`1.IsSequenceTerminated">
      <summary>
            Gets a value indicating whether the sequence has terminated.
            </summary>
      <remarks>
        <alert type="note">
            When <see cref="P:System.Reactive.IObservableCursor`1.IsSequenceTerminated" /> returns <see langword="true" /> it does not indicate that the cursor is at the
            end of the sequence.  It only indicates that the sequence has terminated, regardless of whether the cursor is actually 
            positioned at the end of the sequence or not.
            </alert>
        <alert type="implementors">
          <see cref="P:System.Reactive.IObservableCursor`1.IsSequenceTerminated" /> must be immutable when it returns <see langword="true" />.  Contracts of 
            <see cref="T:System.Reactive.IObservableCursor`1" /> members depend upon it.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the sequence has terminated; otherwise, <see langword="false" />.</value>
      <seealso cref="P:System.Reactive.IObservableCursor`1.AtEndOfSequence" />
    </member>
    <member name="P:System.Reactive.IObservableCursor`1.IsDisposed">
      <summary>
            Gets a value indicating whether the cursor is disposed.
            </summary>
      <value>
        <see langword="True" /> if the cursor is disposed; otherwise, <see langword="false" />.</value>
    </member>
    <member name="T:System.IO.ObservableFile">
      <summary>
            Provides <see langword="static" /> methods for monitoring files.
            </summary>
    </member>
    <member name="M:System.IO.ObservableFile.Watch(System.String)">
      <summary>
            Creates an observable sequence of bytes by asynchronously reading from the specified <paramref name="file" /> when data is appended.
            </summary>
      <param name="file">The path to a file from which bytes are read as data becomes available.</param>
      <remarks>
            The generated sequence is intended to match the contents of the specified file;
            however, specific changes to the file are not detected.  Only the date/time of the last write is monitored for changes.
            All changes to the date/time of the last write to the file are assumed to indicate that new data has been appended to the 
            end of the file.  Data that is overwritten in the file after it has already been read does not affect the generated sequence
            as long as the overwrite doesn't exceed the end of the file.  It is the responsibility of consumers to prevent the file from 
            being deleted, truncated or mutated in any other way that may cause I/O errors or may cause the generated sequence to contain 
            unexpected data.
            </remarks>
      <returns>An observable sequence of byte arrays of a default maximum size read from the specified <paramref name="file" />.</returns>
      <requires>file != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableFile.Watch(System.String,System.Int32)">
      <summary>
            Creates an observable sequence of bytes by asynchronously reading from the specified <paramref name="file" /> when data is appended.
            </summary>
      <param name="file">The path to a file from which bytes are read as data becomes available.</param>
      <param name="bufferSize">The maximum length of each byte array that is read.</param>
      <remarks>
            The generated sequence is intended to match the contents of the specified file;
            however, specific changes to the file are not detected.  Only the date/time of the last write is monitored for changes.
            All changes to the date/time of the last write to the file are assumed to indicate that new data has been appended to the 
            end of the file.  Data that is overwritten in the file after it has already been read does not affect the generated sequence
            as long as the overwrite doesn't exceed the end of the file.  It is the responsibility of consumers to prevent the file from 
            being deleted, truncated or mutated in any other way that may cause I/O errors or may cause the generated sequence to contain 
            unexpected data.
            </remarks>
      <returns>An observable sequence of byte arrays of the specified maximum size read from the specified <paramref name="file" />.</returns>
      <requires>file != null</requires>
      <requires>bufferSize &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableFile.Watch(System.String,System.Text.Encoding)">
      <summary>
            Creates an observable sequence by reading from the specified <paramref name="file" /> when data is appended.
            </summary>
      <param name="file">The path to a file from which text is read as it becomes available.</param>
      <param name="encoding">The character encoding to use.</param>
      <remarks>
            The generated sequence is intended to match the contents of the specified file;
            however, specific changes to the file are not detected.  Only the date/time of the last write is monitored for changes.
            All changes to the date/time of the last write to the file are assumed to indicate that new data has been appended to the 
            end of the file.  Data that is overwritten in the file after it has already been read does not affect the generated sequence
            as long as the overwrite doesn't exceed the end of the file.  It is the responsibility of consumers to prevent the file from 
            being deleted, truncated or mutated in any other way that may cause I/O errors or may cause the generated sequence to contain 
            unexpected data.
            </remarks>
      <returns>An observable sequence of strings read from the specified <paramref name="file" />.</returns>
      <requires>file != null</requires>
      <requires>encoding != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableFile.Watch(System.String,System.Text.Encoding,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Creates an observable sequence by reading from the specified <paramref name="file" /> when data is appended.
            </summary>
      <param name="file">The path to a file from which text is read as it becomes available.</param>
      <param name="encoding">The character encoding to use.</param>
      <param name="scheduler">An object used to schedule reads.</param>
      <remarks>
            The generated sequence is intended to match the contents of the specified file;
            however, specific changes to the file are not detected.  Only the date/time of the last write is monitored for changes.
            All changes to the date/time of the last write to the file are assumed to indicate that new data has been appended to the 
            end of the file.  Data that is overwritten in the file after it has already been read does not affect the generated sequence
            as long as the overwrite doesn't exceed the end of the file.  It is the responsibility of consumers to prevent the file from 
            being deleted, truncated or mutated in any other way that may cause I/O errors or may cause the generated sequence to contain 
            unexpected data.
            </remarks>
      <returns>An observable sequence of strings read from the specified <paramref name="file" />.</returns>
      <requires>file != null</requires>
      <requires>encoding != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableFile.WatchLines(System.String,System.Text.Encoding)">
      <summary>
            Creates an observable sequence by reading lines from the specified <paramref name="file" /> when data is appended.
            </summary>
      <param name="file">The path to a file from which lines are read as they become available.</param>
      <param name="encoding">The character encoding to use.</param>
      <remarks>
        <alert type="warning">
          <para>
            This method never calls <strong>OnCompleted</strong> since there's no indication of when writing to the file has ended.
            As a result, the last line in the file is not read unless it ends with new line characters.
            </para>
          <para>
            Until new line characters are read, the last line remains buffered without any indication of when the file has ended.
            Having an observable parameter or function that indicates when writing to the stream has completed is unreliable because of
            race conditions between the internal <see cref="T:System.IO.FileSystemWatcher" /> and the caller's notion of completion.  For example, if the
            caller notifies that writing has completed as soon as the last line is written, then the <see cref="T:System.IO.FileSystemWatcher" /> may not 
            have a chance to read the last line.
            </para>
        </alert>
        <para>
            The generated sequence is intended to match the contents of the specified file;
            however, specific changes to the file are not detected.  Only the date/time of the last write is monitored for changes.
            All changes to the date/time of the last write to the file are assumed to indicate that new data has been appended to the 
            end of the file.  Data that is overwritten in the file after it has already been read does not affect the generated sequence
            as long as the overwrite doesn't exceed the end of the file.  It is the responsibility of consumers to prevent the file from 
            being deleted, truncated or mutated in any other way that may cause I/O errors or may cause the generated sequence to contain 
            unexpected data.
            </para>
      </remarks>
      <returns>An observable sequence of lines read from the specified <paramref name="file" />.</returns>
      <requires>file != null</requires>
      <requires>encoding != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableFile.WatchLines(System.String,System.Text.Encoding,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Creates an observable sequence by reading lines from the specified <paramref name="file" /> when data is appended.
            </summary>
      <param name="file">The path to a file from which lines are read as they become available.</param>
      <param name="encoding">The character encoding to use.</param>
      <param name="scheduler">An object used to schedule reads.</param>
      <remarks>
        <alert type="warning">
          <para>
            This method never calls <strong>OnCompleted</strong> since there's no indication of when writing to the file has ended.
            As a result, the last line in the file is not read unless it ends with new line characters.
            </para>
          <para>
            Until new line characters are read, the last line remains buffered without any indication of when the file has ended.
            Having an observable parameter or function that indicates when writing to the stream has completed is also unreliable because of
            race conditions between the internal <see cref="T:System.IO.FileSystemWatcher" /> and the caller's notion of completion.  For example, if the
            caller notifies that writing has completed as soon as the last line is written, then the <see cref="T:System.IO.FileSystemWatcher" /> may not 
            have a chance to read the last line.
            </para>
        </alert>
        <para>
            The generated sequence is intended to match the contents of the specified file;
            however, specific changes to the file are not detected.  Only the date/time of the last write is monitored for changes.
            All changes to the date/time of the last write to the file are assumed to indicate that new data has been appended to the 
            end of the file.  Data that is overwritten in the file after it has already been read does not affect the generated sequence
            as long as the overwrite doesn't exceed the end of the file.  It is the responsibility of consumers to prevent the file from 
            being deleted, truncated or mutated in any other way that may cause I/O errors or may cause the generated sequence to contain 
            unexpected data.
            </para>
      </remarks>
      <returns>An observable sequence of lines read from the specified <paramref name="file" />.</returns>
      <requires>file != null</requires>
      <requires>encoding != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.IO.FileStreamExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for <see cref="T:System.IO.FileStream" /> objects.
            </summary>
    </member>
    <member name="M:System.IO.FileStreamExtensions.ToObservable(System.IO.FileStream)">
      <summary>
            Creates an observable sequence of bytes by asynchronously reading to the end of the specified <paramref name="stream" />
            each time the underlying file is updated and advances the position within the stream to the end.
            </summary>
      <param name="stream">The object from which bytes are read as data becomes available.</param>
      <remarks>
        <para>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the underlying file is updated on disc, reading is expected to begin at the previous position 
            in the stream, but if the stream is shared or it's not well-behaved, then the generated sequence may contain unexpected data.
            </para>
        <para>
            Furthermore, specific changes to the file are not detected.  Only the date/time of the last write is monitored for changes.
            All changes to the date/time of the last write to the file are assumed to indicate that new data has been appended to the 
            end of the file.  If data is overwritten in the file after it has already been read from the specified stream, then the last
            write date/time will be updated causing the stream to be read again, although it will already be at the end of the file so 
            nothing will happen.  It is the responsibility of consumers to prevent the file from being deleted, truncated or mutated in 
            any other way that may cause I/O errors or may cause the generated sequence to contain unexpected data.
            </para>
      </remarks>
      <returns>An observable sequence of byte arrays of a default maximum size read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.FileStreamExtensions.ToObservable(System.IO.FileStream,System.Int32)">
      <summary>
            Creates an observable sequence of bytes by asynchronously reading to the end of the specified <paramref name="stream" />
            each time the underlying file is updated and advances the position within the stream to the end.
            </summary>
      <param name="stream">The object from which bytes are read as data becomes available.</param>
      <param name="bufferSize">The maximum length of each byte array that is read.</param>
      <remarks>
        <para>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the underlying file is updated on disc, reading is expected to begin at the previous position 
            in the stream, but if the stream is shared or it's not well-behaved, then the generated sequence may contain unexpected data.
            </para>
        <para>
            Furthermore, specific changes to the file are not detected.  Only the date/time of the last write is monitored for changes.
            All changes to the date/time of the last write to the file are assumed to indicate that new data has been appended to the 
            end of the file.  If data is overwritten in the file after it has already been read from the specified stream, then the last
            write date/time will be updated causing the stream to be read again, although it will already be at the end of the file so 
            nothing will happen.  It is the responsibility of consumers to prevent the file from being deleted, truncated or mutated in 
            any other way that may cause I/O errors or may cause the generated sequence to contain unexpected data.
            </para>
      </remarks>
      <returns>An observable sequence of byte arrays of the specified maximum size read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>bufferSize &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.FileStreamExtensions.ToObservable(System.IO.FileStream,System.Text.Encoding)">
      <summary>
            Creates an observable sequence by reading to the end of the specified <paramref name="stream" /> 
            each time the underlying file is updated and advances the position within the stream to the end.
            </summary>
      <param name="stream">The object from which text is read as it becomes available.</param>
      <param name="encoding">The character encoding to use.</param>
      <remarks>
        <para>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the underlying file is updated on disc, reading is expected to begin at the previous position 
            in the stream, but if the stream is shared or it's not well-behaved, then the generated sequence may contain unexpected data.
            </para>
        <para>
            Furthermore, specific changes to the file are not detected.  Only the date/time of the last write is monitored for changes.
            All changes to the date/time of the last write to the file are assumed to indicate that new data has been appended to the 
            end of the file.  If data is overwritten in the file after it has already been read from the specified stream, then the last
            write date/time will be updated causing the stream to be read again, although it will already be at the end of the file so 
            nothing will happen.  It is the responsibility of consumers to prevent the file from being deleted, truncated or mutated in 
            any other way that may cause I/O errors or may cause the generated sequence to contain unexpected data.
            </para>
      </remarks>
      <returns>An observable sequence of strings read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>encoding != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.FileStreamExtensions.ToObservable(System.IO.FileStream,System.Text.Encoding,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Creates an observable sequence by reading to the end of the specified <paramref name="stream" />
            each time the underlying file is updated and advances the position within the stream to the end.
            </summary>
      <param name="stream">The object from which text is read as it becomes available.</param>
      <param name="encoding">The character encoding to use.</param>
      <param name="scheduler">An object used to schedule reads.</param>
      <remarks>
        <para>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the underlying file is updated on disc, reading is expected to begin at the previous position 
            in the stream, but if the stream is shared or it's not well-behaved, then the generated sequence may contain unexpected data.
            </para>
        <para>
            Furthermore, specific changes to the file are not detected.  Only the date/time of the last write is monitored for changes.
            All changes to the date/time of the last write to the file are assumed to indicate that new data has been appended to the 
            end of the file.  If data is overwritten in the file after it has already been read from the specified stream, then the last
            write date/time will be updated causing the stream to be read again, although it will already be at the end of the file so 
            nothing will happen.  It is the responsibility of consumers to prevent the file from being deleted, truncated or mutated in 
            any other way that may cause I/O errors or may cause the generated sequence to contain unexpected data.
            </para>
      </remarks>
      <returns>An observable sequence of strings read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>encoding != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.FileStreamExtensions.ToObservableLines(System.IO.FileStream,System.Text.Encoding)">
      <summary>
            Creates an observable sequence by reading lines to the end of the specified <paramref name="stream" /> 
            each time the underlying file is updated and advances the position within the stream to the end.
            </summary>
      <param name="stream">The object from which lines are read as they become available.</param>
      <param name="encoding">The character encoding to use.</param>
      <remarks>
        <alert type="warning">
          <para>
            This method never calls <strong>OnCompleted</strong> since there's no indication of when writing to the stream has ended.
            As a result, the last line in the file is not read unless it ends with new line characters.
            </para>
          <para>
            Until new line characters are read, the last line remains buffered without any indication of when the stream has ended.
            Closing the <paramref name="stream" /> will result in an exception being thrown on the next attempt to read from the closed stream, 
            although waiting for an exception is unreliable as a completion indicator because the stream may write to the file exclusively, 
            in which case closing the stream some time after the last line has been read and buffered will not result in an exception later 
            since the internal <see cref="T:System.IO.FileSystemWatcher" /> will not raise any additional change events and there will be no further attempts 
            to read from the stream.
            </para>
          <para>
            Having an observable parameter or function that indicates when writing to the stream has completed is also unreliable because of
            race conditions between the internal <see cref="T:System.IO.FileSystemWatcher" /> and the caller's notion of completion.  For example, if the
            caller notifies that writing has completed as soon as the last line is written, then the <see cref="T:System.IO.FileSystemWatcher" /> may not 
            have a chance to read the last line.
            </para>
        </alert>
        <para>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the underlying file is updated on disc, reading is expected to begin at the previous position 
            in the stream, but if the stream is shared or it's not well-behaved, then the generated sequence may contain unexpected data.
            </para>
        <para>
            Furthermore, specific changes to the file are not detected.  Only the date/time of the last write is monitored for changes.
            All changes to the date/time of the last write to the file are assumed to indicate that new data has been appended to the 
            end of the file.  If data is overwritten in the file after it has already been read from the specified stream, then the last
            write date/time will be updated causing the stream to be read again, although it will already be at the end of the file so 
            nothing will happen.  It is the responsibility of consumers to prevent the file from being deleted, truncated or mutated in 
            any other way that may cause I/O errors or may cause the generated sequence to contain unexpected data.
            </para>
      </remarks>
      <returns>An observable sequence of lines read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>encoding != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.FileStreamExtensions.ToObservableLines(System.IO.FileStream,System.Text.Encoding,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Creates an observable sequence by reading lines to the end of the specified <paramref name="stream" /> 
            each time the underlying file is updated and advances the position within the stream to the end.
            </summary>
      <param name="stream">The object from which lines are read as they become available.</param>
      <param name="encoding">The character encoding to use.</param>
      <param name="scheduler">An object used to schedule reads.</param>
      <remarks>
        <alert type="warning">
          <para>
            This method never calls <strong>OnCompleted</strong> since there's no indication of when writing to the stream has ended.
            As a result, the last line in the file is not read unless it ends with new line characters.
            </para>
          <para>
            Until new line characters are read, the last line remains buffered without any indication of when the stream has ended.
            Closing the <paramref name="stream" /> will result in an exception being thrown on the next attempt to read from the closed stream, 
            although waiting for an exception is unreliable as a completion indicator because the stream may write to the file exclusively, 
            in which case closing the stream some time after the last line has been read and buffered will not result in an exception later 
            since the internal <see cref="T:System.IO.FileSystemWatcher" /> will not raise any additional change events and there will be no further attempts 
            to read from the stream.
            </para>
          <para>
            Having an observable parameter or function that indicates when writing to the stream has completed is also unreliable because of
            race conditions between the internal <see cref="T:System.IO.FileSystemWatcher" /> and the caller's notion of completion.  For example, if the
            caller notifies that writing has completed as soon as the last line is written, then the <see cref="T:System.IO.FileSystemWatcher" /> may not 
            have a chance to read the last line.
            </para>
        </alert>
        <para>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the underlying file is updated on disc, reading is expected to begin at the previous position 
            in the stream, but if the stream is shared or it's not well-behaved, then the generated sequence may contain unexpected data.
            </para>
        <para>
            Furthermore, specific changes to the file are not detected.  Only the date/time of the last write is monitored for changes.
            All changes to the date/time of the last write to the file are assumed to indicate that new data has been appended to the 
            end of the file.  If data is overwritten in the file after it has already been read from the specified stream, then the last
            write date/time will be updated causing the stream to be read again, although it will already be at the end of the file so 
            nothing will happen.  It is the responsibility of consumers to prevent the file from being deleted, truncated or mutated in 
            any other way that may cause I/O errors or may cause the generated sequence to contain unexpected data.
            </para>
      </remarks>
      <returns>An observable sequence of lines read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>encoding != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.IO.TextReaderExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for <see cref="T:System.IO.TextReader" /> objects.
            </summary>
    </member>
    <member name="M:System.IO.TextReaderExtensions.ToObservable``1(System.IO.TextReader,System.IObservable{``0})">
      <summary>
            Creates an observable sequence by reading to the end of the specified <paramref name="reader" /> each time 
            the <paramref name="textAvailable" /> sequence notifies that additional text is available to be read
            and advances the position within the reader to the end of the stream.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when text is available to be read.</typeparam>
      <param name="reader">The object from which text is read as it becomes available.</param>
      <param name="textAvailable">An observable sequence that notifies when additional text is available to be read.</param>
      <remarks>
            The generated sequence is intended to match the underlying stream; however, this behavior 
            depends on whether the reader is well-behaved and whether the reader is not being shared.  Reading always starts from the 
            current position of the reader in the underlying stream.  The reader is expected to increment its position in the stream
            when it's read.  Each time that the <paramref name="textAvailable" /> sequence notifies that additional text is available, 
            reading is expected to begin at the previous position in the stream, but if the reader is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </remarks>
      <returns>An observable sequence of strings read from the specified <paramref name="reader" />.</returns>
      <requires>reader != null</requires>
      <requires>textAvailable != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.TextReaderExtensions.ToObservable``1(System.IO.TextReader,System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Creates an observable sequence by reading to the end of the specified <paramref name="reader" /> each time 
            the <paramref name="textAvailable" /> sequence notifies that additional text is available to be read
            and advances the position within the reader to the end of the stream.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when text is available to be read.</typeparam>
      <param name="reader">The object from which text is read as it becomes available.</param>
      <param name="textAvailable">An observable sequence that notifies when additional text is available to be read.</param>
      <param name="scheduler">An object used to schedule reads.</param>
      <remarks>
            The generated sequence is intended to match the underlying stream; however, this behavior 
            depends on whether the reader is well-behaved and whether the reader is not being shared.  Reading always starts from the 
            current position of the reader in the underlying stream.  The reader is expected to increment its position in the stream
            when it's read.  Each time that the <paramref name="textAvailable" /> sequence notifies that additional text is available, 
            reading is expected to begin at the previous position in the stream, but if the reader is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </remarks>
      <returns>An observable sequence of strings read from the specified <paramref name="reader" />.</returns>
      <requires>reader != null</requires>
      <requires>textAvailable != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.TextReaderExtensions.ToObservableLines``1(System.IO.TextReader,System.IObservable{``0})">
      <summary>
            Creates an observable sequence by reading lines to the end of the specified <paramref name="reader" /> each time 
            the <paramref name="textAvailable" /> sequence notifies that additional text is available to be read
            and advances the position within the reader to the end of the stream.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when text is available to be read.</typeparam>
      <param name="reader">The object from which lines are read as they become available.</param>
      <param name="textAvailable">An observable sequence that notifies when additional text is available to be read.</param>
      <remarks>
        <para>
            The <paramref name="textAvailable" /> sequence does not have to notify when new lines are available.  It only must notify when 
            new text is available, which may or may not have new lines.  Characters that are read up to the end of the stream are automatically
            buffered until a new line sequence is encountered in a subsequent read.  A consequence of this behavior is that if the stream does
            not end with a new line sequence and it's not going to receive any more text, then the last line will not be read until 
            <paramref name="textAvailable" /> calls <strong>OnCompleted</strong>.
            </para>
        <para>
            The generated sequence is intended to match the underlying stream; however, this behavior 
            depends on whether the reader is well-behaved and whether the reader is not being shared.  Reading always starts from the 
            current position of the reader in the underlying stream.  The reader is expected to increment its position in the stream
            when it's read.  Each time that the <paramref name="textAvailable" /> sequence notifies that additional text is available, 
            reading is expected to begin at the previous position in the stream, but if the reader is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </para>
      </remarks>
      <returns>An observable sequence of lines read from the specified <paramref name="reader" />.</returns>
      <requires>reader != null</requires>
      <requires>textAvailable != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.TextReaderExtensions.ToObservableLines``1(System.IO.TextReader,System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Creates an observable sequence by reading lines to the end of the specified <paramref name="reader" /> each time 
            the <paramref name="textAvailable" /> sequence notifies that additional text is available to be read
            and advances the position within the reader to the end of the stream.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when text is available to be read.</typeparam>
      <param name="reader">The object from which lines are read as they become available.</param>
      <param name="textAvailable">An observable sequence that notifies when additional text is available to be read.</param>
      <param name="scheduler">An object used to schedule reads.</param>
      <remarks>
        <para>
            The <paramref name="textAvailable" /> sequence does not have to notify when new lines are available.  It only must notify when 
            new text is available, which may or may not have new lines.  Characters that are read up to the end of the stream are automatically
            buffered until a new line sequence is encountered in a subsequent read.  A consequence of this behavior is that if the stream does
            not end with a new line sequence and it's not going to receive any more text, then the last line will not be read until 
            <paramref name="textAvailable" /> calls <strong>OnCompleted</strong>.
            </para>
        <para>
            The generated sequence is intended to match the underlying stream; however, this behavior 
            depends on whether the reader is well-behaved and whether the reader is not being shared.  Reading always starts from the 
            current position of the reader in the underlying stream.  The reader is expected to increment its position in the stream
            when it's read.  Each time that the <paramref name="textAvailable" /> sequence notifies that additional text is available, 
            reading is expected to begin at the previous position in the stream, but if the reader is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </para>
      </remarks>
      <returns>An observable sequence of lines read from the specified <paramref name="reader" />.</returns>
      <requires>reader != null</requires>
      <requires>textAvailable != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.IO.StreamExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for <see cref="T:System.IO.Stream" /> objects.
            </summary>
    </member>
    <member name="M:System.IO.StreamExtensions.WriteObservable(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
      <summary>
            Writes a section of bytes asynchronously from the specified <paramref name="buffer" /> into the specified <paramref name="stream" /> 
            and advances the position within the stream by the number of bytes written.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" /> to which the <paramref name="buffer" /> is written.</param>
      <param name="buffer">The buffer to write data from.</param>
      <param name="offset">The byte offset in <paramref name="buffer" /> from which to begin writing.</param>
      <param name="count">The maximum number of bytes to write.</param>
      <returns>A scalar observable sequence that indicates when the data has been written.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanWrite</requires>
      <requires>buffer != null</requires>
      <requires>offset &gt;= 0</requires>
      <requires>count &gt;= 0</requires>
      <requires>offset + count &lt;= buffer.Length</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ReadObservable(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
      <summary>
            Reads bytes asynchronously from the specified <paramref name="stream" /> into the specified <paramref name="buffer" /> 
            and advances the position within the stream by the number of bytes read.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" /> to be read.</param>
      <param name="buffer">The buffer to read the data into.</param>
      <param name="offset">The byte offset in <paramref name="buffer" /> at which to begin writing data read from the <paramref name="stream" />.</param>
      <param name="count">The maximum number of bytes to read.</param>
      <returns>A scalar observable sequence containing the total number of bytes read into the buffer.  This can be 
            less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end
            of the stream has been reached.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanWrite</requires>
      <requires>buffer != null</requires>
      <requires>offset &gt;= 0</requires>
      <requires>count &gt;= 0</requires>
      <requires>offset + count &lt;= buffer.Length</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ReadObservable(System.IO.Stream,System.Int32)">
      <summary>
            Reads bytes asynchronously from the specified <paramref name="stream" /> and advances the position within the stream
            by the number of bytes read.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" /> to be read.</param>
      <param name="count">The maximum number of bytes to read.</param>
      <returns>A scalar observable sequence containing the byte array that is read.  The length of the array can be 
            less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end 
            of the stream has been reached.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>count &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ReadToEndObservable(System.IO.Stream)">
      <summary>
            Creates an observable sequence by asynchronously reading bytes from the current position to the end of the specified <paramref name="stream" />
            and advances the position within the stream to the end.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" /> to be read.</param>
      <returns>An observable sequence of byte arrays of a default maximum size read from the current position to the end of the 
            specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ReadToEndObservable(System.IO.Stream,System.Int32)">
      <summary>
            Creates an observable sequence by asynchronously reading bytes from the current position to the end of the specified <paramref name="stream" />
            and advances the position within the stream to the end.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" /> to be read.</param>
      <param name="bufferSize">The maximum length of each byte array that is read.</param>
      <returns>An observable sequence of byte arrays of the specified maximum size read from the current position to the end of the 
            specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>bufferSize &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ToObservable``1(System.IO.Stream,System.IObservable{``0})">
      <summary>
            Creates an observable sequence of bytes by asynchronously reading to the end of the specified <paramref name="stream" /> each time 
            the <paramref name="dataAvailable" /> sequence notifies that additional data is available to be read
            and advances the position within the stream to the end.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when data is available to be read.</typeparam>
      <param name="stream">The object from which bytes are read as data becomes available.</param>
      <param name="dataAvailable">An observable sequence that notifies when additional data is available to be read.</param>
      <remarks>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the <paramref name="dataAvailable" /> sequence notifies that additional data is available, 
            reading is expected to begin at the previous position in the stream, but if the stream is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </remarks>
      <returns>An observable sequence of byte arrays of a default maximum size read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>dataAvailable != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ToObservable``1(System.IO.Stream,System.Int32,System.IObservable{``0})">
      <summary>
            Creates an observable sequence of bytes by asynchronously reading to the end of the specified <paramref name="stream" /> each time 
            the <paramref name="dataAvailable" /> sequence notifies that additional data is available to be read
            and advances the position within the stream to the end.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when data is available to be read.</typeparam>
      <param name="stream">The object from which bytes are read as data becomes available.</param>
      <param name="bufferSize">The maximum length of each byte array that is read.</param>
      <param name="dataAvailable">An observable sequence that notifies when additional data is available to be read.</param>
      <remarks>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the <paramref name="dataAvailable" /> sequence notifies that additional data is available, 
            reading is expected to begin at the previous position in the stream, but if the stream is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </remarks>
      <returns>An observable sequence of byte arrays of the specified maximum size read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>bufferSize &gt; 0</requires>
      <requires>dataAvailable != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ToObservable``1(System.IO.Stream,System.Text.Encoding,System.IObservable{``0})">
      <summary>
            Creates an observable sequence by asynchronously reading to the end of the specified <paramref name="stream" /> each time 
            the <paramref name="textAvailable" /> sequence notifies that additional text is available to be read
            and advances the position within the stream to the end.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when text is available to be read.</typeparam>
      <param name="stream">The object from which text is read as it becomes available.</param>
      <param name="encoding">The character encoding to use.</param>
      <param name="textAvailable">An observable sequence that notifies when additional text is available to be read.</param>
      <remarks>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the <paramref name="textAvailable" /> sequence notifies that additional data is available, 
            reading is expected to begin at the previous position in the stream, but if the stream is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </remarks>
      <returns>An observable sequence of strings read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>encoding != null</requires>
      <requires>textAvailable != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ToObservable``1(System.IO.Stream,System.Text.Encoding,System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Creates an observable sequence by asynchronously reading to the end of the specified <paramref name="stream" /> each time 
            the <paramref name="textAvailable" /> sequence notifies that additional text is available to be read
            and advances the position within the stream to the end.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when text is available to be read.</typeparam>
      <param name="stream">The object from which text is read as it becomes available.</param>
      <param name="encoding">The character encoding to use.</param>
      <param name="textAvailable">An observable sequence that notifies when additional text is available to be read.</param>
      <param name="scheduler">An object used to schedule reads.</param>
      <remarks>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the <paramref name="textAvailable" /> sequence notifies that additional data is available, 
            reading is expected to begin at the previous position in the stream, but if the stream is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </remarks>
      <returns>An observable sequence of strings read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>encoding != null</requires>
      <requires>textAvailable != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ToObservableLines``1(System.IO.Stream,System.Text.Encoding,System.IObservable{``0})">
      <summary>
            Creates an observable sequence by reading lines to the end of the specified <paramref name="stream" /> each time 
            the <paramref name="textAvailable" /> sequence notifies that additional text is available to be read
            and advances the position within the stream to the end.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when text is available to be read.</typeparam>
      <param name="stream">The object from which lines are read as they become available.</param>
      <param name="encoding">The character encoding to use.</param>
      <param name="textAvailable">An observable sequence that notifies when additional text is available to be read.</param>
      <remarks>
        <para>
            The <paramref name="textAvailable" /> sequence does not have to notify when new lines are available.  It only must notify when 
            new text is available, which may or may not have new lines.  Characters that are read up to the end of the stream are automatically
            buffered until a new line sequence is encountered in a subsequent read.  A consequence of this behavior is that if the stream does
            not end with a new line sequence and it's not going to receive any more text, then the last line will not be read until 
            <paramref name="textAvailable" /> calls <strong>OnCompleted</strong>.
            </para>
        <para>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the <paramref name="textAvailable" /> sequence notifies that additional text is available, 
            reading is expected to begin at the previous position in the stream, but if the stream is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </para>
      </remarks>
      <returns>An observable sequence of lines read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>encoding != null</requires>
      <requires>textAvailable != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ToObservableLines``1(System.IO.Stream,System.Text.Encoding,System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Creates an observable sequence by reading lines to the end of the specified <paramref name="stream" /> each time 
            the <paramref name="textAvailable" /> sequence notifies that additional text is available to be read
            and advances the position within the stream to the end.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when text is available to be read.</typeparam>
      <param name="stream">The object from which lines are read as they become available.</param>
      <param name="encoding">The character encoding to use.</param>
      <param name="textAvailable">An observable sequence that notifies when additional text is available to be read.</param>
      <param name="scheduler">An object used to schedule reads.</param>
      <remarks>
        <para>
            The <paramref name="textAvailable" /> sequence does not have to notify when new lines are available.  It only must notify when 
            new text is available, which may or may not have new lines.  Characters that are read up to the end of the stream are automatically
            buffered until a new line sequence is encountered in a subsequent read.  A consequence of this behavior is that if the stream does
            not end with a new line sequence and it's not going to receive any more text, then the last line will not be read until 
            <paramref name="textAvailable" /> calls <strong>OnCompleted</strong>.
            </para>
        <para>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the <paramref name="textAvailable" /> sequence notifies that additional text is available, 
            reading is expected to begin at the previous position in the stream, but if the stream is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </para>
      </remarks>
      <returns>An observable sequence of lines read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>encoding != null</requires>
      <requires>textAvailable != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="F:System.Linq.Cursor`1.firstElementIndex">
      <summary>
            Stores the index offset, relative to the source sequence, of the first value in the <see cref="F:System.Linq.Cursor`1.elements" /> list.
            </summary>
      <remarks>
            This field is used as part of a memory optimization in a forward-only cursor that allows elements to be removed
            when the cursor and all dependent branches have moved passed them, consequently offsetting the indexes in the 
            <see cref="F:System.Linq.Cursor`1.elements" /> list with respect to the actual source sequence.
            </remarks>
    </member>
    <member name="M:System.Linq.Cursor`1.Reset">
      <summary>
            Clears any buffered elements, branches and state, and ensures that a subsequent iteration will re-enumerate the source sequence.
            </summary>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">CurrentIndex == 0</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">LatestIndex == -1</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">!IsSequenceTerminated</ensures>
    </member>
    <member name="T:System.Linq.Enumerable2">
      <summary>
            Provides a set of <see langword="static" /> methods for query operations over enumerable sequences.
            </summary>
    </member>
    <member name="M:System.Linq.Enumerable2.ToCursor``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns a cursor for the specified enumerable sequence.
            </summary>
      <typeparam name="TSource">The type of objects to enumerate.</typeparam>
      <param name="source">The enumerable sequence that the cursor moves over.</param>
      <remarks>
            The cursor's <see cref="P:System.Linq.ICursor`1.IsForwardOnly" /> property returns <see langword="false" />, 
            indicating that it can move forward and backward.
            </remarks>
      <returns>A cursor for the specified enumerable sequence.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;ICursor&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.Enumerable2.ToCursor``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
      <summary>
            Returns a cursor for the specified enumerable sequence with the specified support for backward movement.
            </summary>
      <typeparam name="TSource">The type of objects to enumerate.</typeparam>
      <param name="source">The enumerable sequence that the cursor moves over.</param>
      <param name="forwardOnly">Specifies whether the cursor only moves forward.</param>
      <returns>A cursor for the specified enumerable sequence with the specified support for backward movement.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;ICursor&lt;TSource&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;TSource&gt;&gt;().IsForwardOnly == forwardOnly</ensures>
    </member>
    <member name="M:System.Linq.Enumerable2.Remainder``1(System.Linq.ICursor{``0},System.Int32)">
      <summary>
            Branches from the specified <paramref name="cursor" /> and moves the branch forward the specified number of elements.
            </summary>
      <typeparam name="TSource">The type of objects to enumerate.</typeparam>
      <param name="cursor">The enumerable cursor from which to branch.</param>
      <param name="skip">The number of elements that the new branch must skip.</param>
      <returns>A new branch from the specified <paramref name="cursor" /> with its current index moved ahead the specified 
            number of elements.</returns>
      <requires>cursor != null</requires>
      <requires>skip &gt;= 0</requires>
      <ensures>cursor.IsForwardOnly == Contract.OldValue(cursor.IsForwardOnly)</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;TSource&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;TSource&gt;&gt;().IsForwardOnly == cursor.IsForwardOnly</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;TSource&gt;&gt;().IsSequenceTerminated == cursor.IsSequenceTerminated</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;TSource&gt;&gt;().LatestIndex == cursor.LatestIndex</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;TSource&gt;&gt;().CurrentIndex ==
				(cursor.AtEndOfSequence
				? cursor.CurrentIndex
				: cursor.IsSequenceTerminated
					? Math.Min(cursor.CurrentIndex + skip, cursor.LatestIndex + 1)
					: cursor.CurrentIndex + skip)</ensures>
    </member>
    <member name="M:System.Linq.Enumerable2.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.IObserver{``0})">
      <summary>
            Notifies the specified <paramref name="observer" /> of values, an exception and completion, for its side-effects.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values on which to notify the specified <paramref name="observer" />.</param>
      <param name="observer">An object to observe each value in the <paramref name="source" /> sequence, an exception if thrown 
            or completion if the sequence terminates successfully.</param>
      <requires>source != null</requires>
      <requires>observer != null</requires>
    </member>
    <member name="M:System.Linq.Enumerable2.Do``1(System.Collections.Generic.IEnumerable{``0},System.IObserver{``0})">
      <summary>
            Notifies the specified <paramref name="observer" /> of values, an exception and completion, for its side-effects.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values on which to notify the specified <paramref name="observer" />.</param>
      <param name="observer">An object to observe each value in the <paramref name="source" /> sequence, an exception if thrown 
            or completion if the sequence terminates successfully.</param>
      <returns>An enumerable sequence containing the same values as the <paramref name="source" /> sequence.</returns>
    </member>
    <member name="T:System.Reactive.CollectionModificationKind">
      <summary>
            Indicates the type of a collection modification.
            </summary>
    </member>
    <member name="F:System.Reactive.CollectionModificationKind.Add">
      <summary>
            Indicates that an item is to be added to the collection.
            </summary>
    </member>
    <member name="F:System.Reactive.CollectionModificationKind.Remove">
      <summary>
            Indicates that an item is to be removed from the collection.
            </summary>
    </member>
    <member name="F:System.Reactive.CollectionModificationKind.Clear">
      <summary>
            Indicates that all items are to be removed from the collection.
            </summary>
    </member>
    <member name="T:System.Reactive.CollectionModification`1">
      <summary>
            Represents a modifying notification to a collection.
            </summary>
      <typeparam name="T">The object that provides modification information.</typeparam>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionModification`1" /> class for derived classes.
            </summary>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Accept(System.Collections.Generic.ICollection{`0})">
      <summary>
            Invokes the collection's method corresponding to the modification.
            </summary>
      <param name="collection">Collection on which to invoke the modification.</param>
      <requires>collection != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)">
      <summary>
            Invokes the delegate corresponding to the modification.
            </summary>
      <param name="add">Delegate to invoke for an <see cref="T:System.Reactive.CollectionModification`1.Add" /> modification.</param>
      <param name="remove">Delegate to invoke for a <see cref="T:System.Reactive.CollectionModification`1.Remove" /> modification.</param>
      <param name="clear">Delegate to invoke for a <see cref="T:System.Reactive.CollectionModification`1.Clear" /> modification.</param>
      <requires>add != null</requires>
      <requires>remove != null</requires>
      <requires>clear != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <summary>
            Invokes the delegate corresponding to the modification and returns the produced result.
            </summary>
      <typeparam name="TResult">Type of the produced result.</typeparam>
      <param name="add">Delegate to invoke for an <see cref="T:System.Reactive.CollectionModification`1.Add" /> modification.</param>
      <param name="remove">Delegate to invoke for a <see cref="T:System.Reactive.CollectionModification`1.Remove" /> modification.</param>
      <param name="clear">Delegate to invoke for a <see cref="T:System.Reactive.CollectionModification`1.Clear" /> modification.</param>
      <returns>Result produced by the observation.</returns>
      <requires>add != null</requires>
      <requires>remove != null</requires>
      <requires>clear != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.GetHashCode">
      <summary>
            Generates a hash code that is suitable for use when keying a dictionary.
            </summary>
      <returns>A hash code for the modification.</returns>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Equals(System.Reactive.CollectionModification{`0})">
      <summary>
            Compares the specified modification for <see cref="P:System.Reactive.CollectionModification`1.Kind" /> and <see cref="P:System.Reactive.CollectionModification`1.Value" /> equality.
            </summary>
      <param name="other">The other modification to compare.</param>
      <returns>
        <see langword="True" /> if the <see cref="P:System.Reactive.CollectionModification`1.Kind" /> and <see cref="P:System.Reactive.CollectionModification`1.Value" /> of each modification are equal;
            otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Equals(System.Object)">
      <summary>
            Compares the specified modification for <see cref="P:System.Reactive.CollectionModification`1.Kind" /> and <see cref="P:System.Reactive.CollectionModification`1.Value" /> equality.
            </summary>
      <param name="obj">The other modification to compare.</param>
      <returns>
        <see langword="True" /> if the specified object is an instance of <see cref="T:System.Reactive.CollectionModification`1" /> and if
            the <see cref="P:System.Reactive.CollectionModification`1.Kind" /> and <see cref="P:System.Reactive.CollectionModification`1.Value" /> of each modification are equal; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.op_Equality(System.Reactive.CollectionModification{`0},System.Reactive.CollectionModification{`0})">
      <summary>
            Compares the specified modifications for <see cref="P:System.Reactive.CollectionModification`1.Kind" /> and <see cref="P:System.Reactive.CollectionModification`1.Value" /> equality.
            </summary>
      <param name="first">The first modification.</param>
      <param name="second">The second modification.</param>
      <returns>
        <see langword="True" /> if the <see cref="P:System.Reactive.CollectionModification`1.Kind" /> and <see cref="P:System.Reactive.CollectionModification`1.Value" /> of each modification are equal;
            otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.op_Inequality(System.Reactive.CollectionModification{`0},System.Reactive.CollectionModification{`0})">
      <summary>
            Compares the specified modifications for <see cref="P:System.Reactive.CollectionModification`1.Kind" /> and <see cref="P:System.Reactive.CollectionModification`1.Value" /> inequality.
            </summary>
      <param name="first">The first modification.</param>
      <param name="second">The second modification.</param>
      <returns>
        <see langword="False" /> if the <see cref="P:System.Reactive.CollectionModification`1.Kind" /> and <see cref="P:System.Reactive.CollectionModification`1.Value" /> of each modification are equal;
            otherwise, <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Kind">
      <summary>
            Gets the kind of modification that is represented.
            </summary>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.HasValue">
      <summary>
            Gets a value indicating whether the modification has a value.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == (Kind != CollectionModificationKind.Clear)</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Value">
      <summary>
            Gets the value of an <see cref="F:System.Reactive.CollectionModificationKind.Add" /> or <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> 
            modification; otherwise, throws an exception.
            </summary>
      <getter>
        <requires>HasValue</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Add.#ctor(`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionModification`1.Add" /> class.
            </summary>
      <param name="value">The item to be added.</param>
      <ensures>Kind == CollectionModificationKind.Add</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Clear.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionModification`1.Clear" /> class.
            </summary>
      <ensures>Kind == CollectionModificationKind.Clear</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Remove.#ctor(`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionModification`1.Remove" /> class.
            </summary>
      <param name="value">The item to be removed.</param>
      <ensures>Kind == CollectionModificationKind.Remove</ensures>
    </member>
    <member name="T:System.Reactive.CollectionNotificationExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for <see cref="T:System.Reactive.CollectionNotification`1" /> objects.
            </summary>
    </member>
    <member name="M:System.Reactive.CollectionNotificationExtensions.ToModification``1(System.Reactive.CollectionNotification{``0})">
      <summary>
            Converts a <see cref="T:System.Reactive.CollectionNotification`1" /> to a <see cref="T:System.Reactive.CollectionModification`1" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="notification">The <see cref="T:System.Reactive.CollectionNotification`1" /> to be converted.</param>
      <returns>A <see cref="T:System.Reactive.CollectionModification`1" /> of <see cref="F:System.Reactive.CollectionModificationKind.Add" /> when the specified <paramref name="notification" />
            is <see cref="F:System.Reactive.CollectionNotificationKind.Exists" />, <see cref="F:System.Reactive.CollectionNotificationKind.OnAdded" /> or <see cref="F:System.Reactive.CollectionNotificationKind.OnReplaced" />, 
            a <see cref="T:System.Reactive.CollectionModification`1" /> of <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> when the specified <paramref name="notification" />
            is <see cref="F:System.Reactive.CollectionNotificationKind.OnRemoved" />, or a <see cref="T:System.Reactive.CollectionModification`1" /> of <see cref="F:System.Reactive.CollectionModificationKind.Clear" />
            when the specified <paramref name="notification" /> is <see cref="F:System.Reactive.CollectionNotificationKind.OnCleared" />.</returns>
      <requires>notification != null</requires>
      <ensures>Contract.Result&lt;CollectionModification&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.CollectionNotification`1">
      <summary>
            Represents a collection-modifying notification to an observer.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionNotification`1" /> class for derived classes.
            </summary>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)">
      <summary>
            Invokes the delegate corresponding to the notification.
            </summary>
      <param name="exists">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.Exists" /> notification.</param>
      <param name="onAdded">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.OnAdded" /> notification.</param>
      <param name="onReplaced">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.OnReplaced" /> notification.</param>
      <param name="onRemoved">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.OnRemoved" /> notification.</param>
      <param name="onCleared">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.OnCleared" /> notification.</param>
      <requires>exists != null</requires>
      <requires>onAdded != null</requires>
      <requires>onReplaced != null</requires>
      <requires>onRemoved != null</requires>
      <requires>onCleared != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <summary>
            Invokes the delegate corresponding to the notification and returns the produced result.
            </summary>
      <typeparam name="TResult">Type of the produced result.</typeparam>
      <param name="exists">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.Exists" /> notification.</param>
      <param name="onAdded">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.OnAdded" /> notification.</param>
      <param name="onReplaced">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.OnReplaced" /> notification.</param>
      <param name="onRemoved">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.OnRemoved" /> notification.</param>
      <param name="onCleared">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.OnCleared" /> notification.</param>
      <returns>Result produced by the observation.</returns>
      <requires>exists != null</requires>
      <requires>onAdded != null</requires>
      <requires>onReplaced != null</requires>
      <requires>onRemoved != null</requires>
      <requires>onCleared != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.GetHashCode">
      <summary>
            Generates a hash code that is suitable for use when keying a dictionary.
            </summary>
      <returns>A hash code for the notification.</returns>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.Equals(System.Reactive.CollectionNotification{`0})">
      <summary>
            Compares the specified notification for <see cref="P:System.Reactive.CollectionNotification`1.Kind" /> and <see cref="P:System.Reactive.CollectionNotification`1.Value" /> equality.
            </summary>
      <param name="other">The other notification to compare.</param>
      <returns>
        <see langword="True" /> if the <see cref="P:System.Reactive.CollectionNotification`1.Kind" /> and <see cref="P:System.Reactive.CollectionNotification`1.Value" /> of each notification are equal;
            otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.Equals(System.Object)">
      <summary>
            Compares the specified notification for <see cref="P:System.Reactive.CollectionNotification`1.Kind" /> and <see cref="P:System.Reactive.CollectionNotification`1.Value" /> equality.
            </summary>
      <param name="obj">The other notification to compare.</param>
      <returns>
        <see langword="True" /> if the specified object is an instance of <see cref="T:System.Reactive.CollectionNotification`1" /> and if
            the <see cref="P:System.Reactive.CollectionNotification`1.Kind" /> and <see cref="P:System.Reactive.CollectionNotification`1.Value" /> of each notification are equal; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.op_Equality(System.Reactive.CollectionNotification{`0},System.Reactive.CollectionNotification{`0})">
      <summary>
            Compares the specified notifications for <see cref="P:System.Reactive.CollectionNotification`1.Kind" /> and <see cref="P:System.Reactive.CollectionNotification`1.Value" /> equality.
            </summary>
      <param name="first">The first notification.</param>
      <param name="second">The second notification.</param>
      <returns>
        <see langword="True" /> if the <see cref="P:System.Reactive.CollectionNotification`1.Kind" /> and <see cref="P:System.Reactive.CollectionNotification`1.Value" /> of each notification are equal;
            otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.op_Inequality(System.Reactive.CollectionNotification{`0},System.Reactive.CollectionNotification{`0})">
      <summary>
            Compares the specified notifications for <see cref="P:System.Reactive.CollectionNotification`1.Kind" /> and <see cref="P:System.Reactive.CollectionNotification`1.Value" /> inequality.
            </summary>
      <param name="first">The first notification.</param>
      <param name="second">The second notification.</param>
      <returns>
        <see langword="False" /> if the <see cref="P:System.Reactive.CollectionNotification`1.Kind" /> and <see cref="P:System.Reactive.CollectionNotification`1.Value" /> of each notification are equal;
            otherwise, <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.Kind">
      <summary>
            Gets the kind of notification that is represented.
            </summary>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.HasValue">
      <summary>
            Gets a value indicating whether the notification has a <see cref="P:System.Reactive.CollectionNotification`1.Value" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == (Kind != CollectionNotificationKind.OnCleared)</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.Value">
      <summary>
            Gets the value of an <see cref="F:System.Reactive.CollectionNotificationKind.OnAdded" />, <see cref="F:System.Reactive.CollectionNotificationKind.OnReplaced" />, 
            <see cref="F:System.Reactive.CollectionNotificationKind.OnRemoved" /> or <see cref="F:System.Reactive.CollectionNotificationKind.Exists" /> notification;
            otherwise, throws an exception.
            </summary>
      <getter>
        <requires>HasValue</requires>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.ReplacedValue">
      <summary>
            Gets the replaced value of an <see cref="F:System.Reactive.CollectionNotificationKind.OnReplaced" /> notification; otherwise, throws an exception.
            </summary>
      <getter>
        <requires>Kind == CollectionNotificationKind.OnReplaced</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnReplaced.#ctor(`0,`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionNotification`1.OnReplaced" /> class.
            </summary>
      <param name="oldValue">The item being replaced.</param>
      <param name="newValue">The item replacing the current item.</param>
      <ensures>Kind == CollectionNotificationKind.OnReplaced</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.Exists.#ctor(`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionNotification`1.Exists" /> class.
            </summary>
      <param name="value">The item that exists.</param>
      <ensures>Kind == CollectionNotificationKind.Exists</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnAdded.#ctor(`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionNotification`1.OnAdded" /> class.
            </summary>
      <param name="value">The item being added.</param>
      <ensures>Kind == CollectionNotificationKind.OnAdded</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnRemoved.#ctor(`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionNotification`1.OnRemoved" /> class.
            </summary>
      <param name="value">The item being removed.</param>
      <ensures>Kind == CollectionNotificationKind.OnRemoved</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnCleared.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionNotification`1.OnCleared" /> class.
            </summary>
      <ensures>Kind == CollectionNotificationKind.OnCleared</ensures>
    </member>
    <member name="T:System.Reactive.CollectionModification">
      <summary>
            Provides <see langword="static" /> factory methods for creating <see cref="T:System.Reactive.CollectionModification`1" /> objects.
            </summary>
    </member>
    <member name="M:System.Reactive.CollectionModification.CreateAdd``1(``0)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionModification`1" /> object that is an <see cref="F:System.Reactive.CollectionModificationKind.Add" /> 
            modification for the specified <paramref name="value" />.
            </summary>
      <typeparam name="T">The object that provides modification information.</typeparam>
      <param name="value">The item to be added.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionModification`1" /> object that is an <see cref="F:System.Reactive.CollectionModificationKind.Add" /> 
            modification for the specified <paramref name="value" />.</returns>
      <ensures>Contract.Result&lt;CollectionModification&lt;T&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionModification&lt;T&gt;&gt;().Kind == CollectionModificationKind.Add</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification.CreateRemove``1(``0)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionModification`1" /> object that is a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> 
            modification for the specified <paramref name="value" />.
            </summary>
      <typeparam name="T">The object that provides modification information.</typeparam>
      <param name="value">The item to be removed.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionModification`1" /> object that is a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> 
            modification for the specified <paramref name="value" />.</returns>
      <ensures>Contract.Result&lt;CollectionModification&lt;T&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionModification&lt;T&gt;&gt;().Kind == CollectionModificationKind.Remove</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification.CreateClear``1">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionModification`1" /> object that is a <see cref="F:System.Reactive.CollectionModificationKind.Clear" /> 
            modification.
            </summary>
      <typeparam name="T">The object that provides modification information.</typeparam>
      <returns>A new <see cref="T:System.Reactive.CollectionModification`1" /> object that is a <see cref="F:System.Reactive.CollectionModificationKind.Clear" /> 
            modification.</returns>
      <ensures>Contract.Result&lt;CollectionModification&lt;T&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionModification&lt;T&gt;&gt;().Kind == CollectionModificationKind.Clear</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification.CreateDictionaryAdd``2(``0,``1)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionModification`1" /> object that is an <see cref="F:System.Reactive.CollectionModificationKind.Add" /> 
            modification for the specified <paramref name="key" /> and <paramref name="value" /> pair.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="key">The key of the item to be added.</param>
      <param name="value">The item to be added.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionModification`1" /> object that is an <see cref="F:System.Reactive.CollectionModificationKind.Add" /> 
            modification for the specified <paramref name="key" /> and <paramref name="value" />.</returns>
      <ensures>Contract.Result&lt;CollectionModification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionModification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;().Kind == CollectionModificationKind.Add</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification.CreateDictionaryRemove``2(``0)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionModification`1" /> object that is a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> 
            modification for the specified <paramref name="key" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="key">The key of the item to be removed.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionModification`1" /> object that is a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> 
            modification for the specified <paramref name="key" />.</returns>
      <ensures>Contract.Result&lt;CollectionModification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionModification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;().Kind == CollectionModificationKind.Remove</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification.CreateDictionaryClear``2">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionModification`1" /> object that is a <see cref="F:System.Reactive.CollectionModificationKind.Clear" /> 
            modification.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <returns>A new <see cref="T:System.Reactive.CollectionModification`1" /> object that is a <see cref="F:System.Reactive.CollectionModificationKind.Clear" /> 
            modification.</returns>
      <ensures>Contract.Result&lt;CollectionModification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionModification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;().Kind == CollectionModificationKind.Clear</ensures>
    </member>
    <member name="T:System.Reactive.CollectionModificationExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for <see cref="T:System.Reactive.CollectionModification`1" /> objects.
            </summary>
    </member>
    <member name="M:System.Reactive.CollectionModificationExtensions.ToNotification``1(System.Reactive.CollectionModification{``0})">
      <summary>
            Converts a <see cref="T:System.Reactive.CollectionModification`1" /> to a <see cref="T:System.Reactive.CollectionNotification`1" />.
            </summary>
      <typeparam name="T">The object that provides modification information.</typeparam>
      <param name="modification">The <see cref="T:System.Reactive.CollectionModification`1" /> to be converted.</param>
      <returns>A <see cref="T:System.Reactive.CollectionNotification`1" /> of <see cref="F:System.Reactive.CollectionNotificationKind.OnAdded" /> when the specified <paramref name="modification" />
            is <see cref="F:System.Reactive.CollectionModificationKind.Add" />, a <see cref="T:System.Reactive.CollectionNotification`1" /> of <see cref="F:System.Reactive.CollectionNotificationKind.OnRemoved" /> when the 
            specified <paramref name="modification" /> is <see cref="F:System.Reactive.CollectionModificationKind.Remove" />, or a <see cref="T:System.Reactive.CollectionNotification`1" /> of 
            <see cref="F:System.Reactive.CollectionNotificationKind.OnCleared" /> when the specified <paramref name="modification" /> is <see cref="F:System.Reactive.CollectionModificationKind.Clear" />.</returns>
      <requires>modification != null</requires>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.Linq.Observable2">
      <summary>
            Provides a set of <see langword="static" /> methods for query operations over observable sequences.
            </summary>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Consume``2(System.IObservable{``0},System.Func{``0,System.Maybe{``1}})">
      <summary>
            Generates a sequence using the producer/consumer pattern by iteratively calling a consumer function when data is available.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TResult">The type of the data in the generated sequence.</typeparam>
      <param name="source">Indicates when data becomes available from one or more producers.</param>
      <param name="consumeNext">A function that is called iteratively to generate values from out-of-band data.</param>
      <remarks>
        <para>
            The purpose of the <paramref name="source" /> sequence is simply to notify the consumer when data becomes available in
            out-of-band storage.  The data in the <paramref name="source" /> sequence provides additional information to the consumer, 
            but it does not have to be the actual data produced for the consumer.
            </para>
        <para>
            The <paramref name="consumeNext" /> function is called iteratively when data becomes available, until it returns 
            <see cref="M:System.Maybe.Empty``1" />.  All non-empty values that are returned are concatenated into the generated sequence.
            </para>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Consume``2(System.IObservable{``0},System.Func{``0,System.Maybe{``1}})" /> ensures that there 
            is always one active iterator over the <paramref name="consumeNext" /> function when the <paramref name="source" /> sequence notifies
            that data is available; however, it's not necessarily called for every value in the <paramref name="source" /> sequence.
            It is only called if the previous iteration has completed; otherwise, the current notification is ignored.  This ensures that
            only one consumer is active at any given time, but it also means that the <paramref name="consumeNext" /> function is not guaranteed
            to receive every value in the <paramref name="source" /> sequence; therefore, the <paramref name="consumeNext" /> function must read
            data from out-of-band storage instead; e.g., from a shared stream or queue.
            </para>
        <para>
            The <paramref name="consumeNext" /> function may also be called when data is not available.  For example, if the current consuming 
            iterator completes and additional notifications from the <paramref name="source" /> were received, then <paramref name="consumeNext" />
            is called again to check whether new data was missed.  This avoids a race condition between the <paramref name="source" /> sequence 
            and <paramref name="consumeNext" /> reading shared data.  If no data is available when <paramref name="consumeNext" /> is called, then 
            <see cref="M:System.Maybe.Empty``1" /> should be returned and <paramref name="consumeNext" /> will not be called again until another 
            notification is observed from the <paramref name="source" />.
            </para>
        <alert type="tip">
            Producers and the single active consumer are intended to access shared objects concurrently, yet it remains their responsibility
            to ensure thread-safety.  The <strong>Consume</strong> operator cannot do so without breaking concurrency.  For example, a producer/consumer
            implementation that uses an in-memory queue must manually ensure that reads and writes to the queue are thread-safe.
            </alert>
        <para>
            Multiple producers are supported.  Simply create an observable sequence for each producer that notifies when data is generated, 
            merge them together using the <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}})" /> operator, and use the merged
            observable as the <paramref name="source" /> argument in the <strong>Consume</strong> operator.
            </para>
        <para>
            Multiple consumers are supported by calling <strong>Consume</strong> once and then calling <see cref="M:System.IObservable`1.Subscribe(System.IObserver{`0})" />
            multiple times on the <em>cold</em> observable that is returned.  Just be sure that the <paramref name="source" /> sequence is 
            <em>hot</em> so that each subscription will consume based on the same producers' notifications.
            </para>
      </remarks>
      <returns>An observable sequence that is the concatenation of the values returned by the <paramref name="consumeNext" /> function.</returns>
      <requires>source != null</requires>
      <requires>consumeNext != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Consume``2(System.IObservable{``0},System.Func{``0,System.Maybe{``1}},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Generates a sequence using the producer/consumer pattern by iteratively calling a consumer function on the specified 
            <paramref name="scheduler" /> when data is available.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TResult">The type of the data in the generated sequence.</typeparam>
      <param name="source">Indicates when data becomes available from one or more producers.</param>
      <param name="consumeNext">A function that is called iteratively to generate values from out-of-band data.</param>
      <param name="scheduler">An object that schedules iteration over the <paramref name="consumeNext" /> function.</param>
      <remarks>
        <para>
            The purpose of the <paramref name="source" /> sequence is simply to notify the consumer when data becomes available in
            out-of-band storage.  The data in the <paramref name="source" /> sequence provides additional information to the consumer, 
            but it does not have to be the actual data produced for the consumer.
            </para>
        <para>
            The <paramref name="consumeNext" /> function is called iteratively when data becomes available, until it returns 
            <see cref="M:System.Maybe.Empty``1" />.  All non-empty values that are returned are concatenated into the generated sequence.
            </para>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Consume``2(System.IObservable{``0},System.Func{``0,System.Maybe{``1}},System.Reactive.Concurrency.IScheduler)" /> ensures that there 
            is always one active iterator over the <paramref name="consumeNext" /> function when the <paramref name="source" /> sequence notifies
            that data is available; however, it's not necessarily called for every value in the <paramref name="source" /> sequence.
            It is only called if the previous iteration has completed; otherwise, the current notification is ignored.  This ensures that
            only one consumer is active at any given time, but it also means that the <paramref name="consumeNext" /> function is not guaranteed
            to receive every value in the <paramref name="source" /> sequence; therefore, the <paramref name="consumeNext" /> function must read
            data from out-of-band storage instead; e.g., from a shared stream or queue.
            </para>
        <para>
            The <paramref name="consumeNext" /> function may also be called when data is not available.  For example, if the current consuming 
            iterator completes and additional notifications from the <paramref name="source" /> were received, then <paramref name="consumeNext" />
            is called again to check whether new data was missed.  This avoids a race condition between the <paramref name="source" /> sequence 
            and <paramref name="consumeNext" /> reading shared data.  If no data is available when <paramref name="consumeNext" /> is called, then 
            <see cref="M:System.Maybe.Empty``1" /> should be returned and <paramref name="consumeNext" /> will not be called again until another 
            notification is observed from the <paramref name="source" />.
            </para>
        <alert type="tip">
            Producers and the single active consumer are intended to access shared objects concurrently, yet it remains their responsibility
            to ensure thread-safety.  The <strong>Consume</strong> operator cannot do so without breaking concurrency.  For example, a producer/consumer
            implementation that uses an in-memory queue must manually ensure that reads and writes to the queue are thread-safe.
            </alert>
        <para>
            Multiple producers are supported.  Simply create an observable sequence for each producer that notifies when data is generated, 
            merge them together using the <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}})" /> operator, and use the merged
            observable as the <paramref name="source" /> argument in the <strong>Consume</strong> operator.
            </para>
        <para>
            Multiple consumers are supported by calling <strong>Consume</strong> once and then calling <see cref="M:System.IObservable`1.Subscribe(System.IObserver{`0})" />
            multiple times on the <em>cold</em> observable that is returned.  Just be sure that the <paramref name="source" /> sequence is 
            <em>hot</em> so that each subscription will consume based on the same producers' notifications.
            </para>
      </remarks>
      <returns>An observable sequence that is the concatenation of the values returned by the <paramref name="consumeNext" /> function.</returns>
      <requires>source != null</requires>
      <requires>consumeNext != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Consume``2(System.IObservable{``0},System.IObservable{``1})">
      <summary>
            Generates a sequence using the producer/consumer pattern.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TResult">The type of the data in the generated sequence.</typeparam>
      <param name="source">Indicates when data becomes available from one or more producers.</param>
      <param name="consumer">An observable that is generated from out-of-band data.</param>
      <remarks>
        <para>
            The purpose of the <paramref name="source" /> sequence is simply to notify when data becomes available in out-of-band storage.
            The data in the <paramref name="source" /> sequence is ignored.
            </para>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Consume``2(System.IObservable{``0},System.IObservable{``1})" /> ensures that there is always an active 
            subscription to the <paramref name="consumer" /> sequence when the <paramref name="source" /> sequence notifies that data is
            available; however, a new subscription is not necessarily created for every value in the <paramref name="source" /> sequence.
            <see cref="M:System.IObservable`1.Subscribe(System.IObserver{`0})" /> is only called if the previous subscription has completed; otherwise, the current 
            notification is ignored.  This ensures that only one consumer is active at any given time and that all available data has a 
            chance to be read.
            </para>
        <para>
            A new subscription may also be created when data is not available.  For example, if the current subscription completes and 
            additional notifications from the <paramref name="source" /> were received, then another subscription is created to check whether
            new data was missed.  This avoids a race condition between the <paramref name="source" /> sequence and the consumer's completion 
            notification.  If no data is available for the new subscription, then an empty sequence should be generated and a new subscription
            will not be created again until another notification is observed from the <paramref name="source" />.
            </para>
        <alert type="tip">
            Producers and the single active consumer are intended to access shared objects concurrently, yet it remains their responsibility
            to ensure thread-safety.  The <strong>Consume</strong> operator cannot do so without breaking concurrency.  For example, a producer/consumer
            implementation that uses an in-memory queue must manually ensure that reads and writes to the queue are thread-safe.
            </alert>
        <para>
            Multiple producers are supported.  Simply create an observable sequence for each producer that notifies when data is generated, 
            merge them together using the <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}})" /> operator, and use the merged
            observable as the <paramref name="source" /> argument in the <strong>Consume</strong> operator.
            </para>
        <para>
            Multiple consumers are supported by calling <strong>Consume</strong> once and then calling <see cref="M:System.IObservable`1.Subscribe(System.IObserver{`0})" />
            multiple times on the <em>cold</em> observable that is returned.  Just be sure that the <paramref name="source" /> sequence is 
            <em>hot</em> so that each subscription will consume based on the same producers' notifications.
            </para>
      </remarks>
      <returns>An observable sequence that is the concatenation of all subscriptions to the <paramref name="consumer" /> observable.</returns>
      <requires>source != null</requires>
      <requires>consumer != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Consume``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}})">
      <summary>
            Generates a sequence using the producer/consumer pattern.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TResult">The type of the data in the generated sequence.</typeparam>
      <param name="source">Indicates when data becomes available from one or more producers.</param>
      <param name="consumerSelector">A function that generates an observable sequence from out-of-band data.</param>
      <remarks>
        <para>
            The purpose of the <paramref name="source" /> sequence is simply to notify the consumer when out-of-band data becomes available.
            The data in the <paramref name="source" /> sequence provides additional information to the <paramref name="consumerSelector" /> function, 
            but it does not have to be the actual data being produced.
            </para>
        <para>
            The <paramref name="consumerSelector" /> function is not necessarily called for every value in the <paramref name="source" /> sequence.
            It is only called if the previous consumer's observable has completed; otherwise, the current notification is ignored.  This ensures 
            that only one consumer is active at any given time, but it also means that the <paramref name="consumerSelector" /> function is not guaranteed
            to receive every value in the <paramref name="source" /> sequence; therefore, the <paramref name="consumerSelector" /> function must read
            data from out-of-band storage instead; e.g., from a shared stream or queue.
            </para>
        <para>
            The <paramref name="consumerSelector" /> function may also be called when data is not available.  For example, if the current consuming 
            observable completes and additional notifications from the <paramref name="source" /> were received, then <paramref name="consumerSelector" />
            is called again to check whether new data was missed.  This avoids a race condition between the <paramref name="source" /> sequence 
            and the consuming observable's completion notification.  If no data is available when <paramref name="consumerSelector" /> is called, then 
            an empty sequence should be returned and <paramref name="consumerSelector" /> will not be called again until another notification is observed 
            from the <paramref name="source" />.
            </para>
        <alert type="tip">
            Producers and the single active consumer are intended to access shared objects concurrently, yet it remains their responsibility
            to ensure thread-safety.  The <strong>Consume</strong> operator cannot do so without breaking concurrency.  For example, 
            a producer/consumer implementation that uses an in-memory queue must manually ensure that reads and writes to the queue are thread-safe.
            </alert>
        <para>
            Multiple producers are supported.  Simply create an observable sequence for each producer that notifies when data is generated, 
            merge them together using the <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}})" /> operator, and use the merged
            observable as the <paramref name="source" /> argument in the <strong>Consume</strong> operator.
            </para>
        <para>
            Multiple consumers are supported by calling <strong>Consume</strong> once and then calling <see cref="M:System.IObservable`1.Subscribe(System.IObserver{`0})" />
            multiple times on the <em>cold</em> observable that is returned.  Just be sure that the <paramref name="source" /> sequence is 
            <em>hot</em> so that each subscription will consume based on the same producers' notifications.
            </para>
      </remarks>
      <returns>An observable sequence that is the concatenation of the sequences returned by <paramref name="consumerSelector" />.</returns>
      <requires>source != null</requires>
      <requires>consumerSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.ToCursor``1(System.IObservable{``0})">
      <summary>
            Returns a cursor for the specified observable sequence.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence that the cursor moves over.</param>
      <remarks>
            The cursor's <see cref="P:System.Reactive.IObservableCursor`1.IsForwardOnly" /> property returns <see langword="false" />, 
            indicating that it can move forward and backward.
            </remarks>
      <returns>A cursor for the specified observable sequence.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.ToCursor``1(System.IObservable{``0},System.Boolean)">
      <summary>
            Returns a cursor for the specified observable sequence with the specified support for backward movement.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence that the cursor moves over.</param>
      <param name="forwardOnly">Specifies whether the cursor only moves forward.</param>
      <returns>A cursor for the specified observable sequence with the specified support for backward movement.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().IsForwardOnly == forwardOnly</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Synchronize``1(System.Reactive.IObservableCursor{``0})">
      <summary>
            Returns a thread-safe wrapper around the specified <paramref name="cursor" />.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="cursor">The observable cursor to be synchronized.</param>
      <remarks>
            Branches that are created before calling this method will not be synchronized; however, any new 
            branches that are created by the returned cursor will be synchronized with the cursor.
            </remarks>
      <returns>A thread-safe wrapper around the specified <paramref name="cursor" />.</returns>
      <requires>cursor != null</requires>
      <ensures>cursor.IsSynchronized == Contract.OldValue(cursor.IsSynchronized)</ensures>
      <ensures>cursor.IsForwardOnly == Contract.OldValue(cursor.IsForwardOnly)</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().IsSynchronized</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().IsForwardOnly == cursor.IsForwardOnly</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Synchronize``1(System.Reactive.IObservableCursor{``0},System.Object)">
      <summary>
            Returns a thread-safe wrapper around the specified <paramref name="cursor" />.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="cursor">The observable cursor to be synchronized.</param>
      <param name="gate">An object used to synchronize the specified <paramref name="cursor" />.</param>
      <remarks>
            Branches that are created before calling this method will not be synchronized; however, any new 
            branches that are created by the returned cursor will be synchronized with the cursor.
            </remarks>
      <returns>A thread-safe wrapper around the specified <paramref name="cursor" />.</returns>
      <requires>cursor != null</requires>
      <requires>gate != null</requires>
      <ensures>cursor.IsSynchronized == Contract.OldValue(cursor.IsSynchronized)</ensures>
      <ensures>cursor.IsForwardOnly == Contract.OldValue(cursor.IsForwardOnly)</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().IsSynchronized</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().IsForwardOnly == cursor.IsForwardOnly</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Remainder``1(System.Reactive.IObservableCursor{``0},System.Int32)">
      <summary>
            Branches from the specified <paramref name="cursor" /> and moves the branch forward the specified number of elements.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="cursor">The observable cursor from which to branch.</param>
      <param name="skip">The number of elements that the new branch must skip.</param>
      <returns>A new branch from the specified <paramref name="cursor" /> with its current index moved ahead the specified 
            number of elements.</returns>
      <requires>cursor != null</requires>
      <requires>skip &gt;= 0</requires>
      <ensures>cursor.IsSynchronized == Contract.OldValue(cursor.IsSynchronized)</ensures>
      <ensures>cursor.IsForwardOnly == Contract.OldValue(cursor.IsForwardOnly)</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().IsSynchronized == cursor.IsSynchronized</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().IsForwardOnly == cursor.IsForwardOnly</ensures>
      <ensures>cursor.IsSynchronized || Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().IsSequenceTerminated == cursor.IsSequenceTerminated</ensures>
      <ensures>cursor.IsSynchronized || Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().LatestIndex == cursor.LatestIndex</ensures>
      <ensures>cursor.IsSynchronized || Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().CurrentIndex ==
				(cursor.AtEndOfSequence
				? cursor.CurrentIndex
				: cursor.IsSequenceTerminated
					? Math.Min(cursor.CurrentIndex + skip, cursor.LatestIndex + 1)
					: cursor.CurrentIndex + skip)</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.IObservable{``1},System.Func{``1,``0})">
      <summary>
            Adds the elements from the specified observable sequence into a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="source">The sequence from which elements are collected.</param>
      <param name="keySelector">A function that maps values to keys.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequence.</returns>
      <requires>source != null</requires>
      <requires>keySelector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.IObservable{``1},System.Func{``1,``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Adds the elements from the specified observable sequence into a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="source">The sequence from which elements are collected.</param>
      <param name="keySelector">A function that maps values to keys.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequence.</returns>
      <requires>source != null</requires>
      <requires>keySelector != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``0,``1}}})">
      <summary>
            Adds the elements from the specified observable sequence into a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" />, or removes
            individual elements or clears all elements, depending upon the <see cref="T:System.Reactive.CollectionModificationKind" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="source">The sequence from which collection modifications are received.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequence.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``0,``1}}},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Adds the elements from the specified observable sequence into a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" />, or removes
            individual elements or clears all elements, depending upon the <see cref="T:System.Reactive.CollectionModificationKind" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="source">The sequence from which collection modifications are received.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequence.</returns>
      <requires>source != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``0,``1}}})">
      <summary>
            Concurrently populates a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the default equality comparer for 
            <typeparamref name="TKey" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> is initially populated.</param>
      <param name="keySelector">A function that maps values from the <paramref name="existing" /> sequence to keys.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> are received.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>keySelector != null</requires>
      <requires>changes != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``0,``1}}},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Concurrently populates a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the specified equality comparer for 
            <typeparamref name="TKey" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> is initially populated.</param>
      <param name="keySelector">A function that maps values from the <paramref name="existing" /> sequence to keys.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> are received.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>keySelector != null</requires>
      <requires>changes != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.IObservable{``1},System.Func{``1,``0},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``0,``1}}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the default equality comparer for 
            <typeparamref name="TKey" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> is initially populated.</param>
      <param name="keySelector">A function that maps values from the <paramref name="existing" /> sequence to keys.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> are received.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>keySelector != null</requires>
      <requires>changes != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.IObservable{``1},System.Func{``1,``0},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``0,``1}}},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the specified equality comparer for 
            <typeparamref name="TKey" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> is initially populated.</param>
      <param name="keySelector">A function that maps values from the <paramref name="existing" /> sequence to keys.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> are received.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>keySelector != null</requires>
      <requires>changes != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``1,``0}}},System.Func{System.IObservable{System.Reactive.CollectionNotification{System.Collections.Generic.KeyValuePair{``1,``0}}},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``1,``2}}}})">
      <summary>
            Concurrently populates a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the default equality comparer for 
            <typeparamref name="TKey" /> and projecting notifications using the specified <paramref name="selector" /> function.
            </summary>
      <typeparam name="TSource">The type of objects in the source sequences.</typeparam>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TResult">The type of objects to which reconciled elements are projected.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> is initially populated.</param>
      <param name="keySelector">A function that maps values from the <paramref name="existing" /> sequence to keys.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> are received.</param>
      <param name="selector">Projects a sequence of reconciled collection notifications, combining the <paramref name="existing" /> and 
            <paramref name="changes" /> sequences, into a sequence from which the dictionary is populated.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>keySelector != null</requires>
      <requires>changes != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``1,``0}}},System.Func{System.IObservable{System.Reactive.CollectionNotification{System.Collections.Generic.KeyValuePair{``1,``0}}},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``1,``2}}}},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Concurrently populates a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the specified equality comparer for 
            <typeparamref name="TKey" /> and projecting notifications using the specified <paramref name="selector" /> function.
            </summary>
      <typeparam name="TSource">The type of objects in the source sequences.</typeparam>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TResult">The type of objects to which reconciled elements are projected.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> is initially populated.</param>
      <param name="keySelector">A function that maps values from the <paramref name="existing" /> sequence to keys.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> are received.</param>
      <param name="selector">Projects a sequence of reconciled collection notifications, combining the <paramref name="existing" /> and 
            <paramref name="changes" /> sequences, into a sequence from which the dictionary is populated.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>keySelector != null</requires>
      <requires>changes != null</requires>
      <requires>selector != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``3(System.IObservable{``0},System.Func{``0,``1},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``1,``0}}},System.Func{System.IObservable{System.Reactive.CollectionNotification{System.Collections.Generic.KeyValuePair{``1,``0}}},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``1,``2}}}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the default equality comparer for 
            <typeparamref name="TKey" /> and projecting notifications using the specified <paramref name="selector" /> function.
            </summary>
      <typeparam name="TSource">The type of objects in the source sequences.</typeparam>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TResult">The type of objects to which reconciled elements are projected.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> is initially populated.</param>
      <param name="keySelector">A function that maps values from the <paramref name="existing" /> sequence to keys.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> are received.</param>
      <param name="selector">Projects a sequence of reconciled collection notifications, combining the <paramref name="existing" /> and 
            <paramref name="changes" /> sequences, into a sequence from which the dictionary is populated.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>keySelector != null</requires>
      <requires>changes != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``3(System.IObservable{``0},System.Func{``0,``1},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``1,``0}}},System.Func{System.IObservable{System.Reactive.CollectionNotification{System.Collections.Generic.KeyValuePair{``1,``0}}},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``1,``2}}}},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the specified equality comparer for 
            <typeparamref name="TKey" /> and projecting notifications using the specified <paramref name="selector" /> function.
            </summary>
      <typeparam name="TSource">The type of objects in the source sequences.</typeparam>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TResult">The type of objects to which reconciled elements are projected.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> is initially populated.</param>
      <param name="keySelector">A function that maps values from the <paramref name="existing" /> sequence to keys.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> are received.</param>
      <param name="selector">Projects a sequence of reconciled collection notifications, combining the <paramref name="existing" /> and 
            <paramref name="changes" /> sequences, into a sequence from which the dictionary is populated.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>keySelector != null</requires>
      <requires>changes != null</requires>
      <requires>selector != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``1(System.IObservable{``0})">
      <summary>
            Adds the elements from the specified observable sequence into a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The sequence from which elements are collected.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequence.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``1(System.IObservable{System.Reactive.CollectionModification{``0}})">
      <summary>
            Adds the elements from the specified observable sequence into a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" />, or removes
            individual elements or clears all elements, depending upon the <see cref="T:System.Reactive.CollectionModificationKind" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The sequence from which collection modifications are received.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequence.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``1(System.Collections.Generic.IEnumerable{``0},System.IObservable{System.Reactive.CollectionModification{``0}})">
      <summary>
            Concurrently populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the default equality comparer for 
            <typeparamref name="T" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> is initially populated.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> are received.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``1(System.Collections.Generic.IEnumerable{``0},System.IObservable{System.Reactive.CollectionModification{``0}},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Concurrently populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the specified equality comparer for 
            <typeparamref name="T" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> is initially populated.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> are received.</param>
      <param name="comparer">The object that compares two instances of <typeparamref name="T" /> for equality and generates a hash code 
            that is suitable for use when keying a dictionary.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``1(System.IObservable{``0},System.IObservable{System.Reactive.CollectionModification{``0}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the default equality comparer for 
            <typeparamref name="T" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> is initially populated.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> are received.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``1(System.IObservable{``0},System.IObservable{System.Reactive.CollectionModification{``0}},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the specified equality comparer for 
            <typeparamref name="T" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> is initially populated.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> are received.</param>
      <param name="comparer">The object that compares two instances of <typeparamref name="T" /> for equality and generates a hash code 
            that is suitable for keying a dictionary.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.Collections.Generic.IEnumerable{``0},System.IObservable{System.Reactive.CollectionModification{``0}},System.Func{System.IObservable{System.Reactive.CollectionNotification{``0}},System.IObservable{System.Reactive.CollectionModification{``1}}})">
      <summary>
            Concurrently populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the default equality comparer for 
            <typeparamref name="TSource" /> and projecting notifications using the specified <paramref name="selector" /> function.
            </summary>
      <typeparam name="TSource">The type of objects in the source sequences.</typeparam>
      <typeparam name="TResult">The type of objects to which reconciled elements are projected.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> is initially populated.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> are received.</param>
      <param name="selector">Projects a sequence of reconciled collection notifications, combining the <paramref name="existing" /> and 
            <paramref name="changes" /> sequences, into a sequence from which the list is populated.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.Collections.Generic.IEnumerable{``0},System.IObservable{System.Reactive.CollectionModification{``0}},System.Func{System.IObservable{System.Reactive.CollectionNotification{``0}},System.IObservable{System.Reactive.CollectionModification{``1}}},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Concurrently populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the specified equality comparer for 
            <typeparamref name="TSource" /> and projecting notifications using the specified <paramref name="selector" /> function.
            </summary>
      <typeparam name="TSource">The type of objects in the source sequences.</typeparam>
      <typeparam name="TResult">The type of objects to which reconciled elements are projected.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> is initially populated.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> are received.</param>
      <param name="selector">Projects a sequence of reconciled collection notifications, combining the <paramref name="existing" /> and 
            <paramref name="changes" /> sequences, into a sequence from which the list is populated.</param>
      <param name="comparer">The object that compares two instances of <typeparamref name="TSource" /> for equality and generates a hash code 
            that is suitable for use when keying a dictionary.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <requires>selector != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.IObservable{``0},System.IObservable{System.Reactive.CollectionModification{``0}},System.Func{System.IObservable{System.Reactive.CollectionNotification{``0}},System.IObservable{System.Reactive.CollectionModification{``1}}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the default equality comparer for 
            <typeparamref name="TSource" /> and projecting notifications using the specified <paramref name="selector" /> function.
            </summary>
      <typeparam name="TSource">The type of objects in the source sequences.</typeparam>
      <typeparam name="TResult">The type of objects to which reconciled elements are projected.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> is initially populated.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> are received.</param>
      <param name="selector">Projects a sequence of reconciled collection notifications, combining the <paramref name="existing" /> and 
            <paramref name="changes" /> sequences, into a sequence from which the list is populated.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.IObservable{``0},System.IObservable{System.Reactive.CollectionModification{``0}},System.Func{System.IObservable{System.Reactive.CollectionNotification{``0}},System.IObservable{System.Reactive.CollectionModification{``1}}},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the specified equality comparer for 
            <typeparamref name="TSource" /> and projecting notifications using the specified <paramref name="selector" /> function.
            </summary>
      <typeparam name="TSource">The type of objects in the source sequences.</typeparam>
      <typeparam name="TResult">The type of objects to which reconciled elements are projected.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> is initially populated.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> are received.</param>
      <param name="selector">Projects a sequence of reconciled collection notifications, combining the <paramref name="existing" /> and 
            <paramref name="changes" /> sequences, into a sequence from which the list is populated.</param>
      <param name="comparer">The object that compares two instances of <typeparamref name="TSource" /> for equality and generates a hash code 
            that is suitable for keying a dictionary.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <requires>selector != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.CombineLatest``2(System.IObservable{``0},System.IObservable{``1})">
      <summary>
            Merges two observable sequences into one observable sequence by creating a tuple whenever one of the observable sequences produces an element.
            </summary>
      <typeparam name="T1">The type of the tuple's first component.</typeparam>
      <typeparam name="T2">The type of the tuple's second component.</typeparam>
      <param name="first">The first observable sequence.</param>
      <param name="second">The second observable sequence.</param>
      <returns>An observable sequence containing the result of combining the latest element from each source using a tuple.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Tuple&lt;T1, T2&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.CombineLatest``3(System.IObservable{System.Tuple{``0,``1}},System.IObservable{``2})">
      <summary>
            Merges two observable sequences into one observable sequence by creating a tuple whenever one of the observable sequences produces an element.
            </summary>
      <typeparam name="T1">The type of the tuple's first component.</typeparam>
      <typeparam name="T2">The type of the tuple's second component.</typeparam>
      <typeparam name="T3">The type of the tuple's third component.</typeparam>
      <param name="first">The first observable sequence.</param>
      <param name="second">The second observable sequence.</param>
      <returns>An observable sequence containing the result of combining the latest element from each source using a tuple.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Tuple&lt;T1, T2, T3&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.CombineLatest``4(System.IObservable{System.Tuple{``0,``1,``2}},System.IObservable{``3})">
      <summary>
            Merges two observable sequences into one observable sequence by creating a tuple whenever one of the observable sequences produces an element.
            </summary>
      <typeparam name="T1">The type of the tuple's first component.</typeparam>
      <typeparam name="T2">The type of the tuple's second component.</typeparam>
      <typeparam name="T3">The type of the tuple's third component.</typeparam>
      <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
      <param name="first">The first observable sequence.</param>
      <param name="second">The second observable sequence.</param>
      <returns>An observable sequence containing the result of combining the latest element from each source using a tuple.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Tuple&lt;T1, T2, T3, T4&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.CombineLatest``5(System.IObservable{System.Tuple{``0,``1,``2,``3}},System.IObservable{``4})">
      <summary>
            Merges two observable sequences into one observable sequence by creating a tuple whenever one of the observable sequences produces an element.
            </summary>
      <typeparam name="T1">The type of the tuple's first component.</typeparam>
      <typeparam name="T2">The type of the tuple's second component.</typeparam>
      <typeparam name="T3">The type of the tuple's third component.</typeparam>
      <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
      <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
      <param name="first">The first observable sequence.</param>
      <param name="second">The second observable sequence.</param>
      <returns>An observable sequence containing the result of combining the latest element from each source using a tuple.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Tuple&lt;T1, T2, T3, T4, T5&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.CombineLatest``6(System.IObservable{System.Tuple{``0,``1,``2,``3,``4}},System.IObservable{``5})">
      <summary>
            Merges two observable sequences into one observable sequence by creating a tuple whenever one of the observable sequences produces an element.
            </summary>
      <typeparam name="T1">The type of the tuple's first component.</typeparam>
      <typeparam name="T2">The type of the tuple's second component.</typeparam>
      <typeparam name="T3">The type of the tuple's third component.</typeparam>
      <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
      <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
      <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
      <param name="first">The first observable sequence.</param>
      <param name="second">The second observable sequence.</param>
      <returns>An observable sequence containing the result of combining the latest element from each source using a tuple.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Tuple&lt;T1, T2, T3, T4, T5, T6&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.CombineLatest``7(System.IObservable{System.Tuple{``0,``1,``2,``3,``4,``5}},System.IObservable{``6})">
      <summary>
            Merges two observable sequences into one observable sequence by creating a tuple whenever one of the observable sequences produces an element.
            </summary>
      <typeparam name="T1">The type of the tuple's first component.</typeparam>
      <typeparam name="T2">The type of the tuple's second component.</typeparam>
      <typeparam name="T3">The type of the tuple's third component.</typeparam>
      <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
      <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
      <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
      <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
      <param name="first">The first observable sequence.</param>
      <param name="second">The second observable sequence.</param>
      <returns>An observable sequence containing the result of combining the latest element from each source using a tuple.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Tuple&lt;T1, T2, T3, T4, T5, T6, T7&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.CombineLatest``8(System.IObservable{System.Tuple{``0,``1,``2,``3,``4,``5,``6}},System.IObservable{``7})">
      <summary>
            Merges two observable sequences into one observable sequence by creating a tuple whenever one of the observable sequences produces an element.
            </summary>
      <typeparam name="T1">The type of the tuple's first component.</typeparam>
      <typeparam name="T2">The type of the tuple's second component.</typeparam>
      <typeparam name="T3">The type of the tuple's third component.</typeparam>
      <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
      <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
      <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
      <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
      <typeparam name="T8">The type of the tuple's eighth component.</typeparam>
      <param name="first">The first observable sequence.</param>
      <param name="second">The second observable sequence.</param>
      <returns>An observable sequence containing the result of combining the latest element from each source using a tuple.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Tuple&lt;T1, T2, T3, T4, T5, T6, T7, T8&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.CombineLatest``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
      <summary>
            Merges two or more observable sequences into one observable sequence of lists, each containing the latest values from all observable sequences
            whenever one of the sequences produces an element.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sources">An enumerable sequence containing two or more observable sequences to be merged.</param>
      <remarks>
        <para>
            All of the observable sequences must produce at least one element; otherwise, the generated sequence will be empty.  Furthermore, if an observable 
            sequence produces more than one element before each of the other observable sequences have produced their first elements, then all of the older 
            elements are discarded and will not be included in the generated sequence.  Only the latest elements from each sequence are included.
            </para>
        <para>
            The latest value of an observable sequence is always located in the generated lists at the same index in which that sequence is located in the outer sequence.
            For example, the values from the first observable sequence in the outer sequence will always be at index zero (0) in the lists that are generated.
            </para>
      </remarks>
      <returns>An observable sequence containing the result of combining the latest elements of all sources into lists.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IList&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.CombineLatest``1(System.IObservable{System.IObservable{``0}})">
      <summary>
            Merges two or more observable sequences into one observable sequence of lists, each containing the latest values from the latest consecutive 
            observable sequences whenever one of the sequences produces an element.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sources">An observable sequence containing two or more observable sequences to be merged.</param>
      <remarks>
        <para>
            At least two consecutive observable sequences from the beginning of the outer observable sequence must produce at least one element; otherwise, 
            the generated sequence will be empty.  Furthermore, if an observable sequence produces more than one element before each of the consecutive observable 
            sequences have produced their first elements, then all of the older elements are discarded and will not be included in the generated sequence.
            Only the latest elements from each of the consecutive sequences are included.  As new sequences arrive, the size of the generated lists are increased
            to accomodate them if they start producing values.
            </para>
        <para>
            The latest value of an observable sequence is always located in the generated lists at the same index in which that sequence is located in the outer sequence.
            For example, the values from the first observable sequence in the outer sequence will always be at index zero (0) in the lists that are generated.
            Furthermore, once a generated list contains the value for a particular observable sequence, all subsequent lists will also contain the latest value for that 
            sequence.  As a result, the number of items in the generated lists may stay the same or grow when new observable sequences arrive, but the size of the lists 
            will never shrink.
            </para>
      </remarks>
      <returns>An observable sequence containing the result of combining the latest elements of all sources into lists.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IList&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Multicast``2(System.IObservable{``0},System.Func{System.Reactive.Subjects.ISubject{``0,``1}})">
      <summary>
            Returns a connectable observable sequence that upon connection causes the <paramref name="source" /> sequence to 
            push results into a new fresh subject, which is created by invoking the specified <paramref name="factory" /> function 
            each time that a connection is disposed and a new connection is made.
            </summary>
      <typeparam name="TSource">The type of the source.</typeparam>
      <typeparam name="TResult">The type of the result.</typeparam>
      <param name="source">The source sequence whose elements will be pushed into the specified subject.</param>
      <param name="factory">The factory function used to create the subject that notifications will be pushed into.</param>
      <returns>A connectable observable sequence that upon connection causes the source sequence to push results into a new subject.</returns>
      <requires>source != null</requires>
      <requires>factory != null</requires>
      <ensures>Contract.Result&lt;IConnectableObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Zip``2(System.IObservable{``0},System.IObservable{``1})">
      <summary>
            Merges two observable sequences into one observable sequence of tuples by combining elements in a pairwise fashion.
            </summary>
      <typeparam name="T1">The type of the tuple's first component.</typeparam>
      <typeparam name="T2">The type of the tuple's second component.</typeparam>
      <param name="first">The first observable sequence.</param>
      <param name="second">The second observable sequence.</param>
      <returns>An observable sequence containing the result of combining pairwise elements from each source into a tuple.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Tuple&lt;T1, T2&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Zip``3(System.IObservable{System.Tuple{``0,``1}},System.IObservable{``2})">
      <summary>
            Merges two observable sequences into one observable sequence of tuples by combining elements in a pairwise fashion.
            </summary>
      <typeparam name="T1">The type of the tuple's first component.</typeparam>
      <typeparam name="T2">The type of the tuple's second component.</typeparam>
      <typeparam name="T3">The type of the tuple's third component.</typeparam>
      <param name="first">The first observable sequence.</param>
      <param name="second">The second observable sequence.</param>
      <returns>An observable sequence containing the result of combining pairwise elements from each source into a tuple.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Tuple&lt;T1, T2, T3&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Zip``4(System.IObservable{System.Tuple{``0,``1,``2}},System.IObservable{``3})">
      <summary>
            Merges two observable sequences into one observable sequence of tuples by combining elements in a pairwise fashion.
            </summary>
      <typeparam name="T1">The type of the tuple's first component.</typeparam>
      <typeparam name="T2">The type of the tuple's second component.</typeparam>
      <typeparam name="T3">The type of the tuple's third component.</typeparam>
      <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
      <param name="first">The first observable sequence.</param>
      <param name="second">The second observable sequence.</param>
      <returns>An observable sequence containing the result of combining pairwise elements from each source into a tuple.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Tuple&lt;T1, T2, T3, T4&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Zip``5(System.IObservable{System.Tuple{``0,``1,``2,``3}},System.IObservable{``4})">
      <summary>
            Merges two observable sequences into one observable sequence of tuples by combining elements in a pairwise fashion.
            </summary>
      <typeparam name="T1">The type of the tuple's first component.</typeparam>
      <typeparam name="T2">The type of the tuple's second component.</typeparam>
      <typeparam name="T3">The type of the tuple's third component.</typeparam>
      <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
      <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
      <param name="first">The first observable sequence.</param>
      <param name="second">The second observable sequence.</param>
      <returns>An observable sequence containing the result of combining pairwise elements from each source into a tuple.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Tuple&lt;T1, T2, T3, T4, T5&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Zip``6(System.IObservable{System.Tuple{``0,``1,``2,``3,``4}},System.IObservable{``5})">
      <summary>
            Merges two observable sequences into one observable sequence of tuples by combining elements in a pairwise fashion.
            </summary>
      <typeparam name="T1">The type of the tuple's first component.</typeparam>
      <typeparam name="T2">The type of the tuple's second component.</typeparam>
      <typeparam name="T3">The type of the tuple's third component.</typeparam>
      <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
      <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
      <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
      <param name="first">The first observable sequence.</param>
      <param name="second">The second observable sequence.</param>
      <returns>An observable sequence containing the result of combining pairwise elements from each source into a tuple.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Tuple&lt;T1, T2, T3, T4, T5, T6&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Zip``7(System.IObservable{System.Tuple{``0,``1,``2,``3,``4,``5}},System.IObservable{``6})">
      <summary>
            Merges two observable sequences into one observable sequence of tuples by combining elements in a pairwise fashion.
            </summary>
      <typeparam name="T1">The type of the tuple's first component.</typeparam>
      <typeparam name="T2">The type of the tuple's second component.</typeparam>
      <typeparam name="T3">The type of the tuple's third component.</typeparam>
      <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
      <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
      <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
      <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
      <param name="first">The first observable sequence.</param>
      <param name="second">The second observable sequence.</param>
      <returns>An observable sequence containing the result of combining pairwise elements from each source into a tuple.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Tuple&lt;T1, T2, T3, T4, T5, T6, T7&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Zip``8(System.IObservable{System.Tuple{``0,``1,``2,``3,``4,``5,``6}},System.IObservable{``7})">
      <summary>
            Merges two observable sequences into one observable sequence of tuples by combining elements in a pairwise fashion.
            </summary>
      <typeparam name="T1">The type of the tuple's first component.</typeparam>
      <typeparam name="T2">The type of the tuple's second component.</typeparam>
      <typeparam name="T3">The type of the tuple's third component.</typeparam>
      <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
      <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
      <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
      <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
      <typeparam name="T8">The type of the tuple's eighth component.</typeparam>
      <param name="first">The first observable sequence.</param>
      <param name="second">The second observable sequence.</param>
      <returns>An observable sequence containing the result of combining pairwise elements from each source into a tuple.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Tuple&lt;T1, T2, T3, T4, T5, T6, T7, T8&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Zip``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
      <summary>
            Merges two or more observable sequences into one observable sequence of lists by combining their elements in a pairwise fashion.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sources">An enumerable sequence containing two or more observable sequences to be merged.</param>
      <remarks>
        <para>
            All of the observable sequences must produce at least one element; otherwise, the generated sequence will be empty.  Furthermore, if an observable 
            sequence produces more than one element before each of the other observable sequences have produced their first elements, then all of the elements 
            will be enqueued for future pairing.  No elements are discarded.
            </para>
        <para>
            The latest value of an observable sequence is always located in the generated lists at the same index in which that sequence is located in the outer sequence.
            For example, the values from the first observable sequence in the outer sequence will always be at index zero (0) in the lists that are generated.
            </para>
      </remarks>
      <returns>An observable sequence containing the result of pairwise combining the elements of all sources into lists.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IList&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Zip``1(System.IObservable{System.IObservable{``0}})">
      <summary>
            Merges two or more observable sequences into one observable sequence of lists by combining their elements in a pairwise fashion.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sources">An observable sequence containing two or more observable sequences to be merged.</param>
      <remarks>
        <para>
            All of the observable sequences must produce at least one element; otherwise, the generated sequence will be empty.  Furthermore, if an observable 
            sequence produces more than one element before each of the other observable sequences have produced their first elements, then all of the elements 
            will be enqueued for future pairing.  No elements are discarded.
            </para>
        <para>
            The latest value of an observable sequence is always located in the generated lists at the same index in which that sequence is located in the outer sequence.
            For example, the values from the first observable sequence in the outer sequence will always be at index zero (0) in the lists that are generated.
            </para>
      </remarks>
      <returns>An observable sequence containing the result of pairwise combining the elements of all sources into lists.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IList&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.OnErrorResumeNext``2(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception.
            The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.OnErrorResumeNext``2(System.Collections.Generic.IEnumerable{System.IObservable{``0}},System.Func{``1,System.TimeSpan})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception 
            using the specified back-off algorithm.  The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="backOffSelector">Selects the amount of time to delay before moving to the next observable 
            when the current sequence has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.OnErrorResumeNext``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception.
            The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.OnErrorResumeNext``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}},System.Func{``1,System.Collections.Generic.IEnumerator{System.IObservable{``0}}})">
      <summary>
            Moves to the next observable sequence provided by the specified <paramref name="handler" /> when the current 
            sequence throws the specified type of exception.  The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="handler">Selects the next enumerator when an observable from the current enumerator has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>handler != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.OnErrorResumeNext``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}},System.Func{``1,System.Collections.Generic.IEnumerator{System.IObservable{``0}}},System.Func{``1,System.TimeSpan})">
      <summary>
            Moves to the next observable sequence provided by the specified <paramref name="handler" /> when the current 
            sequence throws the specified type of exception using the specified back-off algorithm.
            The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="handler">Selects the next enumerator when an observable from the current enumerator has faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before moving to the next observable 
            when the current sequence has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>handler != null</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Introspect``1(System.IObservable{``0})">
      <summary>
            Pairs the specified observable sequence with an observable for each value that indicates 
            the duration of the observation of that value.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence to introspect.</param>
      <returns>A paired observable with the left channel providing introspection windows and the 
            right channel providing values from the specified observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;IObservable&lt;TSource&gt;, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Introspect``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Pairs the specified observable sequence with an observable for each value that indicates 
            the duration of the observation of that value.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence to introspect.</param>
      <param name="scheduler">Schedules the observations of values in the right notification channel.</param>
      <returns>A paired observable with the left channel providing introspection windows and the 
            right channel providing values from the specified observable.</returns>
      <requires>source != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;IObservable&lt;TSource&gt;, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.WindowIntrospective``1(System.IObservable{``0})">
      <summary>
            Generates a sequence of windows where each window contains all values that were observed from 
            the <paramref name="source" /> while the values in the previous window were being observed.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence from which to create introspection windows.</param>
      <returns>The source observable sequence buffered into introspection windows.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IObservable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.WindowIntrospective``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Generates a sequence of windows where each window contains all values that were observed from 
            the <paramref name="source" /> while the values in the previous window were being observed.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence from which to create introspection windows.</param>
      <param name="scheduler">Schedules when windows are observed as well as the values in each window.</param>
      <returns>The source observable sequence buffered into introspection windows.</returns>
      <requires>source != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IObservable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.BufferIntrospective``1(System.IObservable{``0})">
      <summary>
            Generates a sequence of lists where each list contains all values that were observed from 
            the <paramref name="source" /> while the previous list was being observed.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence from which to create introspection lists.</param>
      <returns>The source observable sequence buffered into introspection lists.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IList&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.BufferIntrospective``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Generates a sequence of lists where each list contains all values that were observed from 
            the <paramref name="source" /> while the previous list was being observed.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence from which to create introspection lists.</param>
      <param name="scheduler">Schedules when lists are observed.</param>
      <returns>The source observable sequence buffered into introspection lists.</returns>
      <requires>source != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IList&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Maybe``1(System.IObservable{``0})">
      <summary>
            Returns the elements of the specified sequence as a sequence of <see cref="T:System.Maybe`1" />, 
            starting with <see cref="M:System.Maybe.Empty``1" />.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be projected into <see cref="T:System.Maybe`1" /> values.</param>
      <returns>A sequence m <see cref="T:System.Maybe`1" /> values that contain the values from the specified
            observable, starting with <see cref="M:System.Maybe.Empty``1" />.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Maybe&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.TimeShift``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}})">
      <summary>
            Time-shifts each value in the specified observable sequence to a sequence returned by the specified selector
            and concatenates the timer sequences returned by the selector.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TTimer">Type of the timer notifications.</typeparam>
      <param name="source">The observable sequence to be time-shifted.</param>
      <param name="timeSelector">Selects an observable sequence that indicates when the current value should be pushed.</param>
      <returns>The specified observable sequence time-shifted to the concatenated timer sequences returned by the selector.</returns>
      <requires>source != null</requires>
      <requires>timeSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.TimeShift``2(System.IObservable{``0},System.IObservable{``1})">
      <summary>
            Time-shifts each value in the specified observable sequence to the specified <paramref name="timer" />.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TTimer">Type of the timer notifications.</typeparam>
      <param name="source">The observable sequence to be time-shifted.</param>
      <param name="timer">The observable sequence to which the values from the source sequence are time-shifted.</param>
      <returns>The specified observable sequence time-shifted to the specified <paramref name="timer" /> sequence.</returns>
      <requires>source != null</requires>
      <requires>timer != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Catch``2(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception 
            until one of the observables successfully terminates.  The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Catch``2(System.Collections.Generic.IEnumerable{System.IObservable{``0}},System.Func{``1,System.TimeSpan})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception 
            using the specified back-off algorithm until one of the observables successfully terminates.
            The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="backOffSelector">Selects the amount of time to delay before moving to the next observable 
            when the current sequence has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Catch``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception 
            until one of the observables successfully terminates.  The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Catch``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}},System.Func{``1,System.Collections.Generic.IEnumerator{System.IObservable{``0}}})">
      <summary>
            Moves to the next observable sequence provided by the specified <paramref name="handler" /> when the current 
            sequence throws the specified type of exception until one of the observables successfully terminates.
            The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="handler">Selects the next enumerator when an observable from the current enumerator has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>handler != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Catch``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}},System.Func{``1,System.Collections.Generic.IEnumerator{System.IObservable{``0}}},System.Func{``1,System.TimeSpan})">
      <summary>
            Moves to the next observable sequence provided by the specified <paramref name="handler" /> when the current 
            sequence throws the specified type of exception using the specified back-off algorithm until one of the observables 
            successfully terminates.  The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="handler">Selects the next enumerator when an observable from the current enumerator has faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before moving to the next observable 
            when the current sequence has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>handler != null</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Retry``2(System.IObservable{``0},System.Int32)">
      <summary>
            Repeats the source observable sequence when it throws the specified type of exception 
            until it successfully terminates or the specified count has been reached and pairs it
            with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="retryCount">The maximum number of times to retry the sequence when it's faulted.</param>
      <returns>The specified observable sequence with an error channel.</returns>
      <requires>source != null</requires>
      <requires>retryCount &gt;= 0</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Retry``1(System.IObservable{``0},System.Int32,System.Func{System.Exception,System.Int32,System.TimeSpan})">
      <summary>
            Repeats the source observable sequence using the specified back-off algorithm until it 
            successfully terminates or the specified count has been reached and pairs it with an 
            error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="retryCount">The maximum number of times to retry the sequence when it's faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before repeating when the sequence has faulted.</param>
      <returns>The specified observable sequence with an error channel.</returns>
      <requires>source != null</requires>
      <requires>retryCount &gt;= 0</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, Exception&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Retry``2(System.IObservable{``0},System.Int32,System.Func{``1,System.Int32,System.TimeSpan})">
      <summary>
            Repeats the source observable sequence when it throws the specified type of exception
            using the specified back-off algorithm until it successfully terminates or the specified 
            count has been reached and pairs it with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="retryCount">The maximum number of times to retry the sequence when it's faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before repeating when the sequence has faulted.</param>
      <returns>The specified observable sequence with an error channel.</returns>
      <requires>source != null</requires>
      <requires>retryCount &gt;= 0</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.RetryConsecutive``1(System.IObservable{``0},System.Int32)">
      <summary>
            Repeats the source observable sequence when it throws consecutively 
            until it produces a value, successfully terminates or the specified count 
            has been reached and pairs it with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="consecutiveRetryCount">The maximum number of times to retry the sequence consecutively 
            when it's faulted.</param>
      <remarks>
        <see cref="M:System.Reactive.Linq.Observable2.RetryConsecutive``1(System.IObservable{``0},System.Int32)" /> is appropriate when permanent recovery is required for sequences 
            that experience ephemeral consecutive errors at unpredictable intervals, such as those originating 
            from network streams.  For example, it can produce a sequence that automatically reconnects upon 
            consecutive network failures up to the specified <paramref name="consecutiveRetryCount" /> number of 
            times; furthermore, if the sequence is able to successfully generate a value after an error, then 
            the retry count is reset for subsequent consecutive failures.
            </remarks>
      <returns>The specified observable sequence with an error channel.</returns>
      <requires>source != null</requires>
      <requires>consecutiveRetryCount &gt;= 0</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, Exception&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.RetryConsecutive``2(System.IObservable{``0},System.Int32)">
      <summary>
            Repeats the source observable sequence when it throws the specified type of exception 
            consecutively until it produces a value, successfully terminates or the specified count 
            has been reached and pairs it with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="consecutiveRetryCount">The maximum number of times to retry the sequence consecutively 
            when it's faulted.</param>
      <remarks>
        <see cref="M:System.Reactive.Linq.Observable2.RetryConsecutive``2(System.IObservable{``0},System.Int32)" /> is appropriate when permanent recovery is required for sequences 
            that experience ephemeral consecutive errors at unpredictable intervals, such as those originating 
            from network streams.  For example, it can produce a sequence that automatically reconnects upon 
            consecutive network failures up to the specified <paramref name="consecutiveRetryCount" /> number of 
            times; furthermore, if the sequence is able to successfully generate a value after an error, then 
            the retry count is reset for subsequent consecutive failures.
            </remarks>
      <returns>The specified observable sequence with an error channel.</returns>
      <requires>source != null</requires>
      <requires>consecutiveRetryCount &gt;= 0</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.RetryConsecutive``1(System.IObservable{``0},System.Int32,System.Func{System.Exception,System.Int32,System.TimeSpan})">
      <summary>
            Repeats the source observable sequence when it throws consecutively 
            using the specified back-off algorithm until it produces a value, successfully terminates or 
            the specified count has been reached and pairs it with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="consecutiveRetryCount">The maximum number of times to retry the sequence consecutively 
            when it's faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before repeating when the sequence has faulted.</param>
      <remarks>
        <see cref="M:System.Reactive.Linq.Observable2.RetryConsecutive``1(System.IObservable{``0},System.Int32,System.Func{System.Exception,System.Int32,System.TimeSpan})" /> is appropriate when permanent recovery is required for sequences 
            that experience ephemeral consecutive errors at unpredictable intervals, such as those originating 
            from network streams.  For example, it can produce a sequence that automatically reconnects upon 
            consecutive network failures up to the specified <paramref name="consecutiveRetryCount" /> number of 
            times; furthermore, if the sequence is able to successfully generate a value after an error, then 
            the retry count is reset for subsequent consecutive failures.
            </remarks>
      <returns>The specified observable sequence with an error channel.</returns>
      <seealso href="http://en.wikipedia.org/wiki/Exponential_backoff">
            Exponential backoff
            </seealso>
      <requires>source != null</requires>
      <requires>consecutiveRetryCount &gt;= 0</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, Exception&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.RetryConsecutive``2(System.IObservable{``0},System.Int32,System.Func{``1,System.Int32,System.TimeSpan})">
      <summary>
            Repeats the source observable sequence when it throws the specified type of exception 
            consecutively using the specified back-off algorithm until it produces a value, successfully terminates 
            or the specified count has been reached and pairs it with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="consecutiveRetryCount">The maximum number of times to retry the sequence consecutively 
            when it's faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before repeating when the sequence has faulted.</param>s
            <remarks><see cref="M:System.Reactive.Linq.Observable2.RetryConsecutive``2(System.IObservable{``0},System.Int32,System.Func{``1,System.Int32,System.TimeSpan})" /> is appropriate when permanent recovery is required for sequences 
            that experience ephemeral consecutive errors at unpredictable intervals, such as those originating 
            from network streams.  For example, it can produce a sequence that automatically reconnects upon 
            consecutive network failures up to the specified <paramref name="consecutiveRetryCount" /> number of 
            times; furthermore, if the sequence is able to successfully generate a value after an error, then 
            the retry count is reset for subsequent consecutive failures.
            </remarks><returns>The specified observable sequence with an error channel.</returns><seealso href="http://en.wikipedia.org/wiki/Exponential_backoff">
            Exponential backoff
            </seealso><requires>source != null</requires><requires>consecutiveRetryCount &gt;= 0</requires><requires>backOffSelector != null</requires><ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures></member>
    <member name="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}})">
      <summary>
            Concurrently invokes the specified factory to create observables as fast and often as possible and subscribes to all of them
            up to the default maximum concurrency.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sourceFactory">A function that returns observables.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}})" /> is similar to <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}},System.Int32)" />
            except that it does not obey the serializability guarantee for <see cref="M:System.IObserver`1.OnNext(`0)" /> that is recommended in the 
            <strong>Rx Design Guidelines</strong>.  Its behavior is therefore more suitable for hosting environments that must service multiple
            requests concurrently without blocking during observations.  This comes with the loss of automatic synchronization and thread-safety 
            that is normally provided by Rx operators, thus consumers are responsible for ensuring the thread-safety of all observers themselves.
            </para>
      </remarks>
      <returns>A concurrent observable sequence.</returns>
      <requires>sourceFactory != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Func{System.Exception,System.Boolean})">
      <summary>
            Concurrently invokes the specified factory to create observables as fast and often as possible and subscribes to all of them
            up to the default maximum concurrency.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sourceFactory">A function that returns observables.</param>
      <param name="onError">Determines whether an error should fault the entire observable sequence.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Func{System.Exception,System.Boolean})" /> is similar to <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}},System.Int32)" />
            except that it does not obey the serializability guarantee for <see cref="M:System.IObserver`1.OnNext(`0)" /> that is recommended in the 
            <strong>Rx Design Guidelines</strong>.  Its behavior is therefore more suitable for hosting environments that must service multiple
            requests concurrently without blocking during observations.  This comes with the loss of automatic synchronization and thread-safety 
            that is normally provided by Rx operators, thus consumers are responsible for ensuring the thread-safety of all observers themselves.
            </para>
        <para>
            Furthermore, <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Func{System.Exception,System.Boolean})" /> provides an <paramref name="onError" /> parameter that 
            allows the caller to decide whether an <see cref="T:System.Exception" /> is fatal and should fault the entire sequence.  This function 
            should return <see langword="true" /> to indicate that an <see cref="T:System.Exception" /> has been handled, thus preventing the sequence
            from being faulted; otherwise, return <see langword="false" /> to fault the sequence and halt processing as soon as possible.
            In the latter case, the <see cref="T:System.Exception" /> is then passed to the observer of the sequence as is the normal behavior in Rx.
            </para>
      </remarks>
      <returns>A concurrent observable sequence.</returns>
      <requires>sourceFactory != null</requires>
      <requires>onError != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Int32)">
      <summary>
            Concurrently invokes the specified factory to create observables as fast and often as possible and subscribes to all of them
            up to the specified maximum concurrency.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sourceFactory">A function that returns observables.</param>
      <param name="maxConcurrent">The maximum number of observables to be subscribed simultaneously.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Int32)" /> is similar to <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}},System.Int32)" />
            except that it does not obey the serializability guarantee for <see cref="M:System.IObserver`1.OnNext(`0)" /> that is recommended in the 
            <strong>Rx Design Guidelines</strong>.  Its behavior is therefore more suitable for hosting environments that must service multiple
            requests concurrently without blocking during observations.  This comes with the loss of automatic synchronization and thread-safety 
            that is normally provided by Rx operators, thus consumers are responsible for ensuring the thread-safety of all observers themselves.
            </para>
      </remarks>
      <returns>A concurrent observable sequence.</returns>
      <requires>sourceFactory != null</requires>
      <requires>maxConcurrent &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Int32,System.Func{System.Exception,System.Boolean})">
      <summary>
            Concurrently invokes the specified factory to create observables as fast and often as possible and subscribes to all of them
            up to the specified maximum concurrency.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sourceFactory">A function that returns observables.</param>
      <param name="maxConcurrent">The maximum number of observables to be subscribed simultaneously.</param>
      <param name="onError">Determines whether an error should fault the entire observable sequence.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Int32,System.Func{System.Exception,System.Boolean})" /> is similar to <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}},System.Int32)" />
            except that it does not obey the serializability guarantee for <see cref="M:System.IObserver`1.OnNext(`0)" /> that is recommended in the 
            <strong>Rx Design Guidelines</strong>.  Its behavior is therefore more suitable for hosting environments that must service multiple
            requests concurrently without blocking during observations.  This comes with the loss of automatic synchronization and thread-safety 
            that is normally provided by Rx operators, thus consumers are responsible for ensuring the thread-safety of all observers themselves.
            </para>
        <para>
            Furthermore, <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Int32,System.Func{System.Exception,System.Boolean})" /> provides an <paramref name="onError" /> parameter that 
            allows the caller to decide whether an <see cref="T:System.Exception" /> is fatal and should fault the entire sequence.  This function 
            should return <see langword="true" /> to indicate that an <see cref="T:System.Exception" /> has been handled, thus preventing the sequence
            from being faulted; otherwise, return <see langword="false" /> to fault the sequence and halt processing as soon as possible.
            In the latter case, the <see cref="T:System.Exception" /> is then passed to the observer of the sequence as is the normal behavior in Rx.
            </para>
      </remarks>
      <returns>A concurrent observable sequence.</returns>
      <requires>sourceFactory != null</requires>
      <requires>maxConcurrent &gt; 0</requires>
      <requires>onError != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.AsInterval``1(System.IObservable{``0},System.TimeSpan)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="minimumPeriod">The minimum amount of time to delay before the first element 
            and between elements.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.</returns>
      <requires>source != null</requires>
      <requires>minimumPeriod &gt;= TimeSpan.Zero</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.AsInterval``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="minimumPeriod">The minimum amount of time to delay before the first element 
            and between elements.</param>
      <param name="scheduler">An object used to schedule notifications.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.</returns>
      <requires>source != null</requires>
      <requires>minimumPeriod &gt;= TimeSpan.Zero</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.AsTimer``1(System.IObservable{``0},System.TimeSpan)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified minimum period
            between elements.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="minimumPeriod">The minimum amount of time to delay between elements.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements.</returns>
      <requires>source != null</requires>
      <requires>minimumPeriod &gt;= TimeSpan.Zero</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.AsTimer``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified minimum period
            between elements.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="minimumPeriod">The minimum amount of time to delay between elements.</param>
      <param name="scheduler">An object used to schedule notifications.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements.</returns>
      <requires>source != null</requires>
      <requires>minimumPeriod &gt;= TimeSpan.Zero</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pulse``1(System.IObservable{``0},System.TimeSpan)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified <paramref name="period" />, 
            with the latest value repeated when the specified sequence is silent for longer than the specified 
            <paramref name="period" />.
            </summary>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Pulse``1(System.IObservable{``0},System.TimeSpan)" /> is similar to <see cref="M:System.Reactive.Linq.Observable2.AsTimer``1(System.IObservable{``0},System.TimeSpan)" />
            in that it begins without delaying as soon as the first value is observed; however, it differs in that the 
            <paramref name="period" /> between notifications is constant and the last value is repeated at the specified interval 
            while the observable is silent.
            </para>
        <alert type="tip">
            To achieve a pulse without duplicate values, pass the returned observable to Observable.DistinctUntilChanged.
            </alert>
      </remarks>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="period">The exact amount of time to delay between elements.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.</returns>
      <requires>source != null</requires>
      <requires>period &gt;= TimeSpan.Zero</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pulse``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified <paramref name="period" />, 
            with the latest value repeated when the specified sequence is silent for longer than the specified 
            <paramref name="period" />.
            </summary>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Pulse``1(System.IObservable{``0},System.TimeSpan)" /> is similar to <see cref="M:System.Reactive.Linq.Observable2.AsTimer``1(System.IObservable{``0},System.TimeSpan)" />
            in that it begins without delaying as soon as the first value is observed; however, it differs in that the 
            <paramref name="period" /> between notifications is constant and the last value is repeated at the specified interval 
            while the observable is silent.
            </para>
        <alert type="tip">
            To achieve a pulse without duplicate values, pass the returned observable to Observable.DistinctUntilChanged.
            </alert>
      </remarks>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="period">The exact amount of time to delay between elements.</param>
      <param name="scheduler">An object used to schedule notifications.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.</returns>
      <requires>source != null</requires>
      <requires>period &gt;= TimeSpan.Zero</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.AsPairedObservable``2(System.IObservable{System.Either{``0,``1}})">
      <summary>
            Converts the specified observable sequence of <see cref="T:System.Either`2" /> into
            an <see cref="T:System.Reactive.IPairedObservable`2" />.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable sequence to convert.</param>
      <returns>The specified observable sequence as a paired observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pair``2(System.IObservable{``0},System.Func{``0,``1})">
      <summary>
            Creates a paired observable from the specified observable sequence and selector function.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="leftSource">The observable sequence that provides notifications for the left channel.</param>
      <param name="rightSelector">Selects a value for the right channel from each value in the specified observable sequence.</param>
      <returns>The specified observable sequence paired with the values produced by the selector.</returns>
      <requires>leftSource != null</requires>
      <requires>rightSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pair``2(System.IObservable{``0},System.IObservable{``1})">
      <summary>
            Creates a paired observable by combining the latest values of the specified observable sequences.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="leftSource">The observable sequence that provides notifications for the left channel.</param>
      <param name="rightSource">The observable sequence that provides notifications for the right channel.</param>
      <returns>The latest vlaues of both observable sequences paired together.</returns>
      <requires>leftSource != null</requires>
      <requires>rightSource != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pair``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,``1,System.Reactive.Linq.PairDirection})">
      <summary>
            Creates a paired observable by combining the latest values of the specified observable sequences
            and choosing which channels will receive values based on the specified selector.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="leftSource">The observable sequence that provides notifications for the left channel.</param>
      <param name="rightSource">The observable sequence that provides notifications for the right channel.</param>
      <param name="directionSelector">Selects the channels that will receive notifications for every pair.</param>
      <returns>The specified observable sequences paired together and modified by the specified selector.</returns>
      <requires>leftSource != null</requires>
      <requires>rightSource != null</requires>
      <requires>directionSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pair``1(System.IObservable{``0},System.Func{``0,System.Reactive.Linq.PairDirection})">
      <summary>
            Creates a paired observable from the specified observable sequence by choosing which channels 
            will receive each value based on the specified selector function.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable from which values will be paired based on the specified selector function.</param>
      <param name="directionSelector">Selects the channels that will receive notifications for every value in the <paramref name="source" />.</param>
      <returns>A paired observable sequence projected from the specified observable sequence based on the specified selector function.</returns>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromEventBasedAsyncPattern``1(System.Func{System.EventHandler{System.ComponentModel.AsyncCompletedEventArgs},``0},System.Action{``0},System.Action{``0},System.Action{System.Object},System.Action)">
      <summary>
            Creates an observable sequence that contains the cached result from an 
            Event-based Asynchronous Pattern (EBAP) implementation.
            </summary>
      <typeparam name="TDelegate">Type of the event's delegate.</typeparam>
      <param name="conversion">A function used to convert the given event handler to a delegate compatible
            with the underlying .NET event. The resulting delegate is used in calls to the 
            <paramref name="addHandler" /> and <paramref name="removeHandler" /> action parameters.</param>
      <param name="addHandler">Action that attaches the given event handler to the underlying .NET event.</param>
      <param name="removeHandler">Action that detaches the given event handler from the underlying .NET event.</param>
      <param name="start">An action that receives the user token object and begins the asynchronous process.</param>
      <param name="cancel">An action that cancels the asynchronous process when any subscription to the returned 
            observable is disposed.</param>
      <returns>An observable sequence that contains the cached result of the asynchronous operation.</returns>
      <seealso href="http://msdn.microsoft.com/en-us/library/wewwczdw.aspx">
            Event-based Asynchronous Pattern Overview
            </seealso>
      <requires>conversion != null</requires>
      <requires>addHandler != null</requires>
      <requires>removeHandler != null</requires>
      <requires>start != null</requires>
      <requires>cancel != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;AsyncCompletedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromEventBasedAsyncPattern``2(System.Func{System.EventHandler{``1},``0},System.Action{``0},System.Action{``0},System.Action{System.Object},System.Action)">
      <summary>
            Creates an observable sequence that contains the cached result from an 
            Event-based Asynchronous Pattern (EBAP) implementation.
            </summary>
      <typeparam name="TDelegate">Type of the event's delegate.</typeparam>
      <typeparam name="TEventArgs">Type of the event's arguments.</typeparam>
      <param name="conversion">A function used to convert the given event handler to a delegate compatible
            with the underlying .NET event. The resulting delegate is used in calls to the 
            <paramref name="addHandler" /> and <paramref name="removeHandler" /> action parameters.</param>
      <param name="addHandler">Action that attaches the given event handler to the underlying .NET event.</param>
      <param name="removeHandler">Action that detaches the given event handler from the underlying .NET event.</param>
      <param name="start">An action that receives the user token object and begins the asynchronous process.</param>
      <param name="cancel">An action that cancels the asynchronous process when any subscription to the returned 
            observable is disposed.</param>
      <returns>An observable sequence that contains the cached result of the asynchronous operation.</returns>
      <seealso href="http://msdn.microsoft.com/en-us/library/wewwczdw.aspx">
            Event-based Asynchronous Pattern Overview
            </seealso>
      <requires>conversion != null</requires>
      <requires>addHandler != null</requires>
      <requires>removeHandler != null</requires>
      <requires>start != null</requires>
      <requires>cancel != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;TEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromEventBasedAsyncPattern``3(System.Func{System.EventHandler{System.ComponentModel.AsyncCompletedEventArgs},``0},System.Action{``0},System.Action{``0},System.Func{System.EventHandler{``2},``1},System.Action{``1},System.Action{``1},System.Action{System.Object},System.Action)">
      <summary>
            Creates a paired observable sequence of progress notifications along with the cached result from an 
            Event-based Asynchronous Pattern (EBAP) implementation.
            </summary>
      <typeparam name="TDelegate">Type of the event's delegate.</typeparam>
      <typeparam name="TProgressDelegate">Type of the progress event's delegate.</typeparam>
      <typeparam name="TProgressEventArgs">Type of the progress event's arguments.</typeparam>
      <param name="conversion">A function used to convert the given event handler to a delegate compatible
            with the underlying .NET event. The resulting delegate is used in calls to the 
            <paramref name="addHandler" /> and <paramref name="removeHandler" /> action parameters.</param>
      <param name="addHandler">Action that attaches the given event handler to the underlying .NET event.</param>
      <param name="removeHandler">Action that detaches the given event handler from the underlying .NET event.</param>
      <param name="progressConversion">A function used to convert the given progress event handler to a delegate compatible
            with the underlying .NET progress event. The resulting delegate is used in calls to the 
            <paramref name="addProgressHandler" /> and <paramref name="removeProgressHandler" />  action parameters.</param>
      <param name="addProgressHandler">Action that attaches the given progress event handler to the underlying .NET progress event.</param>
      <param name="removeProgressHandler">Action that detaches the given progress event handler from the underlying .NET progress event.</param>
      <param name="start">An action that receives the user token object and begins the asynchronous process.</param>
      <param name="cancel">An action that cancels the asynchronous process when any subscription to the returned 
            observable is disposed.</param>
      <returns>A paired observable sequence of progress notifications on the left and the cached result on the right.</returns>
      <seealso href="http://msdn.microsoft.com/en-us/library/wewwczdw.aspx">
            Event-based Asynchronous Pattern Overview
            </seealso>
      <requires>conversion != null</requires>
      <requires>addHandler != null</requires>
      <requires>removeHandler != null</requires>
      <requires>progressConversion != null</requires>
      <requires>addProgressHandler != null</requires>
      <requires>removeProgressHandler != null</requires>
      <requires>start != null</requires>
      <requires>cancel != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;EventPattern&lt;TProgressEventArgs&gt;, EventPattern&lt;AsyncCompletedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromEventBasedAsyncPattern``4(System.Func{System.EventHandler{``1},``0},System.Action{``0},System.Action{``0},System.Func{System.EventHandler{``3},``2},System.Action{``2},System.Action{``2},System.Action{System.Object},System.Action)">
      <summary>
            Creates a paired observable sequence of progress notifications along with the cached result from an 
            Event-based Asynchronous Pattern (EBAP) implementation.
            </summary>
      <typeparam name="TDelegate">Type of the event's delegate.</typeparam>
      <typeparam name="TEventArgs">Type of the event's arguments.</typeparam>
      <typeparam name="TProgressDelegate">Type of the progress event's delegate.</typeparam>
      <typeparam name="TProgressEventArgs">Type of the progress event's arguments.</typeparam>
      <param name="conversion">A function used to convert the given event handler to a delegate compatible
            with the underlying .NET event. The resulting delegate is used in calls to the 
            <paramref name="addHandler" /> and <paramref name="removeHandler" /> action parameters.</param>
      <param name="addHandler">Action that attaches the given event handler to the underlying .NET event.</param>
      <param name="removeHandler">Action that detaches the given event handler from the underlying .NET event.</param>
      <param name="progressConversion">A function used to convert the given progress event handler to a delegate compatible
            with the underlying .NET progress event. The resulting delegate is used in calls to the 
            <paramref name="addProgressHandler" /> and <paramref name="removeProgressHandler" />  action parameters.</param>
      <param name="addProgressHandler">Action that attaches the given progress event handler to the underlying .NET progress event.</param>
      <param name="removeProgressHandler">Action that detaches the given progress event handler from the underlying .NET progress event.</param>
      <param name="start">An action that receives the user token object and begins the asynchronous process.</param>
      <param name="cancel">An action that cancels the asynchronous process when any subscription to the returned 
            observable is disposed.</param>
      <returns>A paired observable sequence of progress notifications on the left and the cached result on the right.</returns>
      <seealso href="http://msdn.microsoft.com/en-us/library/wewwczdw.aspx">
            Event-based Asynchronous Pattern Overview
            </seealso>
      <requires>conversion != null</requires>
      <requires>addHandler != null</requires>
      <requires>removeHandler != null</requires>
      <requires>progressConversion != null</requires>
      <requires>addProgressHandler != null</requires>
      <requires>removeProgressHandler != null</requires>
      <requires>start != null</requires>
      <requires>cancel != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;EventPattern&lt;TProgressEventArgs&gt;, EventPattern&lt;TEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Prime``1(System.Reactive.Subjects.IConnectableObservable{``0})">
      <summary>
            Connects the specified connectable observable sequence upon the first subscription and never disconnects.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The connectable observable sequence to be connected upon the first subscription.</param>
      <remarks>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>The specified observable sequence primed for use.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Prime``1(System.Reactive.Subjects.IConnectableObservable{``0},System.Action{System.IDisposable})">
      <summary>
            Connects the specified connectable observable sequence upon the first subscription and provides 
            the ability to disconnect to a callback.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The connectable observable sequence to be connected upon the first subscription.</param>
      <param name="whenConnected">Receives the subscription each time the observable is connected.</param>
      <remarks>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>The specified observable sequence primed for use.</returns>
      <requires>source != null</requires>
      <requires>whenConnected != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.StartPrimed(System.Action)">
      <summary>
            Invokes the specified <paramref name="action" /> asynchronously upon the first subscription to the returned observable.
            </summary>
      <param name="action">The action to be invoked upon the first subscription.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.StartPrimed(System.Action)" /> differs from <see cref="M:System.Reactive.Linq.Observable.Start(System.Action)" /> in that the former
            does not call the action until the first subscription, although the observable remains hot for subsequent 
            subscriptions.
            </para>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>An observable sequence primed to call the specified <paramref name="action" /> upon the first subscription.</returns>
      <requires>action != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.StartPrimed(System.Action,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Invokes the specified <paramref name="action" /> asynchronously upon the first subscription to the returned observable.
            </summary>
      <param name="action">The action to be invoked upon the first subscription.</param>
      <param name="scheduler">Schedules the call to the action.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.StartPrimed(System.Action)" /> differs from <see cref="M:System.Reactive.Linq.Observable.Start(System.Action)" /> in that the former
            does not call the action until the first subscription, although the observable remains hot for subsequent 
            subscriptions.
            </para>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>An observable sequence primed to call the specified <paramref name="action" /> upon the first subscription.</returns>
      <requires>action != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.StartPrimed``1(System.Func{``0})">
      <summary>
            Invokes the specified <paramref name="function" /> asynchronously upon the first subscription to the returned observable.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="function">The function to be invoked upon the first subscription.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.StartPrimed``1(System.Func{``0})" /> differs from <see cref="M:System.Reactive.Linq.Observable.Start``1(System.Func{``0})" /> in that the former
            does not call the function until the first subscription, although the observable remains hot for subsequent 
            subscriptions.
            </para>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>An observable sequence primed to call the specified <paramref name="function" /> upon the first subscription.</returns>
      <requires>function != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.StartPrimed``1(System.Func{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Invokes the specified <paramref name="function" /> asynchronously upon the first subscription to the returned observable.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="function">The function to be invoked upon the first subscription.</param>
      <param name="scheduler">Schedules the call to the function.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.StartPrimed``1(System.Func{``0})" /> differs from <see cref="M:System.Reactive.Linq.Observable.Start``1(System.Func{``0})" /> in that the former
            does not call the function until the first subscription, although the observable remains hot for subsequent 
            subscriptions.
            </para>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>An observable sequence primed to call the specified <paramref name="function" /> upon the first subscription.</returns>
      <requires>function != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Coerce``1(System.Object)">
      <summary>
            Coerces the specified object into an observable sequence if it implements <see cref="T:System.IObservable`1" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <remarks>
        <para>
            When a value type is used as the <strong>T</strong> parameter for <see cref="T:System.IObservable`1" />, then the interface
            cannot be treated as convariant on <strong>T</strong> even though any <srong>T</srong> can be treated as an <see cref="T:System.Object" />.
            Casting to <strong>IObservable&lt;object&gt;</strong> throws an exception at runtime.  This makes it somewhat difficult to 
            acquire an untyped reference to the object as an observable sequence of objects, hence the purpose of <see cref="M:System.Reactive.Linq.Observable2.Coerce``1(System.Object)" />.
            </para>
      </remarks>
      <param name="source">An object that may or may not implement <see cref="T:System.IObservable`1" />, or <see langword="null" />.</param>
      <returns>The specified object as an observable sequence if it implements <see cref="T:System.IObservable`1" />; otherwise, 
            <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromPropertyChangedPattern``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>
            Creates an observable sequence of property changed notifications for the specified 
            <paramref name="property" /> on the specified <paramref name="source" />.
            </summary>
      <typeparam name="TSource">Type of the object that defines the specified <paramref name="property" />.</typeparam>
      <typeparam name="TValue">Type of the property's value.</typeparam>
      <param name="source">The object that defines the specified <paramref name="property" />.</param>
      <param name="property">The property on the specified <paramref name="source" /> from which to generate property changed notifications.</param>
      <remarks>
            The following property changed notification patterns are supported: 
            <list type="bullet"><item><see cref="T:System.ComponentModel.INotifyPropertyChanged" /> implementations.</item><item>[Property]Changed event pattern.</item><item>WPF dependency properties.</item></list></remarks>
      <returns>An observable sequence of property changed notifications.</returns>
      <requires>source != null</requires>
      <requires>property != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromPropertyChangedPattern``1(System.Linq.Expressions.Expression{System.Func{``0}})">
      <summary>
            Creates an observable sequence of property changed notifications for the specified <paramref name="property" />.
            </summary>
      <typeparam name="TValue">Type of the property's value.</typeparam>
      <param name="property">The property from which to generate property changed notifications.</param>
      <remarks>
            The following property changed notification patterns are supported: 
            <list type="bullet"><item><see cref="T:System.ComponentModel.INotifyPropertyChanged" /> implementations.</item><item>[Property]Changed event pattern.</item><item>WPF dependency properties.</item></list></remarks>
      <returns>An observable sequence of property changed notifications.</returns>
      <requires>property != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="F:System.Reactive.ObservableCursor`1.firstElementIndex">
      <summary>
            Stores the index offset, relative to the source sequence, of the first value in the <see cref="F:System.Reactive.ObservableCursor`1.elements" /> list.
            </summary>
      <remarks>
            This field is used as part of a memory optimization in a forward-only cursor that allows elements to be removed
            when the cursor and all dependent branches have moved passed them, consequently offsetting the indexes in the 
            <see cref="F:System.Reactive.ObservableCursor`1.elements" /> list with respect to the actual source sequence.
            </remarks>
    </member>
    <member name="T:System.Reactive.Subjects.CursorSubject`1">
      <summary>
            Represents an observer and a replaying observable sequence with a current index that can be moved.
            </summary>
      <remarks>
        <para>
            A cursor is a moveable pointer over an immutable sequence.  This differs from the concept of a <see cref="T:System.IO.Stream" />, 
            which is a moveable pointer over a mutable buffer.  Mutability is a key difference; it means that moving the position of a
            stream backward allows you to overwrite the data from that position to the end of the stream, while moving the position of a 
            cursor backward only changes the index in the sequence from which data is replayed to new subscribers.  In other words, data 
            written to a stream is always inserted at the current position, but data observed by a cursor is always appended to the end 
            of the buffered sequence.
            </para>
        <para>
            Furthermore, the position of a stream is shared between reads and writes, but the position of a cursor is not.  A cursor's 
            position is only used by reads (subscribers) and is entirely independent of writes.  Subscribing to a cursor replays the data 
            in the sequence from the current index to the end; however, the current index is not moved at all.  Changing the index later
            has no effect on existing subscriptions, but changing the position of a stream would certainly effect existing readers.
            </para>
        <para>
          <see cref="T:System.Reactive.Subjects.CursorSubject`1" /> provides a superset of the functionality that is provided by <see cref="T:System.Reactive.Subjects.Subject`1" />, 
            <see cref="T:System.Reactive.Subjects.BehaviorSubject`1" /> and <see cref="T:System.Reactive.Subjects.ReplaySubject`1" />.  Each of these subjects could be implemented in terms
            of <see cref="T:System.Reactive.Subjects.CursorSubject`1" /> by moving the <see cref="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex" /> after calling <see cref="M:System.Reactive.Subjects.CursorSubject`1.OnNext(`0)" />, as necessary.
            </para>
      </remarks>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <invariant>gate != null</invariant>
      <invariant>cursor != null</invariant>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.CursorSubject`1" /> class with bidirectional behavior.
            </summary>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.#ctor(System.Boolean)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.CursorSubject`1" /> class.
            </summary>
      <param name="isForwardOnly">
        <see langword="True" /> if the cursor can only be moved forward; 
            otherwise, <see langword="false" />.</param>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.Subscribe(System.IObserver{`0})">
      <summary>
            Notifies the cursor that an observer is to receive notifications.
            </summary>
      <param name="observer">The object that is to receive notifications.</param>
      <returns>The observer's interface that enables resources to be disposed.</returns>
      <requires inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.Subscribe(System.IObserver{`0},System.Int32)">
      <summary>
            Notifies the provider that an observer is to receive the specified maximum number of <strong>OnNext</strong> notifications.
            </summary>
      <remarks>
        <para>
            This overload to <see cref="M:System.IObservable`1.Subscribe(System.IObserver{`0})" /> behaves similarly except that it has a 
            <paramref name="count" /> parameter that specifies the maximum number of elements that may be pushed to the
            <paramref name="observer" />.  Essentially, it provides an optimized alternative to <see cref="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)" />.
            </para>
        <para>
            The <paramref name="count" /> parameter applies to cursors because they typically will buffer data from the source 
            sequence and replay it to subscribers, starting from the current index and continuing to the latest value that has 
            been buffered.  When a subscriber only wants to view a range of data, then <see cref="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)" /> is often 
            added to the query to specify the number of notifications that are desired; however, the <see cref="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)" /> 
            operator cannot cancel the notifications that are being replayed from the cursor, so it simply drops any additional 
            notifications that exceed the specified limit.  The specified <paramref name="observer" /> will not observe the 
            additional notifications, although the overhead of replaying an entire buffered sequence to the 
            <see cref="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)" /> operator could have a noticeable impact on the performance of your code.  By implementing
            <see cref="M:System.Reactive.Subjects.CursorSubject`1.Subscribe(System.IObserver{`0},System.Int32)" />, replayed notifications can be stopped  when the specified <paramref name="count" />
            is reached.
            </para>
      </remarks>
      <param name="observer">The object that is to receive notifications.</param>
      <param name="count">The maximum number of elements to be observed.</param>
      <returns>The observer's interface that enables resources to be disposed.</returns>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">observer != null</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">count &gt;= 0</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.Connect">
      <summary>
            Not supported.
            </summary>
      <returns>Throws <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">This method is not supported.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.OnNext(`0)">
      <summary>
            Provides the cursor with new data.
            </summary>
      <param name="value">The current notification information.</param>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.OnError(System.Exception)">
      <summary>
            Notifies the cursor that the provider has experienced an error condition.
            </summary>
      <param name="error">An object that provides additional information about the error.</param>
      <requires inheritedFrom="M:System.IObserver`1.OnError(System.Exception)" inheritedFromTypeName="IObserver">error != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.OnCompleted">
      <summary>
            Notifies the cursor that the provider has finished sending push-based notifications.
            </summary>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.Move(System.Int32)">
      <summary>
            Changes the current index of the cursor to the element at the specified number of elements forward or backward.
            </summary>
      <param name="count">The number of elements to move after the current index if the specified count is positive
            or before the current index if the specified count is negative.</param>
      <remarks>
        <para>
            The specified <paramref name="count" /> may be a negative number only if <see cref="P:System.Reactive.Subjects.CursorSubject`1.IsForwardOnly" /> is <see langword="false" />.
            </para>
      </remarks>
      <seealso cref="P:System.Reactive.Subjects.CursorSubject`1.IsForwardOnly" />
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.Branch">
      <summary>
            Returns a new cursor that starts at the current position of this cursor and is tied to the lifetime of this cursor.
            </summary>
      <remarks>
        <alert type="implementors">
          <see cref="M:System.Reactive.Subjects.CursorSubject`1.Branch" /> provides a means for cursor authors to optimize branches so that they can share the same state.
            </alert>
      </remarks>
      <returns>A new cursor that starts at the current position of this cursor.</returns>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSynchronized == IsSynchronized</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.ToString">
      <summary>
            Returns a string representation of the cursor.
            </summary>
      <returns>A string representation of the cursor.</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.Dispose">
      <summary>
            Permanently releases all observers and buffered elements.
            </summary>
    </member>
    <member name="P:System.Reactive.Subjects.CursorSubject`1.IsSynchronized">
      <summary>
            Gets a value indicating whether the cursor's methods and properties can be used concurrently by multiple threads.
            </summary>
      <value>Always returns <see langword="true" />.</value>
      <getter>
        <ensures>Contract.Result&lt;bool&gt;()</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.CursorSubject`1.IsForwardOnly">
      <summary>
            Gets a value indicating whether the cursor only moves forward.
            </summary>
      <value>
        <see langword="True" /> if the cursor only moves forward; otherwise, <see langword="false" />.</value>
      <seealso cref="M:System.Reactive.Subjects.CursorSubject`1.Move(System.Int32)" />
    </member>
    <member name="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex">
      <summary>
            Gets the zero-based index of the element in the sequence at which the cursor is positioned after 
            <see cref="M:System.Reactive.Subjects.CursorSubject`1.Move(System.Int32)" /> is called.
            </summary>
      <remarks>
        <para>
          <see cref="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex" /> starts and remains at 0 until it is changed by the <see cref="M:System.Reactive.Subjects.CursorSubject`1.Move(System.Int32)" /> method.  A value of 0 indicates
            that the cursor is positioned at the end of an empty sequence.  If the sequence generates one or more values, then 0 indicates
            that the cursor is positioned at the beginning of the sequence.  Subscribing to a cursor that has not moved replays all values in 
            the sequence, if any.
            </para>
        <para>
            The valid range of values for <see cref="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex" /> changes depending upon whether the sequence has terminated.
            If the sequence has not terminated, then <see cref="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex" /> can be any value that is greater than or equal to zero, 
            even if that value is greater than <see cref="P:System.Reactive.Subjects.CursorSubject`1.LatestIndex" />; however, once the sequence has terminated, 
            <see cref="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex" /> cannot be moved past one more than the <see cref="P:System.Reactive.Subjects.CursorSubject`1.LatestIndex" />.  This final position 
            indicates that the cursor is at the end of the sequence.  Calling <strog>Subscribe</strog> on a cursor that is 
            positioned at the end of the sequence causes only the termination notification to be pushed, without replaying any values.
            </para>
        <para>
            If <see cref="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex" /> is moved past the latest element in the sequence, as indicated by the value of 
            <see cref="P:System.Reactive.Subjects.CursorSubject`1.LatestIndex" />, then the existing values in the sequence will not be replayed to new subscriptions; 
            furthermore, any new values with indices that are less than <see cref="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex" /> will also be excluded from
            new subscriptions.
            </para>
        <para>
            If the current index is positioned ahead of the latest element in the sequence and the sequence 
            subsequently ends, then the current index is automatically changed to <see cref="P:System.Reactive.Subjects.CursorSubject`1.LatestIndex" /> + 1 to indicate 
            that the current index is at the end of the sequence.  Consumers can check whether <see cref="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex" /> has changed 
            during the <strong>OnCompleted</strong> notification.
            </para>
      </remarks>
      <value>The zero-based index of the element in the sequence on which the cursor is positioned after 
            <see cref="M:System.Reactive.Subjects.CursorSubject`1.Move(System.Int32)" /> is called; otherwise, -1.</value>
      <getter>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.CursorSubject`1.LatestIndex">
      <summary>
            Gets the zero-based index of the last known element in the sequence.
            </summary>
      <value>The zero-based index of the last known element in the sequence; -1 until the sequence produces an element, if any.
            If the sequence has terminated, then the value is the index of the last element in the sequence.</value>
      <getter>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_LatestIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.CursorSubject`1.AtEndOfSequence">
      <summary>
            Gets a value indicating whether the cursor is positioned at the end of the sequence.
            </summary>
      <remarks>
        <alert type="note">
            When <see cref="P:System.Reactive.Subjects.CursorSubject`1.AtEndOfSequence" /> returns <see langword="false" /> it does not indicate that the sequence has 
            not terminated.  It only indicates that the cursor is not currently positioned at the end of the sequence,
            regardless of whether the sequence has actually terminated or not.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the sequence has terminated and the cursor is currently positioned at the end of the sequence;
            otherwise, <see langword="false" />.</value>
      <seealso cref="P:System.Reactive.Subjects.CursorSubject`1.IsSequenceTerminated" />
      <getter>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">!Contract.Result&lt;bool&gt;() || IsSequenceTerminated</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.CursorSubject`1.IsSequenceTerminated">
      <summary>
            Gets a value indicating whether the sequence has terminated.
            </summary>
      <remarks>
        <alert type="note">
            When <see cref="P:System.Reactive.Subjects.CursorSubject`1.IsSequenceTerminated" /> returns <see langword="true" /> it does not indicate that the cursor is at the
            end of the sequence.  It only indicates that the sequence has terminated, regardless of whether the 
            cursor is actually positioned at the end of the sequence or not.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the sequence has terminated; otherwise, <see langword="false" />.</value>
      <seealso cref="P:System.Reactive.Subjects.CursorSubject`1.AtEndOfSequence" />
    </member>
    <member name="P:System.Reactive.Subjects.CursorSubject`1.IsDisposed">
      <summary>
            Gets a value indicating whether the subject is disposed.
            </summary>
      <value>
        <see langword="True" /> if the subject is disposed; otherwise, <see langword="false" />.</value>
    </member>
    <member name="T:System.Windows.Reactive.View">
      <summary>
            Provides the attached property <see cref="F:System.Windows.Reactive.View.ModelProperty" />, which attaches a model factory to a <see cref="T:System.Windows.FrameworkElement" /> 
            object by specifying the <see cref="T:System.Type" /> of the model.
            </summary>
    </member>
    <member name="F:System.Windows.Reactive.View.ModelProperty">
      <summary>
            Represents the <strong>Model</strong> attached property in XAML, which specifies the <see cref="T:System.Type" /> of the model to be attached 
            to a <see cref="T:System.Windows.FrameworkElement" />.  The type must define a parameterless default constructor that will be used to create a new 
            instance each time that the target <see cref="T:System.Windows.FrameworkElement" /> is loaded.
            </summary>
      <remarks>
        <para>
            The specified <see cref="T:System.Type" /> does not have to implement any particular interfaces or derive from any particular base class; 
            however, a few special interfaces are supported to provide additional functionality.  See the 
            <see cref="T:System.Windows.FrameworkElementExtensions" /> documentation for more information.
            </para>
        <alert type="warning">
            Do not attempt to get or set the value of <see cref="F:System.Windows.Reactive.View.ModelProperty" /> in code; instead, use the 
            <see cref="T:System.Windows.FrameworkElementExtensions" /> class directly.  Though it does not reflect whether <see cref="F:System.Windows.Reactive.View.ModelProperty" />
            was used to create an attachment, it always retrieves the current attachment object for the specified <see cref="T:System.Windows.FrameworkElement" />.
            </alert>
      </remarks>
    </member>
    <member name="M:System.Windows.Reactive.View.GetModel(System.Windows.FrameworkElement)">
      <summary>
            Gets the <see cref="T:System.Type" /> of the model assigned to the <see cref="F:System.Windows.Reactive.View.ModelProperty" /> attached property for the specified 
            <paramref name="element" />.  Do not use this method.  See the remarks section for more information.
            </summary>
      <remarks>
        <see cref="M:System.Windows.Reactive.View.GetModel(System.Windows.FrameworkElement)" /> only returns the model type that was assigned by the <see cref="F:System.Windows.Reactive.View.ModelProperty" /> attached property.
            To get the currently attached model, regardless of how it was attached, call the <see cref="M:System.Windows.FrameworkElementExtensions.GetViewModel(System.Windows.FrameworkElement)" /> 
            method instead.
            </remarks>
      <param name="element">The <see cref="T:System.Windows.FrameworkElement" /> from which to retrieve the value of the <see cref="F:System.Windows.Reactive.View.ModelProperty" /> 
            attached property.</param>
      <returns>The <see cref="T:System.Type" /> of the model that is attached to the specified <paramref name="element" /> via the 
            <see cref="F:System.Windows.Reactive.View.ModelProperty" /> attached property, or <see langword="null" /> if no model was attached via that property.</returns>
      <requires>element != null</requires>
    </member>
    <member name="M:System.Windows.Reactive.View.SetModel(System.Windows.FrameworkElement,System.Type)">
      <summary>
            Sets the value of the <see cref="F:System.Windows.Reactive.View.ModelProperty" /> attached property for the specified <paramref name="element" /> to the specified
            <paramref name="modelType" /> and attaches a factory that creates instances of the specified model Type
            for the specified <paramref name="element" />.
            </summary>
      <remarks>
        <see cref="M:System.Windows.Reactive.View.SetModel(System.Windows.FrameworkElement,System.Type)" /> sets the <see cref="T:System.Type" /> of the model for the <see cref="F:System.Windows.Reactive.View.ModelProperty" /> attached property and also 
            attaches a factory for the model using the <see cref="M:System.Windows.FrameworkElementExtensions.SetViewModel(System.Windows.FrameworkElement,System.Func{System.Object})" /> method.
            Using <see cref="T:System.Windows.FrameworkElementExtensions" /> directly is recommended instead of calling <see cref="M:System.Windows.Reactive.View.SetModel(System.Windows.FrameworkElement,System.Type)" />, even though it 
            doesn't set the value of the <see cref="F:System.Windows.Reactive.View.ModelProperty" /> attached property.
            </remarks>
      <param name="element">The <see cref="T:System.Windows.FrameworkElement" /> to which the specified <paramref name="modelType" /> will be attached.</param>
      <param name="modelType">The <see cref="T:System.Type" /> of the object to be attached to the specified <paramref name="element" />.</param>
      <requires>element != null</requires>
    </member>
    <member name="T:System.Windows.Reactive.IViewModel">
      <summary>
            When implemented, represents a <see cref="T:System.Windows.FrameworkElement" /> attachment that may provide binding targets for properties and events.
            </summary>
    </member>
    <member name="M:System.Windows.Reactive.IViewModel.Attach(System.Windows.FrameworkElement)">
      <summary>
            Attaches this view model to the specified <paramref name="element" />.
            </summary>
      <param name="element">The <see cref="T:System.Windows.FrameworkElement" /> to which this view model must be attached.</param>
      <requires>element != null</requires>
      <requires>!IsAttached</requires>
      <ensures>IsAttached</ensures>
    </member>
    <member name="M:System.Windows.Reactive.IViewModel.Detach">
      <summary>
            Detaches this view model if it's currently attached; otherwise, performs no action.
            </summary>
      <requires>IsAttached</requires>
      <ensures>!IsAttached</ensures>
    </member>
    <member name="P:System.Windows.Reactive.IViewModel.IsAttached">
      <summary>
            Gets a value indicating whether the view model is currently attached to a <see cref="T:System.Windows.FrameworkElement" />.
            </summary>
      <value>
        <see langword="True" /> if the view model is attached; otherwise, <see langword="false" />.</value>
    </member>
    <member name="T:Rxx.Parsers.Reactive.StringObservableParser`1">
      <summary>
            Represents a parser over an observable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
      <invariant>whiteSpace != null</invariant>
      <invariant>insignificantWhiteSpace != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.Reactive.ObservableParser`2">
      <summary>
            Represents a parser over an observable sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParser`2.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.Parser`2" /> class for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})">
      <summary>
            Subscribes to the specified observable sequence and applies the parser's grammar, 
            which is defined by <see cref="P:Rxx.Parsers.Reactive.ObservableParser`2.Start" />, to generate matches.
            </summary>
      <param name="source">The oservable sequence to parse.</param>
      <returns>An observable sequence of parse results.</returns>
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParser`2.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current parser.
            </summary>
      <returns>A <see cref="T:System.String" /> that represents the current parser.</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParser`2.Next">
      <summary>
            Gets a parser with a grammar that matches the next element in the source sequence.
            </summary>
      <remarks>
            A parser's grammar is defined in terms of grammar rules, each of which is defined in terms of the <see cref="P:Rxx.Parsers.Reactive.ObservableParser`2.Next" /> parser
            or another rule.
            </remarks>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParser`2.Start">
      <summary>
            Gets the parser's grammar as a parser that is defined in terms of the <see cref="P:Rxx.Parsers.Reactive.ObservableParser`2.Next" /> parser.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.IStringObservableParser`1">
      <summary>
            Represents a parser over an observable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires>stops != null</requires>
      <requires>stops.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires>stopWords != null</requires>
      <requires>stopWords.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires>!string.IsNullOrEmpty(value)</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IStringObservableParser`1.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IStringObservableParser`1.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive insignificant whitespace characters and joins
            them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.Reactive.StringObservableParser`1" /> class for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires>stops != null</requires>
      <requires>stops.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires>stopWords != null</requires>
      <requires>stopWords.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires>!string.IsNullOrEmpty(value)</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive whitespace characters determined by the 
            <see cref="P:Rxx.Parsers.Reactive.StringObservableParser`1.InsignificantWhiteSpaceCharacters" /> collection and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.InsignificantWhiteSpaceCharacters">
      <summary>
            Gets a collection of characters that are considered insignificant whitespace for the  
            <see cref="P:Rxx.Parsers.Reactive.StringObservableParser`1.InsignificantWhiteSpace" /> parser.  
            </summary>
      <getter>
        <ensures>Contract.Result&lt;ICollection&lt;char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.XmlObservableParser`1">
      <summary>
            Represents an XML parser over an observable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of XML nodes.</typeparam>
      <invariant>comparer != null</invariant>
      <invariant>id != null</invariant>
      <invariant>tagStart != null</invariant>
      <invariant>tagEnd != null</invariant>
      <invariant>tagName != null</invariant>
      <invariant>attributeDelimiter != null</invariant>
      <invariant>attributeName != null</invariant>
      <invariant>attributeValue != null</invariant>
      <invariant>attribute != null</invariant>
      <invariant>openTag != null</invariant>
      <invariant>closeTag != null</invariant>
      <invariant>text != null</invariant>
      <invariant>comment != null</invariant>
      <invariant>cData != null</invariant>
      <invariant>element != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.Reactive.IXmlObservableParser`1">
      <summary>
            Represents an XML parser over an observable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of XML nodes.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Attribute(System.String)">
      <summary>
            Creates a parser that matches a single XML attribute with the specified <paramref name="name" />.
            </summary>
      <param name="name">The name of the attribute to match.</param>
      <returns>A parser that matches a single XML attribute with the specified <paramref name="name" />.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified attributes and children.
            </summary>
      <param name="content">The parsers that match the element's attributes, child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.
            </summary>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.
            </summary>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.</returns>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parsers that match the element's attributes, child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, having no attributes
            and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, having no attributes 
            and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">An enumerable sequence containing the names of the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.Text">
      <summary>
            Gets a parser with a grammar that matches all characters, including whitespace, up to the start tag of an element.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.Comment">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;!-- and ending with --&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.CData">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;![CDATA[ and ending with ]]&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.AnyContent">
      <summary>
            Gets a parser with a grammar that matches any <see cref="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.Text" />, <see cref="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.Comment" /> or <see cref="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.CData" /> content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.AnyElement">
      <summary>
            Gets a parser with a grammar that matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.AnyAttribute">
      <summary>
            Gets a parser with a grammar that matches an XML attribute.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.#ctor(System.Boolean)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.Reactive.XmlObservableParser`1" /> class with the specified case-sensitivity
            for derived classes.
            </summary>
      <param name="caseSensitive">Indicates whether the comparison behavior used for matching element and attribute names
            must ignore case.</param>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.Reactive.XmlObservableParser`1" /> class with case-sensitive element and 
            attribute name comparisons for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Attribute(System.String)">
      <summary>
            Creates a parser that matches a single XML attribute with the specified <paramref name="name" />.
            </summary>
      <param name="name">The name of the attribute to match.</param>
      <returns>A parser that matches a single XML attribute with the specified <paramref name="name" />.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified attributes and children.
            </summary>
      <param name="content">The parsers that match the element's attributes, child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.
            </summary>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.
            </summary>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.</returns>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parsers that match the element's attributes, child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, having no attributes
            and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, having no attributes 
            and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">An enumerable sequence containing the names of the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Start">
      <summary>
            Gets the <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Schema" /> that is the parser's grammar.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParser`2.get_Start" inheritedFromTypeName="ObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Schema">
      <summary>
            Gets the parser's grammar as an XML schema that is defined in terms of the parsers created by
            <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.AnyElement" />, <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.AnyAttribute" />, <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.AnyContent" />, <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Text" />, 
            <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Comment" />, <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.CData" /> or any of the methods that create parsers with 
            context-sensitive grammars, such as <see cref="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" /> and 
            <see cref="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Attribute(System.String)" /></summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Text">
      <summary>
            Gets a parser with a grammar that matches all characters, including whitespace, up to the start tag of an element.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Comment">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;!-- and ending with --&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.CData">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;![CDATA[ and ending with ]]&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.AnyContent">
      <summary>
            Gets a parser with a grammar that matches any <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Text" />, <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Comment" /> or <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.CData" /> content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.AnyElement">
      <summary>
            Gets a parser with a grammar that matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.AnyAttribute">
      <summary>
            Gets a parser with a grammar that matches an XML attribute.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2">
      <summary>
            Represents a parser context over an enumerable sequence of <see cref="T:System.Char" />
            to support in-line grammars.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
      <typeparam name="TQueryValue">The type of the current value in the query context.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Char)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_AnyCharacter" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_WhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive insignificant whitespace characters and joins
            them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.XmlObservableParser">
      <summary>
            Represents a context-free XML parser over an observable sequence of <see cref="T:System.Char" />.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser.#ctor(System.Boolean)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.Reactive.XmlObservableParser" /> class with the specified case-sensitivity.
            </summary>
      <param name="caseSensitive">Indicates whether the comparison behavior used for matching element and attribute names
            must ignore case.</param>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.Reactive.XmlObservableParser" /> class.
            </summary>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser.Schema">
      <summary>
            Gets the parser's grammar.  The default grammar matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.XmlObservableParser`1.get_Schema" inheritedFromTypeName="XmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2">
      <summary>
            Represents an XML parser context over an observable sequence of <see cref="T:System.Char" />
            to support in-line grammars.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of XML nodes.</typeparam>
      <typeparam name="TQueryValue">The type of the current value in the query context.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Attribute(System.String)">
      <summary>
            Creates a parser that matches a single XML attribute with the specified <paramref name="name" />.
            </summary>
      <param name="name">The name of the attribute to match.</param>
      <returns>A parser that matches a single XML attribute with the specified <paramref name="name" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrWhiteSpace(name)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified attributes and children.
            </summary>
      <param name="content">The parsers that match the element's attributes, child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.
            </summary>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.
            </summary>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parsers that match the element's attributes, child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, having no attributes
            and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, having no attributes 
            and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">An enumerable sequence containing the names of the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Text">
      <summary>
            Gets a parser with a grammar that matches all characters, including whitespace, up to the start tag of an element.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Text" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Comment">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;!-- and ending with --&gt;.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Comment" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.CData">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;![CDATA[ and ending with ]]&gt;.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_CData" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.AnyContent">
      <summary>
            Gets a parser with a grammar that matches any <see cref="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Text" />, <see cref="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Comment" /> or <see cref="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.CData" /> content.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyContent" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.AnyElement">
      <summary>
            Gets a parser with a grammar that matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyElement" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.AnyAttribute">
      <summary>
            Gets a parser with a grammar that matches an XML attribute.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.XmlParser">
      <summary>
            Represents a context-free XML parser over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />.
            </summary>
    </member>
    <member name="T:Rxx.Parsers.XmlParser`1">
      <summary>
            Represents an XML parser over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of XML nodes.</typeparam>
      <invariant>comparer != null</invariant>
      <invariant>id != null</invariant>
      <invariant>tagStart != null</invariant>
      <invariant>tagEnd != null</invariant>
      <invariant>tagName != null</invariant>
      <invariant>attributeDelimiter != null</invariant>
      <invariant>attributeName != null</invariant>
      <invariant>attributeValue != null</invariant>
      <invariant>attribute != null</invariant>
      <invariant>openTag != null</invariant>
      <invariant>closeTag != null</invariant>
      <invariant>text != null</invariant>
      <invariant>comment != null</invariant>
      <invariant>cData != null</invariant>
      <invariant>element != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.StringParser`1">
      <summary>
            Represents a parser over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
      <invariant>whiteSpace != null</invariant>
      <invariant>insignificantWhiteSpace != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.Parser`2">
      <summary>
            Represents a parser over an enumerable sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Parser`2.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.Parser`2" /> class for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Parser`2.Parse(System.Linq.ICursor{`0})">
      <summary>
            Iterates the specified enumerable sequence and applies the parser's grammar, 
            which is defined by <see cref="P:Rxx.Parsers.Parser`2.Start" />, to generate matches.
            </summary>
      <param name="source">The enumerable sequence to parse.</param>
      <returns>An enumerable sequence of parse results.</returns>
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Parser`2.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current parser.
            </summary>
      <returns>A <see cref="T:System.String" /> that represents the current parser.</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Parser`2.Next">
      <summary>
            Gets a parser with a grammar that matches the next element in the source sequence.
            </summary>
      <remarks>
            A parser's grammar is defined in terms of grammar rules, each of which is defined in terms of the <see cref="P:Rxx.Parsers.Parser`2.Next" /> parser
            or another rule.
            </remarks>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Parser`2.Start">
      <summary>
            Gets the parser's grammar as a parser that is defined in terms of the <see cref="P:Rxx.Parsers.Parser`2.Next" /> parser.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.IStringParser`1">
      <summary>
            Represents a parser over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires>stops != null</requires>
      <requires>stops.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires>stopWords != null</requires>
      <requires>stopWords.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires>!string.IsNullOrEmpty(value)</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.IStringParser`1.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IStringParser`1.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IStringParser`1.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive insignificant whitespace characters and joins
            them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.StringParser`1" /> class for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires>stops != null</requires>
      <requires>stops.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires>stopWords != null</requires>
      <requires>stopWords.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires>!string.IsNullOrEmpty(value)</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive whitespace characters determined by the 
            <see cref="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpaceCharacters" /> collection and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpaceCharacters">
      <summary>
            Gets a collection of characters that are considered insignificant whitespace for the  
            <see cref="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpace" /> parser.  
            </summary>
      <getter>
        <ensures>Contract.Result&lt;ICollection&lt;char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.IXmlParser`1">
      <summary>
            Represents an XML parser over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of XML nodes.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)">
      <summary>
            Creates a parser that matches a single XML attribute with the specified <paramref name="name" />.
            </summary>
      <param name="name">The name of the attribute to match.</param>
      <returns>A parser that matches a single XML attribute with the specified <paramref name="name" />.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified attributes and children.
            </summary>
      <param name="content">The parsers that match the element's attributes, child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.
            </summary>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.
            </summary>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.</returns>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parsers that match the element's attributes, child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, having no attributes
            and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, having no attributes 
            and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">An enumerable sequence containing the names of the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.Text">
      <summary>
            Gets a parser with a grammar that matches all characters, including whitespace, up to the start tag of an element.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.Comment">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;!-- and ending with --&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.CData">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;![CDATA[ and ending with ]]&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.AnyContent">
      <summary>
            Gets a parser with a grammar that matches any <see cref="P:Rxx.Parsers.IXmlParser`1.Text" />, <see cref="P:Rxx.Parsers.IXmlParser`1.Comment" /> or <see cref="P:Rxx.Parsers.IXmlParser`1.CData" /> content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.AnyElement">
      <summary>
            Gets a parser with a grammar that matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.AnyAttribute">
      <summary>
            Gets a parser with a grammar that matches an XML attribute.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.#ctor(System.Boolean)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.XmlParser`1" /> class with the specified case-sensitivity
            for derived classes.
            </summary>
      <param name="caseSensitive">Indicates whether the comparison behavior used for matching element and attribute names
            must ignore case.</param>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.XmlParser`1" /> class with case-sensitive element and 
            attribute name comparisons for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Attribute(System.String)">
      <summary>
            Creates a parser that matches a single XML attribute with the specified <paramref name="name" />.
            </summary>
      <param name="name">The name of the attribute to match.</param>
      <returns>A parser that matches a single XML attribute with the specified <paramref name="name" />.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified attributes and children.
            </summary>
      <param name="content">The parsers that match the element's attributes, child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.
            </summary>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.
            </summary>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.</returns>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parsers that match the element's attributes, child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, having no attributes
            and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, having no attributes 
            and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">An enumerable sequence containing the names of the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrWhiteSpace(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Start">
      <summary>
            Gets the <see cref="P:Rxx.Parsers.XmlParser`1.Schema" /> that is the parser's grammar.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Parser`2.get_Start" inheritedFromTypeName="Parser">Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Schema">
      <summary>
            Gets the parser's grammar as an XML schema that is defined in terms of the parsers created by
            <see cref="P:Rxx.Parsers.XmlParser`1.AnyElement" />, <see cref="P:Rxx.Parsers.XmlParser`1.AnyAttribute" />, <see cref="P:Rxx.Parsers.XmlParser`1.AnyContent" />, <see cref="P:Rxx.Parsers.XmlParser`1.Text" />, 
            <see cref="P:Rxx.Parsers.XmlParser`1.Comment" />, <see cref="P:Rxx.Parsers.XmlParser`1.CData" /> or any of the methods that create parsers with 
            context-sensitive grammars, such as <see cref="M:Rxx.Parsers.XmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" /> and 
            <see cref="M:Rxx.Parsers.XmlParser`1.Attribute(System.String)" /></summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Text">
      <summary>
            Gets a parser with a grammar that matches all characters, including whitespace, up to the start tag of an element.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Comment">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;!-- and ending with --&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.CData">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;![CDATA[ and ending with ]]&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.AnyContent">
      <summary>
            Gets a parser with a grammar that matches any <see cref="P:Rxx.Parsers.XmlParser`1.Text" />, <see cref="P:Rxx.Parsers.XmlParser`1.Comment" /> or <see cref="P:Rxx.Parsers.XmlParser`1.CData" /> content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.AnyElement">
      <summary>
            Gets a parser with a grammar that matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.AnyAttribute">
      <summary>
            Gets a parser with a grammar that matches an XML attribute.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParser.#ctor(System.Boolean)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.XmlParser" /> class with the specified case-sensitivity.
            </summary>
      <param name="caseSensitive">Indicates whether the comparison behavior used for matching element and attribute names
            must ignore case.</param>
    </member>
    <member name="M:Rxx.Parsers.XmlParser.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.XmlParser" /> class.
            </summary>
    </member>
    <member name="P:Rxx.Parsers.XmlParser.Schema">
      <summary>
            Gets the parser's grammar.  The default grammar matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.XmlParser`1.get_Schema" inheritedFromTypeName="XmlParser">Contract.Result&lt;IParser&lt;char, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AmbiguousObservableParser`3">
      <summary>
            Represents an ambiguous parser that begins a parse operation at the current position of the source sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TUntilResult">The type of the elements that are generated by the optional until parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>parser != null</invariant>
      <invariant>untilCount &gt;= unlimitedCount</invariant>
    </member>
    <member name="T:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions">
      <summary>
            Provides <see langword="static" /> methods for defining <see cref="T:Rxx.Parsers.Reactive.IObservableParser`2" /> grammars.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Aggregate``4(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},System.Func{``2},System.Func{``2,``1,``2},System.Func{``2,``3})">
      <summary>
            Applies an <paramref name="accumulator" /> function over each result sequence from the 
            specified <paramref name="parser" /> and yields a sequence of accumulated results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TAccumulate">The type of the accumulation.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulation.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be aggregated.</param>
      <param name="seed">A function that returns the initial value of the accumulation for each parse result.</param>
      <param name="accumulator">A function to be invoked on each element of each parse result.</param>
      <param name="selector">A function that projects the final aggregation of each parse result.</param>
      <returns>A parser that returns the aggregated results.</returns>
      <requires>parser != null</requires>
      <requires>accumulator != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Join``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Appends each element in each result sequence from the specified <paramref name="parser" /> 
            to an accumulated <see cref="T:System.String" />, yielding a single <see cref="T:System.String" /> per result
            sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined into strings.</param>
      <returns>A parser that returns the aggregated <see cref="T:System.String" /> results.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Join``3(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},System.Func{System.String,``2})">
      <summary>
            Appends each element in each result from the specified <paramref name="parser" /> 
            to an accumulated <see cref="T:System.String" /> and projects the strings for each result.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulated <see cref="T:System.String" />.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined.</param>
      <param name="selector">A function that projects the aggregated <see cref="T:System.String" /> of each parse result.</param>
      <returns>A parser that returns the joined results.</returns>
      <requires>parser != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Join``4(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},System.Func{``1,``2},System.Func{System.String,``3})">
      <summary>
            Applies a <paramref name="joiner" /> function over each result from the specified 
            <paramref name="parser" /> to create an accumulated <see cref="T:System.String" /> and projects 
            the strings for each result.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TJoin">The type of the accumulation on which <see cref="M:System.Object.ToString" /> is called.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulated <see cref="T:System.String" />.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined.</param>
      <param name="joiner">A function to be invoked on each element of each parse result to produce a value 
            on which <see cref="M:System.Object.ToString" /> is called and appended to the accumulation.</param>
      <param name="selector">A function that projects the aggregated <see cref="T:System.String" /> of each parse result.</param>
      <returns>A parser that returns the joined results.</returns>
      <requires>parser != null</requires>
      <requires>joiner != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.ToList``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Appends the results of each result sequence from the specified <paramref name="parser" /> into an <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated by the parser.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be aggregated.</param>
      <returns>A parser that returns the results aggregated into an <see cref="T:System.Collections.Generic.IList`1" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IList&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.NonGreedy``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Converts greedy matches from the specified <paramref name="parser" /> into matches that 
            have a length of zero.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The greedy parser to be made into a non-greedy parser.</param>
      <returns>A parser that converts the greedy matches from the specified <paramref name="parser" /> into 
            matches that have a length of zero.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Ambiguous``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until there are no matches or the 
            source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until there are
            no matches or the source sequence ends.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until there are no matches or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Ambiguous``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32)">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until the specified count is reached
            or the source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until the specified 
            count is reached or the source sequence ends.</param>
      <param name="untilCount">Indicates the maximum number of ambiguous matches to find.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until the specified count is reached or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <requires>untilCount &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Ambiguous``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until the other parser matches or the 
            source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TUntilResult">The type of the elements that are generated by the until parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until the other 
            parser matches or the source sequence ends.</param>
      <param name="untilParser">The parser that ends the ambiguity when it matches.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until the other parser matches or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <requires>untilParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Amplify``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into a singleton observable sequence
            that contains the match's value.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be projected into singleton observable sequences.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> projected into singleton
            observable sequences.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Single``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Matches the single element from the ambiguous result sequence in each match that is yielded by the specified 
            <paramref name="parser" /> and fails for any match in which there is zero or more than one element.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which the single result element is yielded for each match.</param>
      <returns>A parser that matches the single element from the result sequence of each match that is 
            yielded by the specified <paramref name="parser" /> and fails for any match in which there is zero 
            or more than one element.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{System.Reactive.IObservableCursor{``0},System.IObservable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> method 
            for the generated parser.</param>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.String,System.Func{System.Reactive.IObservableCursor{``0},System.IObservable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> method 
            for the generated parser.</param>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{System.Reactive.IObservableCursor{``0},System.IObserver{Rxx.Parsers.IParseResult{``1}},System.IDisposable})">
      <summary>
            Creates a parser with the specified subscriber function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parseSubscribe">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> method 
            for the generated parser as an observable subscription.</param>
      <returns>A parser with the specified subscriber function.</returns>
      <requires>parser != null</requires>
      <requires>parseSubscribe != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.String,System.Func{System.Reactive.IObservableCursor{``0},System.IObserver{Rxx.Parsers.IParseResult{``1}},System.IDisposable})">
      <summary>
            Creates a parser with the specified subscriber function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parseSubscribe">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> method 
            for the generated parser as an observable subscription.</param>
      <returns>A parser with the specified subscriber function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parseSubscribe != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{System.Reactive.IObservableCursor{``0},System.IObserver{Rxx.Parsers.IParseResult{``2}},System.IDisposable})">
      <summary>
            Creates a parser with the specified subscriber function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified subscriber function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parseSubscribe">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> method 
            for the generated parser as an observable subscription.</param>
      <returns>A parser with the specified subscriber function.</returns>
      <requires>parser != null</requires>
      <requires>parseSubscribe != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.String,System.Func{System.Reactive.IObservableCursor{``0},System.IObserver{Rxx.Parsers.IParseResult{``2}},System.IDisposable})">
      <summary>
            Creates a parser with the specified subscriber function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified subscriber function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parseSubscribe">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> method 
            for the generated parser as an observable subscription.</param>
      <returns>A parser with the specified subscriber function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parseSubscribe != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AsString``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Converts matches from the specified <paramref name="parser" /> into strings.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be converted into strings.</param>
      <returns>A parser that yields strings for the matches from the specified <paramref name="parser" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Required``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> if the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> if there are no matches.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Required``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.String)">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> with the specified message if the specified <paramref name="parser" /> 
            does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="errorMessage">A <see cref="T:System.String" /> that describes the failed expectation to be used as the message 
            in the <see cref="T:Rxx.Parsers.ParseException" />.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> with the specified message if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrWhiteSpace(errorMessage)</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Required``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{System.String})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> with a message returned by the specified function if the specified 
            <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="errorMessageFactory">A function that returns a <see cref="T:System.String" /> describing the failed expectation 
            to be used as the message in the <see cref="T:Rxx.Parsers.ParseException" />.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> with a message returned by the specified functions if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>errorMessageFactory != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Required``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{System.Int32,System.Exception})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> returned by the specified function if the specified 
            <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="exceptionFactory">A function that returns the <see cref="T:Rxx.Parsers.ParseException" /> to be thrown describing the 
            failed expectation.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> returned by the specified functions if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>exceptionFactory != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Where``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,System.Boolean})">
      <summary>
            Matches all results from the specified <paramref name="parser" /> for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be filtered by the specified <paramref name="predicate" />.</param>
      <param name="predicate">A function that returns <see langword="true" /> to indicate when a match should be yielded and 
            <see langword="false" /> when a match should be ignored.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> for which 
            the specified <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>parser != null</requires>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.IgnoreBefore``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``2})">
      <summary>
            Matches the left parser followed by the right parser, but only returns the right parser's matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIgnore">The type of the elements that are generated by the left parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated by the right parser.</typeparam>
      <param name="ignoreParser">The parser from which to ignore matches.</param>
      <param name="parser">The parser from which to yield matches.</param>
      <returns>A parser that matches the left parser followed by the right parser, but only returns the 
            right parser's matches.</returns>
      <requires>ignoreParser != null</requires>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.IgnoreTrailing``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser, but only returns the left parser's matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIgnore">The type of the elements that are generated by the right parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated by the left parser.</typeparam>
      <param name="parser">The parser from which to yield matches.</param>
      <param name="ignoreParser">The parser from which to ignore matches.</param>
      <returns>A parser that matches the left parser followed by the right parser, but only returns the 
            left parser's matches.</returns>
      <requires>parser != null</requires>
      <requires>ignoreParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Of``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``1)">
      <summary>
            Matches all results from the specified <paramref name="parser" /> that equal the specified
            <paramref name="value" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches equivalent to the specified <paramref name="value" /> will be yielded.</param>
      <param name="value">The value to be compared to matches for equality.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> that equal
            the specified <paramref name="value" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Of``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``1,System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Matches all results from the specified <paramref name="parser" /> that equal the specified
            <paramref name="value" /> using the specified <paramref name="comparer" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches equivalent to the specified <paramref name="value" /> will be yielded.</param>
      <param name="value">The value to be compared to matches for equality.</param>
      <param name="comparer">The object that compares matches to the specified <paramref name="value" /> for equality.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> that equal
            the specified <paramref name="value" /> using the specified <paramref name="comparer" />.</returns>
      <requires>parser != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Group``4(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``3},Rxx.Parsers.Reactive.IObservableParser{``0,``2})">
      <summary>
            Matches the <paramref name="content" /> between the specified <paramref name="open" /> and <paramref name="close" /> parsers.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TOpen">The type of the elements that are generated from parsing the <paramref name="open" /> elements.</typeparam>
      <typeparam name="TClose">The type of the elements that are generated from parsing the <paramref name="close" /> elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the <paramref name="content" /> elements.</typeparam>
      <param name="open">The parser after which the matching of <paramref name="content" /> begins.</param>
      <param name="content">The parser that matches values between the <paramref name="open" /> and <paramref name="close" /> parsers.</param>
      <param name="close">The parser at which the matching of <paramref name="content" /> ends.</param>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by the <paramref name="content" /> parser
            and finally the <paramref name="close" /> parser, yielding the results of the <paramref name="content" /> parser only.</returns>
      <requires>open != null</requires>
      <requires>content != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Group``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``2})">
      <summary>
            Matches zero or more values in between the specified <paramref name="open" /> and <paramref name="close" /> parsers.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TOpen">The type of the elements that are generated from parsing the <paramref name="open" /> elements.</typeparam>
      <typeparam name="TClose">The type of the elements that are generated from parsing the <paramref name="close" /> elements.</typeparam>
      <param name="open">The parser after which the group begins.</param>
      <param name="close">The parser at which the group ends.</param>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by everything up to the first 
            match of the <paramref name="close" /> parser, yielding the results in between.</returns>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AmbiguousGroup``1(Rxx.Parsers.Reactive.IObservableParser{``0,``0},Rxx.Parsers.Reactive.IObservableParser{``0,``0})">
      <summary>
            Matches everything in between the specified <paramref name="open" /> and <paramref name="close" /> parsers, 
            yielding the first unambiguous match as well as everything in between any sub-groups and overlapping groups, 
            extending past the unambiguous match of the <paramref name="close" /> parser, that match the same grammar.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <param name="open">The parser after which the group begins.</param>
      <param name="close">The parser at which the group ends.</param>
      <remarks>
            The same <paramref name="open" /> or <paramref name="close" /> parser may produce multiple matches at the same index.
            </remarks>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by everything up to the first 
            match of the <paramref name="close" /> parser, yielding the results in between as well as the results of all ambiguous 
            matches of the group grammar.</returns>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Not``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> when the specified <paramref name="notParser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TNotResult">The type of the elements that are generated by the <paramref name="notParser" />.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match when the specified <paramref name="notParser" /> does not match.</param>
      <param name="notParser">The parser that when it matches will cause the matches from the specified 
            <paramref name="parser" /> to be ignored.</param>
      <returns>A parser that matches the specified <paramref name="parser" /> when the specified <paramref name="notParser" />
            does not match.</returns>
      <requires>parser != null</requires>
      <requires>notParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Or``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches either the left parser or the right parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that has precedence.</param>
      <param name="nextParser">The parser that is matched if the first <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields the matches from <paramref name="parser" /> if there are any; otherwise, the matches 
            from <paramref name="nextParser" /> are yielded.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Any``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{``0,``1}})">
      <summary>
            Matches the first parser that is successful.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched until one is successful.</param>
      <returns>A parser that yields the matches from the first parser in <paramref name="parsers" /> that is successful.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Any``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1}[])">
      <summary>
            Matches the first parser that is successful.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched until one is successful.</param>
      <returns>A parser that yields the matches from the first parser in <paramref name="parsers" /> that is successful.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.And``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.And``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.And``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.And``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AndUnordered``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the left parser and the right parser in any order and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">A parser to be matched, before or after the other parser.</param>
      <param name="otherParser">The other parser to be matched, before or after the first parser.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser and the second parser in any order, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>otherParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AndUnordered``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the left parser and the right parser in any order and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">A parser to be matched, before or after the other parser.</param>
      <param name="otherParser">The other parser to be matched, before or after the first parser.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser and the second parser in any order, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>otherParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AndUnordered``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Matches the left parser and the right parser in any order and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">A parser to be matched, before or after the other parser.</param>
      <param name="otherParser">The other parser to be matched, before or after the first parser.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser and the second parser in any order, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>otherParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AndUnordered``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Matches the left parser and the right parser in any order and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">A parser to be matched, before or after the other parser.</param>
      <param name="otherParser">The other parser to be matched, before or after the first parser.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser and the second parser in any order, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>otherParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.All``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{``0,``1}})">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.All``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1}[])">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.All``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}}})">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.All``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}}[])">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AllUnordered``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{``0,``1}})">
      <summary>
            Matches all <paramref name="parsers" /> in any order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" /> in any order, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AllUnordered``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1}[])">
      <summary>
            Matches all <paramref name="parsers" /> in any order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" /> in any order, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AllUnordered``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}}})">
      <summary>
            Matches all <paramref name="parsers" /> in any order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" /> in any order, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AllUnordered``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}}[])">
      <summary>
            Matches all <paramref name="parsers" /> in any order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" /> in any order, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.WithDefault``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``1)">
      <summary>
            Matches the specified <paramref name="parser" /> or yields the specified default result if there are 
            no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <param name="defaultResult">The value that is yielded if the specified <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> or the specified default result
            if the <paramref name="parser" /> does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.None``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Yields success when the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which any match results in failure.</param>
      <returns>A parser that yields failure when the specified <paramref name="parser" /> matches or 
            an empty sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.None``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``2)">
      <summary>
            Yields success when the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TSuccess">The type of the success value.</typeparam>
      <param name="parser">The parser for which any match results in failure.</param>
      <param name="successResult">The value that is yielded if the specified <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields failure when the specified <paramref name="parser" /> matches or success when 
            it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TSuccess&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Maybe``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> or yields success without a value when it does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> or
            an empty observable sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Maybe``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Matches the specified <paramref name="parser" /> or yields success without a value when it does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> or
            an empty observable sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Exactly``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> the specified number of times.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched.</param>
      <param name="count">The specified number of times to match the specified <paramref name="parser" />.</param>
      <returns>A parser that matches the specified <paramref name="parser" /> the specified number of times.</returns>
      <requires>parser != null</requires>
      <requires>count &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.NoneOrMore``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.NoneOrMoreNonGreedy``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively, making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.NoneOrMore``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively, 
            making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.NoneOrMore``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TSeparator">The type of the separator elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.NoneOrMoreNonGreedy``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively, matching the specified 
            <paramref name="separator" /> in between and making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.NoneOrMore``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},Rxx.Parsers.Reactive.IObservableParser{``0,``1})" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively, 
            matching the specified <paramref name="separator" /> in between and making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OneOrMore``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OneOrMoreNonGreedy``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively, making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OneOrMore``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively, 
            making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OneOrMore``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TSeparator">The type of the separator elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OneOrMoreNonGreedy``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively, matching the specified 
            <paramref name="separator" /> in between and making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OneOrMore``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},Rxx.Parsers.Reactive.IObservableParser{``0,``1})" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively, 
            matching the specified <paramref name="separator" /> in between and making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AtLeast``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively a minimum number of times.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively a minimum number of times.</param>
      <param name="count">The minimum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> the minimum 
            number of times specified by <paramref name="count" />.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AtLeast``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32,System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively between the specified number of times, inclusive.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively between the specified number of times.</param>
      <param name="count">The minimum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <param name="maximum">The maximum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> between the specified number of 
            times, inclusive.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <requires>maximum &gt;= count</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AtLeastNonGreedy``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively a minimum number of times, making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AtLeast``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32)" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively a minimum number of times.</param>
      <param name="count">The minimum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> the minimum 
            number of times specified by <paramref name="count" />, making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AtLeastNonGreedy``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32,System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively between the specified number of times, inclusive, 
            making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AtLeast``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32,System.Int32)" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively a minimum number of times.</param>
      <param name="count">The minimum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <param name="maximum">The maximum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> between the specified number of 
            times, inclusive, making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <requires>maximum &gt;= count</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Select``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,``2})">
      <summary>
            Projects matches from the specified <paramref name="parser" /> into a new form.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the specified <paramref name="parser" />.</typeparam>
      <param name="parser">The parser from which matches will be projected by the specified <paramref name="selector" /> function.</param>
      <param name="selector">A transform function to apply to each match.</param>
      <returns>A parser that projects matches from the specified <paramref name="parser" /> into a new form.</returns>
      <requires>parser != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectMany``4(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,Rxx.Parsers.Reactive.IObservableParser{``0,``2}},System.Func{``1,``2,``3})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into another parser, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TSecondResult">The type of the elements that are generated from the projected parsers.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the projected parsers.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified parser selector function to create 
            the next parser.</param>
      <param name="parserSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each match from the projected parsers.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into another parser, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>parserSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectMany``4(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,Rxx.Parsers.Reactive.IObservableParser{``0,``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},Rxx.Parsers.IParseResult{``2},System.Int32})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into another parser, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TSecondResult">The type of the elements that are generated from the projected parsers.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the projected parsers.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified parser selector function to create 
            the next parser.</param>
      <param name="parserSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each match from the projected parsers.</param>
      <param name="lengthSelector">A function that returns the length for each pair of projected matches.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into another parser, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>parserSelector != null</requires>
      <requires>resultSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectMany``4(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,System.IObservable{``2}},System.Func{``1,``2,``3})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into an observable sequence, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TCollection">The type of the elements in the sequences that are projected from the matches.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the projected sequences.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified collection selector function.</param>
      <param name="collectionSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each element from the projected sequences.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into an observable sequence, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>collectionSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectMany``4(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,System.IObservable{``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},``2,System.Int32})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into an observable sequence, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TCollection">The type of the elements in the sequences that are projected from the matches.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the projected sequences.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified collection selector function.</param>
      <param name="collectionSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each element from the projected sequences.</param>
      <param name="lengthSelector">A function that returns the length for each pair of projected values.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into an observable sequence, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>collectionSelector != null</requires>
      <requires>resultSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OnSuccess``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Action{Rxx.Parsers.IParseResult{``1}})">
      <summary>
            Invokes the specified <paramref name="action" /> on each result for its side-effects.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which results will be supplied to the specified <paramref name="action" />.</param>
      <param name="action">The method that will be called for each parser result.</param>
      <returns>A new parser that is the same as the specified parser and also inovkes the specified 
            <paramref name="action" /> with each result for its side-effects.</returns>
      <requires>parser != null</requires>
      <requires>action != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OnFailure``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Action)">
      <summary>
            Invokes the specified <paramref name="action" /> for its side-effects if the specified <paramref name="parser" />
            does not yield any results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which no results will cause the specified <paramref name="action" /> to be invoked.</param>
      <param name="action">Invoked if the <paramref name="parser" /> does not yield any results.</param>
      <returns>A new parser that is the same as the specified parser and also inovkes the specified 
            <paramref name="action" /> for its side-effects if the specified <paramref name="parser" /> does not yield
            any results.</returns>
      <requires>parser != null</requires>
      <requires>action != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Defer``2(System.Func{Rxx.Parsers.Reactive.IObservableParser{``0,``1}})">
      <summary>
            Defers creation of a parser until the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> method is called.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parserFactory">A function that returns the underlying <see cref="T:Rxx.Parsers.Reactive.IObservableParser`2" /> on which 
            the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> method will be called.</param>
      <returns>A parser that defers creation of its underlying parser until the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> 
            method is called.</returns>
      <requires>parserFactory != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``2)">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding the specified scalar <paramref name="result" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the <paramref name="result" />.</typeparam>
      <param name="parser">The parser for which the specified <paramref name="result" /> indicates success.</param>
      <param name="result">The value of the created parser's result.</param>
      <returns>A parser that always returns the specified scalar <paramref name="result" /> with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``2,System.Int32)">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding the specified scalar <paramref name="result" /> 
            with the specified length.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the <paramref name="result" />.</typeparam>
      <param name="parser">The parser for which the specified <paramref name="result" /> indicates success.</param>
      <param name="result">The value of the created parser's result.</param>
      <param name="length">The length of the created parser's result.</param>
      <returns>A parser that always returns the specified scalar <paramref name="result" /> with the specified 
            length, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding a single result containing an empty sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which a single empty result sequence is returned to indicate success.</param>
      <returns>A parser that returns a single result containing an empty sequence with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding a single result containing an empty sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements in the sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which a single empty result sequence is returned to indicate success.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})" /> is required as an explicit overload
            because the meaning of the parser's result sequence is special and must not be compounded into a sequence of sequences, 
            which would happen if the <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})" /> overload were to be called
            instead.
            </remarks>
      <returns>A parser that returns a single result containing an empty sequence with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Failure``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Indicates a failure to parse without actually parsing by returning an empty sequence of parse results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that is to fail.</param>
      <returns>A parser that always returns an empty sequence of parse results, starting from the index at which 
            the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Parse``2(System.Func{Rxx.Parsers.Reactive.IObservableParser{``0,``0},Rxx.Parsers.Reactive.IObservableParser{``0,``1}})">
      <summary>
            Creates a parser from the specified <paramref name="grammar" /> function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="grammar">A function the accepts a parser that acts as a cursor and returns a parser that matches 
            in terms of the cursor.</param>
      <returns>A parser that yields matches from the specified <paramref name="grammar" />.</returns>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Parse``2(System.IObservable{``0},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Applies the specified <paramref name="parser" /> to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The observable sequence to parse.</param>
      <param name="parser">An object that defines a grammar to be applied to the observable sequence to generate matches.</param>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Parse``2(System.IObservable{``0},System.Func{Rxx.Parsers.Reactive.ObservableParserQueryContext{``0,``0,Rxx.Parsers.Reactive.IObservableParser{``0,``0}},Rxx.Parsers.Reactive.ObservableParserQueryContext{``0,``0,Rxx.Parsers.Reactive.IObservableParser{``0,``1}}})">
      <summary>
            Applies the specified unambiguous parser grammar to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The observable sequence to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.Parse(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor
            	let letter = next.Where(char.IsLetter)
            	let number = next.Where(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Parse``2(System.IObservable{``0},System.Func{Rxx.Parsers.Reactive.ObservableParserQueryContext{``0,``0,Rxx.Parsers.Reactive.IObservableParser{``0,``0}},Rxx.Parsers.Reactive.ObservableParserQueryContext{``0,``0,Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}}}})">
      <summary>
            Applies the specified ambiguous parser grammar to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The observable sequence to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.Parse(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor
            	let letter = next.Where(char.IsLetter)
            	let number = next.Where(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.ParseString``1(System.IObservable{System.Char},System.Func{Rxx.Parsers.Reactive.StringObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Char}},Rxx.Parsers.Reactive.StringObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,``0}}})">
      <summary>
            Applies the specified unambiguous parser grammar to generate matches from a sequence of characters.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source characters.</typeparam>
      <param name="source">The observable sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseString(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let letter = parser.Character(char.IsLetter)
            	let number = parser.Character(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.ParseString``1(System.IObservable{System.Char},System.Func{Rxx.Parsers.Reactive.StringObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Char}},Rxx.Parsers.Reactive.StringObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{``0}}}})">
      <summary>
            Applies the specified ambiguous parser grammar to generate matches from a sequence of characters.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source characters.</typeparam>
      <param name="source">The sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseString(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let letter = parser.Character(char.IsLetter)
            	let number = parser.Character(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.ParseXml``1(System.IObservable{System.Char},System.Func{Rxx.Parsers.Reactive.XmlObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Char}},Rxx.Parsers.Reactive.XmlObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,``0}}})">
      <summary>
            Applies the specified unambiguous XML parser grammar to generate matches.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source XML nodes.</typeparam>
      <param name="source">The sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseXml(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let widget = parser.Element("widget")
            	// define the grammar in terms of the rules
            	select parser.Element("products", widget.OneOrMore()))]]></code></example>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.ParseXml``1(System.IObservable{System.Char},System.Func{Rxx.Parsers.Reactive.XmlObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Char}},Rxx.Parsers.Reactive.XmlObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{``0}}}})">
      <summary>
            Applies the specified ambiguous XML parser grammar to generate matches.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source XML nodes.</typeparam>
      <param name="source">The sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseXml(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let widget = parser.Element("widget")
            	// define the grammar in terms of the rules
            	select parser.Element("products", widget.OneOrMore()))]]></code></example>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Select``4(Rxx.Parsers.Reactive.ObservableParserQueryContext{``0,``1,``2},System.Func{``2,``3})">
      <summary>
            Enables defining in-line parser grammars using LINQ.
            </summary>
      <typeparam name="TParseSource">The type of the original source elements.</typeparam>
      <typeparam name="TParseResult">The type of the elements that are originally generated from parsing the source elements.</typeparam>
      <typeparam name="TSource">The type of the source elements; typically, this will be an anonymous compiler-generaed type.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The parser query context to be projected.</param>
      <param name="selector">A function that projects the current result of the query context.</param>
      <returns>A new query context that is the projection of the specified query context using the specified <paramref name="selector" />.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ObservableParserQueryContext&lt;TParseSource, TParseResult, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Select``3(Rxx.Parsers.Reactive.StringObservableParserQueryContext{``0,``1},System.Func{``1,``2})">
      <summary>
            Enables defining in-line parser grammars using LINQ.
            </summary>
      <typeparam name="TParseResult">The type of the elements that are originally generated from parsing the source elements.</typeparam>
      <typeparam name="TSource">The type of the source elements; typically, this will be an anonymous compiler-generaed type.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The parser query context to be projected.</param>
      <param name="selector">A function that projects the current result of the query context.</param>
      <returns>A new query context that is the projection of the specified query context using the specified <paramref name="selector" />.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;StringObservableParserQueryContext&lt;TParseResult, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Select``3(Rxx.Parsers.Reactive.XmlObservableParserQueryContext{``0,``1},System.Func{``1,``2})">
      <summary>
            Enables defining in-line parser grammars using LINQ.
            </summary>
      <typeparam name="TParseResult">The type of the elements that are originally generated from parsing the source elements.</typeparam>
      <typeparam name="TSource">The type of the source elements; typically, this will be an anonymous compiler-generaed type.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The parser query context to be projected.</param>
      <param name="selector">A function that projects the current result of the query context.</param>
      <returns>A new query context that is the projection of the specified query context using the specified <paramref name="selector" />.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;XmlObservableParserQueryContext&lt;TParseResult, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.ObservableParseResult">
      <summary>
            Provides <see langword="static" /> methods for creating <see cref="T:Rxx.Parsers.ParseResult`1" /> objects.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.Return``1(``0,System.Int32)">
      <summary>
            Creates a singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" />  
            with the specified <paramref name="value" /> and <paramref name="length" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="value">The projection of elements of a parse operation.</param>
      <param name="length">The number of elements that were consumed in the sequence to generate 
            the specified <paramref name="value" />.</param>
      <returns>A singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" />  
            with the specified <paramref name="value" /> and <paramref name="length" />.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.SuccessMany``1(System.Int32)">
      <summary>
            Creates a new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified 
            <paramref name="length" /> and an empty sequence for the value.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified 
            <paramref name="length" /> and an empty sequence for the value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IObservable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.ReturnSuccess``1(System.Int32)">
      <summary>
            Creates a singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> with 
            the specified <paramref name="length" /> and the default value for the specified 
            <typeparamref name="TValue" /> type.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> with 
            the specified <paramref name="length" /> and a default value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.ReturnSuccessMany``1(System.Int32)">
      <summary>
            Creates a singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> 
            with the specified <paramref name="length" /> and an empty sequence for the value.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> 
            with the specified <paramref name="length" /> and an empty sequence for the value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;IObservable&lt;TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.ReturnFailure``1">
      <summary>
            Creates an empty observable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <returns>An empty observable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.</returns>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.ReturnFailureMany``1">
      <summary>
            Creates an empty observable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <returns>An empty observable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.</returns>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.YieldMany``1(Rxx.Parsers.IParseResult{``0})">
      <summary>
            Creates a new parse result with the length of the specified <paramref name="result" />
            and a singleton observable sequence containing the value of the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> from which to create a new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the same length and value as the 
            specified <paramref name="result" />, although with the value wrapped in a singleton observable sequence.</returns>
      <requires>result != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IObservable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.YieldMany``1(Rxx.Parsers.IParseResult{``0},System.Int32)">
      <summary>
            Creates a new parse result with the specified <paramref name="length" /> and a singleton observable 
            sequence containing the value of the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> from which to create a new parse result.</param>
      <param name="length">The length of the new result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the same length and value as the 
            specified <paramref name="result" />, although with the value wrapped in a singleton observable sequence.</returns>
      <requires>result != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IObservable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.Concat``1(Rxx.Parsers.IParseResult{System.IObservable{``0}},Rxx.Parsers.IParseResult{``0})">
      <summary>
            Concatenates the specified parse result value sequence and scalar parse result value into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The parse result value sequence to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The scalar parse result value to be concatenated to the value of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' lengths and 
            the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>firstResult.Value != null</requires>
      <requires>secondResult != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.Concat``1(Rxx.Parsers.IParseResult{``0},Rxx.Parsers.IParseResult{System.IObservable{``0}})">
      <summary>
            Concatenates the specified scalar parse result value and parse result value sequence into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The scalar parse result value to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The parse result value sequence to be concatenated to the value of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' 
            lengths and the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>secondResult != null</requires>
      <requires>secondResult.Value != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.Concat``1(Rxx.Parsers.IParseResult{System.IObservable{``0}},Rxx.Parsers.IParseResult{System.IObservable{``0}})">
      <summary>
            Concatenates the specified parse result value sequences into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The parse result value sequence to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The parse result value sequence to be concatenated to the value sequence of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' 
            lengths and the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>firstResult.Value != null</requires>
      <requires>secondResult != null</requires>
      <requires>secondResult.Value != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.ObservableParserStart`2">
      <summary>
            Represents a parser that begins a parse operation at the beginning of the source sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>grammar != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.Reactive.ObservableParserQueryContext`3">
      <summary>
            Represents a parser context over an observable sequence to support in-line grammars.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TQueryValue">The type of the current value in the query context.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.XmlParserQueryContext`2">
      <summary>
            Represents an XML parser context over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />
            to support in-line grammars.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of XML nodes.</typeparam>
      <typeparam name="TQueryValue">The type of the current value in the query context.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Attribute(System.String)">
      <summary>
            Creates a parser that matches a single XML attribute with the specified <paramref name="name" />.
            </summary>
      <param name="name">The name of the attribute to match.</param>
      <returns>A parser that matches a single XML attribute with the specified <paramref name="name" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">!string.IsNullOrWhiteSpace(name)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified attributes and children.
            </summary>
      <param name="content">The parsers that match the element's attributes, child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.
            </summary>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.
            </summary>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parsers that match the element's attributes, child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, having no attributes
            and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, having no attributes 
            and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">An enumerable sequence containing the names of the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.Text">
      <summary>
            Gets a parser with a grammar that matches all characters, including whitespace, up to the start tag of an element.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Text" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.Comment">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;!-- and ending with --&gt;.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Comment" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.CData">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;![CDATA[ and ending with ]]&gt;.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_CData" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.AnyContent">
      <summary>
            Gets a parser with a grammar that matches any <see cref="P:Rxx.Parsers.XmlParserQueryContext`2.Text" />, <see cref="P:Rxx.Parsers.XmlParserQueryContext`2.Comment" /> or <see cref="P:Rxx.Parsers.XmlParserQueryContext`2.CData" /> content.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyContent" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.AnyElement">
      <summary>
            Gets a parser with a grammar that matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyElement" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.AnyAttribute">
      <summary>
            Gets a parser with a grammar that matches an XML attribute.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.AmbiguousParser`2">
      <summary>
            Represents an ambiguous parser that begins a parse operation at the current position of the source sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>parser != null</invariant>
      <invariant>untilCount &gt;= unlimitedCount</invariant>
    </member>
    <member name="T:Rxx.Parsers.Linq.ParserExtensions">
      <summary>
            Provides <see langword="static" /> methods for defining <see cref="T:Rxx.Parsers.IParser`2" /> grammars.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AsString``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Converts matches from the specified <paramref name="parser" /> into strings.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be converted into strings.</param>
      <returns>A parser that yields strings for the matches from the specified <paramref name="parser" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Aggregate``4(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``2},System.Func{``2,``1,``2},System.Func{``2,``3})">
      <summary>
            Applies an <paramref name="accumulator" /> function over each result sequence from the 
            specified <paramref name="parser" /> and yields a sequence of accumulated results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TAccumulate">The type of the accumulation.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulation.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be aggregated.</param>
      <param name="seed">A function that returns the initial value of the accumulation for each parse result.</param>
      <param name="accumulator">A function to be invoked on each element of each parse result.</param>
      <param name="selector">A function that projects the final aggregation of each parse result.</param>
      <returns>A parser that returns the aggregated results.</returns>
      <requires>parser != null</requires>
      <requires>accumulator != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Join``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Appends each element in each result sequence from the specified <paramref name="parser" /> 
            to an accumulated <see cref="T:System.String" />, yielding a single <see cref="T:System.String" /> per result
            sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined into strings.</param>
      <returns>A parser that returns the aggregated <see cref="T:System.String" /> results.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Join``3(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{System.String,``2})">
      <summary>
            Appends each element in each result from the specified <paramref name="parser" /> 
            to an accumulated <see cref="T:System.String" /> and projects the strings for each result.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulated <see cref="T:System.String" />.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined.</param>
      <param name="selector">A function that projects the aggregated <see cref="T:System.String" /> of each parse result.</param>
      <returns>A parser that returns the joined results.</returns>
      <requires>parser != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Join``4(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``1,``2},System.Func{System.String,``3})">
      <summary>
            Applies a <paramref name="joiner" /> function over each result from the specified 
            <paramref name="parser" /> to create an accumulated <see cref="T:System.String" /> and projects 
            the strings for each result.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TJoin">The type of the accumulation on which <see cref="M:System.Object.ToString" /> is called.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulated <see cref="T:System.String" />.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined.</param>
      <param name="joiner">A function to be invoked on each element of each parse result to produce a value 
            on which <see cref="M:System.Object.ToString" /> is called and appended to the accumulation.</param>
      <param name="selector">A function that projects the aggregated <see cref="T:System.String" /> of each parse result.</param>
      <returns>A parser that returns the joined results.</returns>
      <requires>parser != null</requires>
      <requires>joiner != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.ToList``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Appends the results of each result sequence from the specified <paramref name="parser" /> into an <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated by the parser.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be aggregated.</param>
      <returns>A parser that returns the results aggregated into an <see cref="T:System.Collections.Generic.IList`1" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IList&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.WithDefault``2(Rxx.Parsers.IParser{``0,``1},``1)">
      <summary>
            Matches the specified <paramref name="parser" /> or yields the specified default result if there are 
            no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <param name="defaultResult">The value that is yielded if the specified <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> or the specified default result
            if the <paramref name="parser" /> does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.None``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Yields success when the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which any match results in failure.</param>
      <returns>A parser that yields failure when the specified <paramref name="parser" /> matches or 
            an empty sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.None``3(Rxx.Parsers.IParser{``0,``1},``2)">
      <summary>
            Yields success when the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TSuccess">The type of the success value.</typeparam>
      <param name="parser">The parser for which any match results in failure.</param>
      <param name="successResult">The value that is yielded if the specified <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields failure when the specified <paramref name="parser" /> matches or success when 
            it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TSuccess&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Maybe``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> or yields success without a value when it does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> or 
            an empty enumerable sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Maybe``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Matches the specified <paramref name="parser" /> or yields success without a value when it does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> or 
            an empty enumerable sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Exactly``2(Rxx.Parsers.IParser{``0,``1},System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> the specified number of times.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched.</param>
      <param name="count">The specified number of times to match the specified <paramref name="parser" />.</param>
      <returns>A parser that matches the specified <paramref name="parser" /> the specified number of times.</returns>
      <requires>parser != null</requires>
      <requires>count &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.NoneOrMore``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.NoneOrMoreNonGreedy``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively, making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Linq.ParserExtensions.NoneOrMore``2(Rxx.Parsers.IParser{``0,``1})" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively, 
            making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.NoneOrMore``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.NoneOrMoreNonGreedy``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively, matching the specified 
            <paramref name="separator" /> in between and making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Linq.ParserExtensions.NoneOrMore``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively, 
            matching the specified <paramref name="separator" /> in between and making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.OneOrMore``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.OneOrMoreNonGreedy``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively, making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Linq.ParserExtensions.OneOrMore``2(Rxx.Parsers.IParser{``0,``1})" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively, 
            making the least number of matches possible..</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.OneOrMore``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.OneOrMoreNonGreedy``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively, matching the specified 
            <paramref name="separator" /> in between and making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Linq.ParserExtensions.OneOrMore``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively, 
            matching the specified <paramref name="separator" /> in between and making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AtLeast``2(Rxx.Parsers.IParser{``0,``1},System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively a minimum number of times.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively a minimum number of times.</param>
      <param name="count">The minimum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> the minimum 
            number of times specified by <paramref name="count" />.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AtLeast``2(Rxx.Parsers.IParser{``0,``1},System.Int32,System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively between the specified number of times, inclusive.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively between the specified number of times.</param>
      <param name="count">The minimum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <param name="maximum">The maximum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> between the specified number of 
            times, inclusive.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <requires>maximum &gt;= count</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AtLeastNonGreedy``2(Rxx.Parsers.IParser{``0,``1},System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively a minimum number of times, making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Linq.ParserExtensions.AtLeast``2(Rxx.Parsers.IParser{``0,``1},System.Int32)" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively a minimum number of times.</param>
      <param name="count">The minimum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> the minimum 
            number of times specified by <paramref name="count" />, making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AtLeastNonGreedy``2(Rxx.Parsers.IParser{``0,``1},System.Int32,System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively between the specified number of times, inclusive, 
            making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Linq.ParserExtensions.AtLeast``2(Rxx.Parsers.IParser{``0,``1},System.Int32,System.Int32)" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively a minimum number of times.</param>
      <param name="count">The minimum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <param name="maximum">The maximum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> between the specified number of 
            times, inclusive, making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <requires>maximum &gt;= count</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> method 
            for the generated parser.</param>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.String,System.Func{System.Linq.ICursor{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> method 
            for the generated parser.</param>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> method 
            for the generated parser.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            is merely a convenience extension that works similar to 
            <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            except that it passes the specified <paramref name="parser" /> to the <paramref name="parse" /> function to facilitate writing 
            iterator blocks that must reference the original parser.
            </remarks>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.String,System.Func{System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> method 
            for the generated parser.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            is merely a convenience extension that works similar to 
            <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            except that it passes the specified <paramref name="parser" /> to the <paramref name="parse" /> function to facilitate writing 
            iterator blocks that must reference the original parser.
            </remarks>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``4(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``1},``2,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``3}}},``2)">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function and <paramref name="argument" />, starting at the index 
            of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TArgument">The type of the extra argument that is passed to the <paramref name="parse" /> function.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> method 
            for the generated parser.</param>
      <param name="argument">Extra data to be passed to the <paramref name="parse" /> function.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            is merely a convenience extension that works similar to 
            <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            except that it passes the specified <paramref name="parser" /> to the <paramref name="parse" /> function to facilitate writing 
            iterator blocks that must reference the original parser.
            </remarks>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``4(Rxx.Parsers.IParser{``0,``1},System.String,System.Func{System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``1},``2,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``3}}},``2)">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function and <paramref name="argument" />, starting at the index 
            of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TArgument">The type of the extra argument that is passed to the <paramref name="parse" /> function.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> method 
            for the generated parser.</param>
      <param name="argument">Extra data to be passed to the <paramref name="parse" /> function.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            is merely a convenience extension that works similar to 
            <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            except that it passes the specified <paramref name="parser" /> to the <paramref name="parse" /> function to facilitate writing 
            iterator blocks that must reference the original parser.
            </remarks>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Required``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> if the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> if there are no matches.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Required``2(Rxx.Parsers.IParser{``0,``1},System.String)">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> with the specified message if the specified <paramref name="parser" /> 
            does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="errorMessage">A <see cref="T:System.String" /> that describes the failed expectation to be used as the message 
            in the <see cref="T:Rxx.Parsers.ParseException" />.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> with the specified message if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrWhiteSpace(errorMessage)</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Required``2(Rxx.Parsers.IParser{``0,``1},System.Func{System.String})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> with a message returned by the specified function if the specified 
            <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="errorMessageFactory">A function that returns a <see cref="T:System.String" /> describing the failed expectation 
            to be used as the message in the <see cref="T:Rxx.Parsers.ParseException" />.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> with a message returned by the specified functions if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>errorMessageFactory != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Required``2(Rxx.Parsers.IParser{``0,``1},System.Func{System.Int32,System.Exception})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> returned by the specified function if the specified 
            <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="exceptionFactory">A function that returns the <see cref="T:Rxx.Parsers.ParseException" /> to be thrown describing the 
            failed expectation.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> returned by the specified functions if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>exceptionFactory != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Where``2(Rxx.Parsers.IParser{``0,``1},System.Func{``1,System.Boolean})">
      <summary>
            Matches all results from the specified <paramref name="parser" /> for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be filtered by the specified <paramref name="predicate" />.</param>
      <param name="predicate">A function that returns <see langword="true" /> to indicate when a match should be yielded and 
            <see langword="false" /> when a match should be ignored.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> for which 
            the specified <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>parser != null</requires>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.IgnoreBefore``3(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``2})">
      <summary>
            Matches the left parser followed by the right parser, but only returns the right parser's matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIgnore">The type of the elements that are generated by the left parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated by the right parser.</typeparam>
      <param name="ignoreParser">The parser from which to ignore matches.</param>
      <param name="parser">The parser from which to yield matches.</param>
      <returns>A parser that matches the left parser followed by the right parser, but only returns the 
            right parser's matches.</returns>
      <requires>ignoreParser != null</requires>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.IgnoreTrailing``3(Rxx.Parsers.IParser{``0,``2},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser, but only returns the left parser's matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIgnore">The type of the elements that are generated by the right parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated by the left parser.</typeparam>
      <param name="parser">The parser from which to yield matches.</param>
      <param name="ignoreParser">The parser from which to ignore matches.</param>
      <returns>A parser that matches the left parser followed by the right parser, but only returns the 
            left parser's matches.</returns>
      <requires>parser != null</requires>
      <requires>ignoreParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Of``2(Rxx.Parsers.IParser{``0,``1},``1)">
      <summary>
            Matches all results from the specified <paramref name="parser" /> that equal the specified
            <paramref name="value" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches equivalent to the specified <paramref name="value" /> will be yielded.</param>
      <param name="value">The value to be compared to matches for equality.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> that equal
            the specified <paramref name="value" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Of``2(Rxx.Parsers.IParser{``0,``1},``1,System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Matches all results from the specified <paramref name="parser" /> that equal the specified
            <paramref name="value" /> using the specified <paramref name="comparer" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches equivalent to the specified <paramref name="value" /> will be yielded.</param>
      <param name="value">The value to be compared to matches for equality.</param>
      <param name="comparer">The object that compares matches to the specified <paramref name="value" /> for equality.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> that equal
            the specified <paramref name="value" /> using the specified <paramref name="comparer" />.</returns>
      <requires>parser != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Group``4(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``3},Rxx.Parsers.IParser{``0,``2})">
      <summary>
            Matches the <paramref name="content" /> between the specified <paramref name="open" /> and <paramref name="close" /> parsers.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TOpen">The type of the elements that are generated from parsing the <paramref name="open" /> elements.</typeparam>
      <typeparam name="TClose">The type of the elements that are generated from parsing the <paramref name="close" /> elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the <paramref name="content" /> elements.</typeparam>
      <param name="open">The parser after which the matching of <paramref name="content" /> begins.</param>
      <param name="content">The parser that matches values between the <paramref name="open" /> and <paramref name="close" /> parsers.</param>
      <param name="close">The parser at which the matching of <paramref name="content" /> ends.</param>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by the <paramref name="content" /> parser
            and finally the <paramref name="close" /> parser, yielding the results of the <paramref name="content" /> parser only.</returns>
      <requires>open != null</requires>
      <requires>content != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Group``3(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``2})">
      <summary>
            Matches zero or more values in between the specified <paramref name="open" /> and <paramref name="close" /> parsers.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TOpen">The type of the elements that are generated from parsing the <paramref name="open" /> elements.</typeparam>
      <typeparam name="TClose">The type of the elements that are generated from parsing the <paramref name="close" /> elements.</typeparam>
      <param name="open">The parser after which the group begins.</param>
      <param name="close">The parser at which the group ends.</param>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by everything up to the first 
            match of the <paramref name="close" /> parser, yielding the results in between.</returns>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AmbiguousGroup``1(Rxx.Parsers.IParser{``0,``0},Rxx.Parsers.IParser{``0,``0})">
      <summary>
            Matches everything in between the specified <paramref name="open" /> and <paramref name="close" /> parsers, 
            yielding the first unambiguous match as well as everything in between any sub-groups and overlapping groups, 
            extending past the unambiguous match of the <paramref name="close" /> parser, that match the same grammar.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <param name="open">The parser after which the group begins.</param>
      <param name="close">The parser at which the group ends.</param>
      <remarks>
            The same <paramref name="open" /> or <paramref name="close" /> parser may produce multiple matches at the same index.
            </remarks>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by everything up to the first 
            match of the <paramref name="close" /> parser, yielding the results in between as well as the results of all ambiguous 
            matches of the group grammar.</returns>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Not``3(Rxx.Parsers.IParser{``0,``2},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> when the specified <paramref name="notParser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TNotResult">The type of the elements that are generated by the <paramref name="notParser" />.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match when the specified <paramref name="notParser" /> does not match.</param>
      <param name="notParser">The parser that when it matches will cause the matches from the specified 
            <paramref name="parser" /> to be ignored.</param>
      <returns>A parser that matches the specified <paramref name="parser" /> when the specified <paramref name="notParser" />
            does not match.</returns>
      <requires>parser != null</requires>
      <requires>notParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Or``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches either the left parser or the right parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that has precedence.</param>
      <param name="nextParser">The parser that is matched if the first <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields the matches from <paramref name="parser" /> if there are any; otherwise, the matches 
            from <paramref name="nextParser" /> are yielded.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Any``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{``0,``1}})">
      <summary>
            Matches the first parser that is successful.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched until one is successful.</param>
      <returns>A parser that yields the matches from the first parser in <paramref name="parsers" /> that is successful.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Any``2(Rxx.Parsers.IParser{``0,``1}[])">
      <summary>
            Matches the first parser that is successful.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched until one is successful.</param>
      <returns>A parser that yields the matches from the first parser in <paramref name="parsers" /> that is successful.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.And``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.And``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.And``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.And``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AndUnordered``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the left parser and the right parser in any order and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">A parser to be matched, before or after the other parser.</param>
      <param name="otherParser">The other parser to be matched, before or after the first parser.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser and the second parser in any order, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>otherParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AndUnordered``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the left parser and the right parser in any order and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">A parser to be matched, before or after the other parser.</param>
      <param name="otherParser">The other parser to be matched, before or after the first parser.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser and the second parser in any order, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>otherParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AndUnordered``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Matches the left parser and the right parser in any order and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">A parser to be matched, before or after the other parser.</param>
      <param name="otherParser">The other parser to be matched, before or after the first parser.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser and the second parser in any order, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>otherParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AndUnordered``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Matches the left parser and the right parser in any order and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">A parser to be matched, before or after the other parser.</param>
      <param name="otherParser">The other parser to be matched, before or after the first parser.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser and the second parser in any order, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>otherParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.All``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{``0,``1}})">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.All``2(Rxx.Parsers.IParser{``0,``1}[])">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.All``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}}})">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.All``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}}[])">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AllUnordered``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{``0,``1}})">
      <summary>
            Matches all <paramref name="parsers" /> in any order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" /> in any order, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AllUnordered``2(Rxx.Parsers.IParser{``0,``1}[])">
      <summary>
            Matches all <paramref name="parsers" /> in any order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" /> in any order, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AllUnordered``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}}})">
      <summary>
            Matches all <paramref name="parsers" /> in any order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" /> in any order, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AllUnordered``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}}[])">
      <summary>
            Matches all <paramref name="parsers" /> in any order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" /> in any order, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Parse``2(System.Func{Rxx.Parsers.IParser{``0,``0},Rxx.Parsers.IParser{``0,``1}})">
      <summary>
            Creates a parser from the specified <paramref name="grammar" /> function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="grammar">A function the accepts a parser that acts as a cursor and returns a parser that matches 
            in terms of the cursor.</param>
      <returns>A parser that yields matches from the specified <paramref name="grammar" />.</returns>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Parse``2(System.Collections.Generic.IEnumerable{``0},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Applies the specified <paramref name="parser" /> to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The enumerable sequence to parse.</param>
      <param name="parser">An object that defines a grammar to be applied to the enumerable sequence to generate matches.</param>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Parse``2(System.Collections.Generic.IEnumerable{``0},System.Func{Rxx.Parsers.ParserQueryContext{``0,``0,Rxx.Parsers.IParser{``0,``0}},Rxx.Parsers.ParserQueryContext{``0,``0,Rxx.Parsers.IParser{``0,``1}}})">
      <summary>
            Applies the specified unambiguous parser grammar to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The enumerable sequence to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.Parse(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor
            	let letter = next.Where(char.IsLetter)
            	let number = next.Where(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Parse``2(System.Collections.Generic.IEnumerable{``0},System.Func{Rxx.Parsers.ParserQueryContext{``0,``0,Rxx.Parsers.IParser{``0,``0}},Rxx.Parsers.ParserQueryContext{``0,``0,Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}}}})">
      <summary>
            Applies the specified ambiguous parser grammar to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The enumerable sequence to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.Parse(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor
            	let letter = next.Where(char.IsLetter)
            	let number = next.Where(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.ParseString``1(System.Collections.Generic.IEnumerable{System.Char},System.Func{Rxx.Parsers.StringParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Char}},Rxx.Parsers.StringParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,``0}}})">
      <summary>
            Applies the specified unambiguous <see cref="T:System.String" /> parser grammar to generate matches.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source characters.</typeparam>
      <param name="source">The <see cref="T:System.String" /> or enumerable sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseString(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let letter = parser.Character(char.IsLetter)
            	let number = parser.Character(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.ParseString``1(System.Collections.Generic.IEnumerable{System.Char},System.Func{Rxx.Parsers.StringParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Char}},Rxx.Parsers.StringParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{``0}}}})">
      <summary>
            Applies the specified ambiguous <see cref="T:System.String" /> parser grammar to generate matches.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source characters.</typeparam>
      <param name="source">The <see cref="T:System.String" /> or enumerable sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseString(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let letter = parser.Character(char.IsLetter)
            	let number = parser.Character(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.ParseXml``1(System.Collections.Generic.IEnumerable{System.Char},System.Func{Rxx.Parsers.XmlParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Char}},Rxx.Parsers.XmlParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,``0}}})">
      <summary>
            Applies the specified unambiguous XML parser grammar to generate matches.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source XML nodes.</typeparam>
      <param name="source">The <see cref="T:System.String" /> or enumerable sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseXml(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let widget = parser.Element("widget")
            	// define the grammar in terms of the rules
            	select parser.Element("products", widget.OneOrMore()))]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.ParseXml``1(System.Collections.Generic.IEnumerable{System.Char},System.Func{Rxx.Parsers.XmlParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Char}},Rxx.Parsers.XmlParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{``0}}}})">
      <summary>
            Applies the specified ambiguous XML parser grammar to generate matches.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source XML nodes.</typeparam>
      <param name="source">The <see cref="T:System.String" /> or enumerable sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseXml(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let widget = parser.Element("widget")
            	// define the grammar in terms of the rules
            	select parser.Element("products", widget.OneOrMore()))]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Select``4(Rxx.Parsers.ParserQueryContext{``0,``1,``2},System.Func{``2,``3})">
      <summary>
            Enables defining in-line parser grammars using LINQ.
            </summary>
      <typeparam name="TParseSource">The type of the original source elements.</typeparam>
      <typeparam name="TParseResult">The type of the elements that are originally generated from parsing the source elements.</typeparam>
      <typeparam name="TSource">The type of the source elements; typically, this will be an anonymous compiler-generaed type.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The parser query context to be projected.</param>
      <param name="selector">A function that projects the current result of the query context.</param>
      <returns>A new query context that is the projection of the specified query context using the specified <paramref name="selector" />.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ParserQueryContext&lt;TParseSource, TParseResult, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Select``3(Rxx.Parsers.StringParserQueryContext{``0,``1},System.Func{``1,``2})">
      <summary>
            Enables defining in-line parser grammars using LINQ.
            </summary>
      <typeparam name="TParseResult">The type of the elements that are originally generated from parsing the source elements.</typeparam>
      <typeparam name="TSource">The type of the source elements; typically, this will be an anonymous compiler-generaed type.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The parser query context to be projected.</param>
      <param name="selector">A function that projects the current result of the query context.</param>
      <returns>A new query context that is the projection of the specified query context using the specified <paramref name="selector" />.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;StringParserQueryContext&lt;TParseResult, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Select``3(Rxx.Parsers.XmlParserQueryContext{``0,``1},System.Func{``1,``2})">
      <summary>
            Enables defining in-line parser grammars using LINQ.
            </summary>
      <typeparam name="TParseResult">The type of the elements that are originally generated from parsing the source elements.</typeparam>
      <typeparam name="TSource">The type of the source elements; typically, this will be an anonymous compiler-generaed type.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The parser query context to be projected.</param>
      <param name="selector">A function that projects the current result of the query context.</param>
      <returns>A new query context that is the projection of the specified query context using the specified <paramref name="selector" />.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;XmlParserQueryContext&lt;TParseResult, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.NonGreedy``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Converts greedy matches from the specified <paramref name="parser" /> into matches that 
            have a length of zero.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The greedy parser to be made into a non-greedy parser.</param>
      <returns>A parser that converts the greedy matches from the specified <paramref name="parser" /> into 
            matches that have a length of zero.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Ambiguous``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until there are no matches or the 
            source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until there are
            no matches or the source sequence ends.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until there are no matches or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Ambiguous``2(Rxx.Parsers.IParser{``0,``1},System.Int32)">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until the specified count is reached
            or the source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until the specified 
            count is reached or the source sequence ends.</param>
      <param name="untilCount">Indicates the maximum number of ambiguous matches to find.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until the specified count is reached or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <requires>untilCount &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Ambiguous``3(Rxx.Parsers.IParser{``0,``2},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until the other parser matches or the 
            source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TUntilResult">The type of the elements that are generated by the until parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until the other 
            parser matches or the source sequence ends.</param>
      <param name="untilParser">The parser that ends the ambiguity when it matches.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until the other parser matches or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <requires>untilParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Amplify``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into a singleton enumerable sequence
            that contains the match's value.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be projected into singleton enumerable sequences.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> projected into singleton
            enumerable sequences.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Single``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Matches the single element from the ambiguous result sequence in each match that is yielded by the specified 
            <paramref name="parser" /> and fails for any match in which there is zero or more than one element.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which the single result element is yielded for each match.</param>
      <returns>A parser that matches the single element from the result sequence of each match that is 
            yielded by the specified <paramref name="parser" /> and fails for any match in which there is zero 
            or more than one element.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Select``3(Rxx.Parsers.IParser{``0,``1},System.Func{``1,``2})">
      <summary>
            Projects matches from the specified <paramref name="parser" /> into a new form.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the specified <paramref name="parser" />.</typeparam>
      <param name="parser">The parser from which matches will be projected by the specified <paramref name="selector" /> function.</param>
      <param name="selector">A transform function to apply to each match.</param>
      <returns>A parser that projects matches from the specified <paramref name="parser" /> into a new form.</returns>
      <requires>parser != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.SelectMany``4(Rxx.Parsers.IParser{``0,``1},System.Func{``1,Rxx.Parsers.IParser{``0,``2}},System.Func{``1,``2,``3})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into another parser, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TSecondResult">The type of the elements that are generated from the projected parsers.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the projected parsers.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified parser selector function to create 
            the next parser.</param>
      <param name="parserSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each match from the projected parsers.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into another parser, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>parserSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.SelectMany``4(Rxx.Parsers.IParser{``0,``1},System.Func{``1,Rxx.Parsers.IParser{``0,``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},Rxx.Parsers.IParseResult{``2},System.Int32})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into another parser, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TSecondResult">The type of the elements that are generated from the projected parsers.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the projected parsers.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified parser selector function to create 
            the next parser.</param>
      <param name="parserSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each match from the projected parsers.</param>
      <param name="lengthSelector">A function that returns the length for each pair of projected matches.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into another parser, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>parserSelector != null</requires>
      <requires>resultSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.SelectMany``4(Rxx.Parsers.IParser{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``2}},System.Func{``1,``2,``3})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into an enumerable sequence, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TCollection">The type of the elements in the sequences that are projected from the matches.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the projected sequences.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified collection selector function.</param>
      <param name="collectionSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each element from the projected sequences.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into an enumerable sequence, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>collectionSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.SelectMany``4(Rxx.Parsers.IParser{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},``2,System.Int32})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into an enumerable sequence, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TCollection">The type of the elements in the sequences that are projected from the matches.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the projected sequences.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified collection selector function.</param>
      <param name="collectionSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each element from the projected sequences.</param>
      <param name="lengthSelector">A function that returns the length for each pair of projected values.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into an enumerable sequence, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>collectionSelector != null</requires>
      <requires>resultSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.OnSuccess``2(Rxx.Parsers.IParser{``0,``1},System.Action{Rxx.Parsers.IParseResult{``1}})">
      <summary>
            Invokes the specified <paramref name="action" /> on each result for its side-effects.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which results will be supplied to the specified <paramref name="action" />.</param>
      <param name="action">The method that will be called for each parser result.</param>
      <returns>A new parser that is the same as the specified parser and also inovkes the specified 
            <paramref name="action" /> with each result for its side-effects.</returns>
      <requires>parser != null</requires>
      <requires>action != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.OnFailure``2(Rxx.Parsers.IParser{``0,``1},System.Action)">
      <summary>
            Invokes the specified <paramref name="action" /> for its side-effects if the specified <paramref name="parser" />
            does not yield any results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which no results will cause the specified <paramref name="action" /> to be invoked.</param>
      <param name="action">Invoked if the <paramref name="parser" /> does not yield any results.</param>
      <returns>A new parser that is the same as the specified parser and also inovkes the specified 
            <paramref name="action" /> for its side-effects if the specified <paramref name="parser" /> does not yield
            any results.</returns>
      <requires>parser != null</requires>
      <requires>action != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Defer``2(System.Func{Rxx.Parsers.IParser{``0,``1}})">
      <summary>
            Defers creation of a parser until the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> method is called.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parserFactory">A function that returns the underlying <see cref="T:Rxx.Parsers.IParser`2" /> on which 
            the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> method will be called.</param>
      <returns>A parser that defers creation of its underlying parser until the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> 
            method is called.</returns>
      <requires>parserFactory != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Success``3(Rxx.Parsers.IParser{``0,``1},``2)">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding the specified scalar <paramref name="result" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the <paramref name="result" />.</typeparam>
      <param name="parser">The parser for which the specified <paramref name="result" /> indicates success.</param>
      <param name="result">The value of the created parser's result.</param>
      <returns>A parser that always returns the specified scalar <paramref name="result" /> with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Success``3(Rxx.Parsers.IParser{``0,``1},``2,System.Int32)">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding the specified scalar <paramref name="result" /> 
            with the specified length.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the <paramref name="result" />.</typeparam>
      <param name="parser">The parser for which the specified <paramref name="result" /> indicates success.</param>
      <param name="result">The value of the created parser's result.</param>
      <param name="length">The length of the created parser's result.</param>
      <returns>A parser that always returns the specified scalar <paramref name="result" /> with the specified 
            length, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Success``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding a single result containing an empty sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which a single empty result sequence is returned to indicate success.</param>
      <returns>A parser that returns a single result containing an empty sequence with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Success``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding a single result containing an empty sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements in the sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which a single empty result sequence is returned to indicate success.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Success``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})" /> is required as an explicit overload
            because the meaning of the parser's result sequence is special and must not be compounded into a sequence of sequences, 
            which would happen if the <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Success``2(Rxx.Parsers.IParser{``0,``1})" /> overload were to be called
            instead.
            </remarks>
      <returns>A parser that returns a single result containing an empty sequence with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Failure``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Indicates a failure to parse without actually parsing by returning an empty sequence of parse results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that is to fail.</param>
      <returns>A parser that always returns an empty sequence of parse results, starting from the index at which 
            the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.ParseException">
      <summary>
            Represents errors that occur while parsing a sequence.
            </summary>
      <invariant>sourceIndex &gt;= 0</invariant>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the default <see cref="P:Rxx.Parsers.ParseException.Message" />.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.Int32)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the default <see cref="P:Rxx.Parsers.ParseException.Message" />
            and the specified <see cref="P:Rxx.Parsers.ParseException.SourceIndex" />.
            </summary>
      <param name="sourceIndex">The index in the sequence at which the error occurred while parsing.</param>
      <requires>sourceIndex &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the specified <paramref name="message" />.
            </summary>
      <param name="message">The message that describes the parser error.</param>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.Int32,System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the specified <paramref name="message" />
            and <see cref="P:Rxx.Parsers.ParseException.SourceIndex" />.
            </summary>
      <param name="sourceIndex">The index in the sequence at which the error occurred while parsing.</param>
      <param name="message">The message that describes the parser error.</param>
      <requires>sourceIndex &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.String,System.Exception)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the specified <paramref name="message" />
            and <paramref name="innerException" />.
            </summary>
      <param name="message">The message that describes the parser error.</param>
      <param name="innerException">The exception that is the cause of the current exception, or <see langword="null" /> if no inner exception is specified.</param>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.Int32,System.Exception)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the default <see cref="P:Rxx.Parsers.ParseException.Message" />
            and the specified <see cref="P:Rxx.Parsers.ParseException.SourceIndex" /> and <paramref name="innerException" />.
            </summary>
      <param name="sourceIndex">The index in the sequence at which the error occurred while parsing.</param>
      <param name="innerException">The exception that is the cause of the current exception, or <see langword="null" /> if no inner exception is specified.</param>
      <requires>sourceIndex &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.Int32,System.String,System.Exception)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the specified <paramref name="message" />, 
            <see cref="P:Rxx.Parsers.ParseException.SourceIndex" /> and <paramref name="innerException" />.
            </summary>
      <param name="sourceIndex">The index in the sequence at which the error occurred while parsing.</param>
      <param name="message">The message that describes the parser error.</param>
      <param name="innerException">The exception that is the cause of the current exception, or <see langword="null" /> if no inner exception is specified.</param>
      <requires>sourceIndex &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with serialized data.
            </summary>
      <param name="info">Holds the serialized data about the exception.</param>
      <param name="context">Contains contextual information about the source or destination.</param>
      <requires>info != null</requires>
    </member>
    <member name="M:Rxx.Parsers.ParseException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates serialization <paramref name="info" /> for the current exception instance.
            </summary>
      <param name="info">Holds the serialized data about the exception.</param>
      <param name="context">Contains contextual information about the source or destination.</param>
    </member>
    <member name="P:Rxx.Parsers.ParseException.SourceIndex">
      <summary>
            Gets the index in the sequence at which the error occurred while parsing.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.ParseException.Message">
      <summary>
            Gets a message that describes the parser error.
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Exception.get_Message" inheritedFromTypeName="Exception">Contract.Result&lt;string&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.ParseResult">
      <summary>
            Provides <see langword="static" /> methods for creating <see cref="T:Rxx.Parsers.ParseResult`1" /> objects.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Add``3(Rxx.Parsers.IParseResult{``0},Rxx.Parsers.IParseResult{``1},System.Func{``0,``1,``2})">
      <summary>
            Applies a selector function to two parse results to produce a new parse result.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TFirstResult">The type of the first parse result's value.</typeparam>
      <typeparam name="TSecondResult">The type of the second parse result's value.</typeparam>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The parse result to be combined with <paramref name="secondResult" />.</param>
      <param name="secondResult">The parse result to be combined with <paramref name="firstResult" />.</param>
      <param name="resultSelector">A function that selects a new parse result from the two specified parse results.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' 
            lengths and the return value of the <paramref name="resultSelector" /> function.</returns>
      <requires>firstResult != null</requires>
      <requires>!(firstResult is ILookAheadParseResult&lt;TFirstResult&gt;)</requires>
      <requires>secondResult != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Concat``1(Rxx.Parsers.IParseResult{System.Collections.Generic.IEnumerable{``0}},Rxx.Parsers.IParseResult{``0})">
      <summary>
            Concatenates the specified parse result value sequence and scalar parse result value into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The parse result value sequence to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The scalar parse result value to be concatenated to the value of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' lengths and 
            the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>firstResult.Value != null</requires>
      <requires>!(firstResult is ILookAheadParseResult&lt;IEnumerable&lt;TResult&gt;&gt;)</requires>
      <requires>secondResult != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Concat``1(Rxx.Parsers.IParseResult{``0},Rxx.Parsers.IParseResult{System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Concatenates the specified scalar parse result value and parse result value sequence into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The scalar parse result value to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The parse result value sequence to be concatenated to the value of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' 
            lengths and the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>!(firstResult is ILookAheadParseResult&lt;TResult&gt;)</requires>
      <requires>secondResult != null</requires>
      <requires>secondResult.Value != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Concat``1(Rxx.Parsers.IParseResult{System.Collections.Generic.IEnumerable{``0}},Rxx.Parsers.IParseResult{System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Concatenates the specified parse result value sequences into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The parse result value sequence to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The parse result value sequence to be concatenated to the value sequence of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' 
            lengths and the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>firstResult.Value != null</requires>
      <requires>!(firstResult is ILookAheadParseResult&lt;IEnumerable&lt;TResult&gt;&gt;)</requires>
      <requires>secondResult != null</requires>
      <requires>secondResult.Value != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Create``1(``0,System.Int32)">
      <summary>
            Creates a new <see cref="T:Rxx.Parsers.IParseResult`1" /> instance from the specified 
            <paramref name="value" /> and <paramref name="length" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="value">The projection of elements of a parse operation.</param>
      <param name="length">The number of elements that were consumed in the sequence to generate 
            the specified <paramref name="value" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> instance containing the specified 
            <paramref name="value" /> and <paramref name="length" />.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.CreateLookAhead``1(``0,System.Int32)">
      <summary>
            Creates a new <see cref="T:Rxx.Parsers.ILookAheadParseResult`1" /> instance from the specified 
            <paramref name="value" /> and <paramref name="length" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="value">The projection of elements of a parse operation.</param>
      <param name="length">The number of elements that were consumed in the sequence to generate 
            the specified <paramref name="value" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.ILookAheadParseResult`1" /> instance containing the specified 
            <paramref name="value" /> and <paramref name="length" />.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;ILookAheadParseResult&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Return``1(``0,System.Int32)">
      <summary>
            Creates a singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" />  
            with the specified <paramref name="value" /> and <paramref name="length" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="value">The projection of elements of a parse operation.</param>
      <param name="length">The number of elements that were consumed in the sequence to generate 
            the specified <paramref name="value" />.</param>
      <returns>A singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" />  
            with the specified <paramref name="value" /> and <paramref name="length" />.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Success``1(System.Int32)">
      <summary>
            Creates a new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified <paramref name="length" />
            and the default value for the specified <typeparamref name="TValue" /> type.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified 
            <paramref name="length" /> and a default value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.SuccessMany``1(System.Int32)">
      <summary>
            Creates a new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified 
            <paramref name="length" /> and an empty sequence for the value.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified 
            <paramref name="length" /> and an empty sequence for the value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IEnumerable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.ReturnSuccess``1(System.Int32)">
      <summary>
            Creates a singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> with 
            the specified <paramref name="length" /> and the default value for the specified 
            <typeparamref name="TValue" /> type.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> with 
            the specified <paramref name="length" /> and a default value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.ReturnSuccessMany``1(System.Int32)">
      <summary>
            Creates a singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> 
            with the specified <paramref name="length" /> and an empty sequence for the value.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> 
            with the specified <paramref name="length" /> and an empty sequence for the value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;IEnumerable&lt;TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.ReturnFailure``1">
      <summary>
            Creates an empty enumerable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <returns>An empty enumerable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.</returns>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.ReturnFailureMany``1">
      <summary>
            Creates an empty enumerable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <returns>An empty enumerable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.</returns>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``1(Rxx.Parsers.IParseResult{``0})">
      <summary>
            Clones the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> from which to create a new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the same length and value as the 
            specified <paramref name="result" />.</returns>
      <requires>result != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``1(Rxx.Parsers.IParseResult{``0},System.Int32)">
      <summary>
            Creates a new parse result with the specified <paramref name="length" /> 
            and the same value as the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> that provides the length.</param>
      <param name="length">The length of the new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified <paramref name="length" /> 
            and the same value as the specified <paramref name="result" />.</returns>
      <requires>result != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``2(Rxx.Parsers.IParseResult{``0},``1)">
      <summary>
            Creates a new parse result with the specified value and the length of the specified 
            <paramref name="result" />.
            </summary>
      <typeparam name="TOldValue">The type of the old parse result's value.</typeparam>
      <typeparam name="TNewValue">The type of the new parse result's value</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> that provides the length.</param>
      <param name="value">The value of the new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified value and the length of the specified 
            <paramref name="result" />.</returns>
      <requires>result != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TNewValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``2(Rxx.Parsers.IParseResult{``0},System.Func{``0,``1})">
      <summary>
            Creates a new parse result with the value returned by the specified selector and the length of the 
            specified <paramref name="result" />.
            </summary>
      <typeparam name="TOldValue">The type of the old parse result's value.</typeparam>
      <typeparam name="TNewValue">The type of the new parse result's value</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> that provides the length.</param>
      <param name="valueSelector">A function that selects the value for the new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the value returned by the specified selector 
            and the length of the specified <paramref name="result" />.</returns>
      <requires>result != null</requires>
      <requires>valueSelector != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TNewValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``3(Rxx.Parsers.IParseResult{``0},Rxx.Parsers.IParseResult{``1},System.Func{``0,``1,``2},System.Func{Rxx.Parsers.IParseResult{``0},Rxx.Parsers.IParseResult{``1},System.Int32})">
      <summary>
            Creates a new parse result from two parse results with the length and value returned 
            by the specified selectors.
            </summary>
      <typeparam name="TFirstValue">The type of the first parse result's value.</typeparam>
      <typeparam name="TSecondValue">The type of the second parse result's value.</typeparam>
      <typeparam name="TNewValue">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The first parse result.</param>
      <param name="secondResult">The second parse result.</param>
      <param name="valueSelector">A function that selects the value for the new parse result.</param>
      <param name="lengthSelector">A function that selects the length for the new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the length and value returned by the 
            specified selectors.</returns>
      <requires>firstResult != null</requires>
      <requires>!(firstResult is ILookAheadParseResult&lt;TFirstValue&gt;)</requires>
      <requires>secondResult != null</requires>
      <requires>valueSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TNewValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``3(Rxx.Parsers.IParseResult{``0},``1,System.Func{``0,``1,``2},System.Func{Rxx.Parsers.IParseResult{``0},``1,System.Int32})">
      <summary>
            Creates a new parse result from a parse result and another value with the length and value 
            returned by the specified selectors.
            </summary>
      <typeparam name="TOldValue">The type of the old parse result's value.</typeparam>
      <typeparam name="TOther">The type of the other value.</typeparam>
      <typeparam name="TNewValue">The type of the new parse result's value.</typeparam>
      <param name="result">The old parse result from which to create a new parse result.</param>
      <param name="other">The other value from which to create a new parse result.</param>
      <param name="valueSelector">A function that selects the value for the new parse result.</param>
      <param name="lengthSelector">A function that selects the length for the new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the length and value returned by the 
            specified selectors.</returns>
      <requires>result != null</requires>
      <requires>other != null</requires>
      <requires>valueSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TNewValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.YieldMany``1(Rxx.Parsers.IParseResult{``0})">
      <summary>
            Creates a new parse result with the length of the specified <paramref name="result" />
            and a singleton enumerable sequence containing the value of the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> from which to create a new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the same length and value as the 
            specified <paramref name="result" />, although with the value wrapped in a singleton enumerable sequence.</returns>
      <requires>result != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IEnumerable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.YieldMany``1(Rxx.Parsers.IParseResult{``0},System.Int32)">
      <summary>
            Creates a new parse result with the specified <paramref name="length" /> and a singleton enumerable 
            sequence containing the value of the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> from which to create a new parse result.</param>
      <param name="length">The length of the new result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the same length and value as the 
            specified <paramref name="result" />, although with the value wrapped in a singleton enumerable sequence.</returns>
      <requires>result != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IEnumerable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.ParserQueryContext`3">
      <summary>
            Represents a parser context over an enumerable sequence to support in-line grammars.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TQueryValue">The type of the current value in the query context.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.ParserStart`2">
      <summary>
            Represents a parser that begins a parse operation at the beginning of the source sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>grammar != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.ParserTraceSources">
      <summary>
            Provides <see cref="T:System.Diagnostics.TraceSource" /> objects that are used by <see cref="T:Rxx.Parsers.Parser`2" />.
            </summary>
    </member>
    <member name="F:Rxx.Parsers.ParserTraceSources.Compilation">
      <summary>
            A <see cref="T:System.Diagnostics.TraceSource" /> used by <see cref="T:Rxx.Parsers.Parser`2" /> to trace diagnostic information 
            when compiling grammars at runtime.
            </summary>
    </member>
    <member name="F:Rxx.Parsers.ParserTraceSources.Execution">
      <summary>
            A <see cref="T:System.Diagnostics.TraceSource" /> used by <see cref="T:Rxx.Parsers.Parser`2" /> to trace diagnostic information 
            when executing parse operations.
            </summary>
    </member>
    <member name="F:Rxx.Parsers.ParserTraceSources.Input">
      <summary>
            A <see cref="T:System.Diagnostics.TraceSource" /> used by <see cref="T:Rxx.Parsers.Parser`2" /> to trace the input data as it's
            being evaluated by parsers.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.ParserTraceSources.SetLevels(System.Nullable{System.Diagnostics.SourceLevels},System.Nullable{System.Diagnostics.SourceLevels},System.Nullable{System.Diagnostics.SourceLevels})">
      <summary>
            Sets the trace levels for any of the <see cref="T:System.Diagnostics.TraceSource" /> objects that are used by 
            <see cref="T:Rxx.Parsers.Parser`2" /> and returns an <see cref="T:System.IDisposable" /> that, when disposed, 
            resets the trace levels of the modified sources to their values before <see cref="M:Rxx.Parsers.ParserTraceSources.SetLevels(System.Nullable{System.Diagnostics.SourceLevels},System.Nullable{System.Diagnostics.SourceLevels},System.Nullable{System.Diagnostics.SourceLevels})" /> was 
            called.
            </summary>
      <param name="compilation">Sets the trace level for the <see cref="F:Rxx.Parsers.ParserTraceSources.Compilation" /> source.</param>
      <param name="execution">Sets the trace level for the <see cref="F:Rxx.Parsers.ParserTraceSources.Execution" /> source.</param>
      <param name="input">Sets the trace level for the <see cref="F:Rxx.Parsers.ParserTraceSources.Input" /> source.</param>
      <returns>An <see cref="T:System.IDisposable" /> that, when disposed, resets the trace levels of the modified 
            sources to their values before <see cref="M:Rxx.Parsers.ParserTraceSources.SetLevels(System.Nullable{System.Diagnostics.SourceLevels},System.Nullable{System.Diagnostics.SourceLevels},System.Nullable{System.Diagnostics.SourceLevels})" /> was called.</returns>
    </member>
    <member name="M:Rxx.Parsers.ParserTraceSources.AddListener(System.Diagnostics.TraceListener)">
      <summary>
            Adds the specified <paramref name="listener" /> to <see cref="P:Rxx.Parsers.ParserTraceSources.All" /> parser trace sources.
            </summary>
      <param name="listener">The <see cref="T:System.Diagnostics.TraceListener" /> to be added.</param>
      <requires>listener != null</requires>
    </member>
    <member name="M:Rxx.Parsers.ParserTraceSources.RemoveListeners(System.Diagnostics.TraceListener)">
      <summary>
            Removes the specified <paramref name="listener" /> from <see cref="P:Rxx.Parsers.ParserTraceSources.All" /> parser trace sources.
            </summary>
      <param name="listener">The <see cref="T:System.Diagnostics.TraceListener" /> to be removed.</param>
      <requires>listener != null</requires>
    </member>
    <member name="M:Rxx.Parsers.ParserTraceSources.ClearListeners">
      <summary>
            Clears the <see cref="T:System.Diagnostics.TraceListener" /> collections of <see cref="P:Rxx.Parsers.ParserTraceSources.All" /> parser trace sources.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.ParserTraceSources.TraceQueryCompilation(System.String)">
      <summary>
            Traces the start of a query compilation and provides an <see cref="T:System.IDisposable" /> that traces the 
            end when it's disposed.
            </summary>
      <param name="name">Optional name of the parser to be traced.</param>
      <remarks>
        <alert type="warning">
            Compiling a query often depends upon the next value in the source sequence, 
            which means that if the cursor is at the head of the source sequence then calling 
            MoveNext may block the compilation until the next value is available.  This could
            lead to misleading profiling ouput; it may appears as though query compilation is 
            taking a long time for source sequences that are cold, when in fact the compilation
            time includes the time it takes to generate one or more values in the source sequence.
            </alert>
      </remarks>
      <returns>An <see cref="T:System.IDisposable" /> that, when disposed, traces the end of a query compilation.</returns>
      <requires>name == null || name.Length &gt; 0</requires>
    </member>
    <member name="P:Rxx.Parsers.ParserTraceSources.All">
      <summary>
            Gets a collection of all <see cref="T:System.Diagnostics.TraceSource" /> objects that are used by <see cref="T:Rxx.Parsers.Parser`2" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;ICollection&lt;TraceSource&gt;&gt;() != null</ensures>
        <ensures>Contract.Result&lt;ICollection&lt;TraceSource&gt;&gt;().Count &gt; 0</ensures>
        <ensures>Contract.Result&lt;ICollection&lt;TraceSource&gt;&gt;().IsReadOnly</ensures>
        <ensures>Contract.ForAll(Contract.Result&lt;ICollection&lt;TraceSource&gt;&gt;(), source =&gt; source != null)</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.StringParserDefaults">
      <summary>
            Provides default values for <see cref="T:Rxx.Parsers.StringParser`1" />.
            </summary>
    </member>
    <member name="F:Rxx.Parsers.StringParserDefaults.InsignificantWhiteSpaceCharacters">
      <summary>
            The default collection of whitespace characters returned by <see cref="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpaceCharacters" />.
            The collection contains a space, tab, new-line, and carriage return.
            </summary>
    </member>
    <member name="T:Rxx.Parsers.StringParserQueryContext`2">
      <summary>
            Represents a parser context over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />
            to support in-line grammars.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
      <typeparam name="TQueryValue">The type of the current value in the query context.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Char)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParserQueryContext`2.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_AnyCharacter" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.StringParserQueryContext`2.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_WhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.StringParserQueryContext`2.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive insignificant whitespace characters and joins
            them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserTraceExecutionContext`1.#ctor(System.String,Rxx.Parsers.IParserCursor{`0})">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParserTraceExecutionContext`1" /> class.
            </summary>
      <param name="name">Name of the parser to be traced.</param>
      <param name="cursor">The parser's cursor.</param>
      <requires>name == null || name.Length &gt; 0</requires>
      <requires>cursor != null</requires>
    </member>
    <member name="T:Rxx.Properties.Errors">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.CannotDetermineRoutedEventArgsType">
      <summary>
              Looks up a localized string similar to The argument type for the specified RoutedEvent cannot be determined from the type of its delegate..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.CannotResetCursorBranch">
      <summary>
              Looks up a localized string similar to Individual cursor branches cannot be reset.  To reset the entire cursor, call Reset on the primary cursor object instead..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.DependencyPropertyNotFound">
      <summary>
              Looks up a localized string similar to The specified DependencyProperty was not found on the specified DependencyObject..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.EventIsNotCompatibleWithEventArgs">
      <summary>
              Looks up a localized string similar to The event member's delegate has an arguments parameter that is not compatible with System.EventArgs.  Member name: {0}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.EventIsNotCompatibleWithEventHandler">
      <summary>
              Looks up a localized string similar to The event member's delegate is not compatible with System.EventHandler&lt;TEventArgs&gt;.  Member name: {0}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.EventSubscriptionIncompatibleDelegate">
      <summary>
              Looks up a localized string similar to The specified delegate type is not compatible with the delegate type of the RoutedEvent..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.EventSubscriptionIncompatibleHandler">
      <summary>
              Looks up a localized string similar to The specified handler is not a compatible delegate type, ICommand or IObserver&lt;EventPattern&lt;TEventArgs&gt;&gt; object for the specified RoutedEvent..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.EventSubscriptionIncompatibleObserver">
      <summary>
              Looks up a localized string similar to The specified observer's type argument is not compatible with the delegate type of the RoutedEvent.  Expected EventPattern&lt;TEventArgs&gt; where TEventArgs is any type that is compatible with the argument type of the RoutedEvent..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.InlineParseNotSupported">
      <summary>
              Looks up a localized string similar to An in-line query cannot be parsed while the grammar is being defined..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.InlineParserWithoutGrammar">
      <summary>
              Looks up a localized string similar to The temporary in-line parser does not have a grammar..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.InvalidFormatDirectoryPath">
      <summary>
              Looks up a localized string similar to The format of the specified directory path is invalid..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.InvalidPairDirectionValue">
      <summary>
              Looks up a localized string similar to The PairDirection value is invalid..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParseCalledWhileParsing">
      <summary>
              Looks up a localized string similar to Parse cannot be called again until the current parse operation completes..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParseExceptionMessage">
      <summary>
              Looks up a localized string similar to Syntax error in parser input sequence..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParseExceptionMessageOverrideFormat">
      <summary>
              Looks up a localized string similar to {0}{1}Source index: {2}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParseNotCalledOrFailed">
      <summary>
              Looks up a localized string similar to The operation is unavailable until after Parse has been called and it has completed successfully..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParserCannotMoveToEndBackward">
      <summary>
              Looks up a localized string similar to The parser cannot move the cursor to the end of the input sequence because the current index is ahead of the latest index..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParserNextNotReady">
      <summary>
              Looks up a localized string similar to The Next property cannot be read until after Parse is called..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParseSubscribeCalledWhileParsing">
      <summary>
              Looks up a localized string similar to The parser does not allow new subscriptions until the current parse operation completes..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyDoesNotSupportChangeEvents">
      <summary>
              Looks up a localized string similar to The specified property does not support change events..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyExpressionContainsIndexer">
      <summary>
              Looks up a localized string similar to The specified expression contains an indexer..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyExpressionNotUnderstood">
      <summary>
              Looks up a localized string similar to The specified expression cannot be understood as a property..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyExpressionOwnerNotUnderstood">
      <summary>
              Looks up a localized string similar to The specified expression cannot be understood as a property being read from a local variable, field, another property, or a chain of fields and properties..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyExpressionTooComplex">
      <summary>
              Looks up a localized string similar to The specified expression contains more than just fields and properties..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyExpresssionOwnerNotDetermined">
      <summary>
              Looks up a localized string similar to The owner of the specified property could not be determined..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyIsReadOnly">
      <summary>
              Looks up a localized string similar to The specified property is read-only.  Property name: {0}..
            </summary>
    </member>
    <member name="T:Rxx.Properties.Text">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DefaultDisposedSubscriptionMessage">
      <summary>
              Looks up a localized string similar to Disposed subscription..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DefaultDisposingSubscriptionMessage">
      <summary>
              Looks up a localized string similar to Disposing subscription..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DefaultOnCompletedMessage">
      <summary>
              Looks up a localized string similar to Sequence completed..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DefaultSubscribedMessage">
      <summary>
              Looks up a localized string similar to Subscribed to observable..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DefaultSubscribingMessage">
      <summary>
              Looks up a localized string similar to Subscribing to observable..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DisposedSubscriptionFormat">
      <summary>
              Looks up a localized string similar to Disposed subscription: {0}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DisposingSubscriptionFormat">
      <summary>
              Looks up a localized string similar to Disposing subscription: {0}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.FileSystemWatcherBufferChangeFormat">
      <summary>
              Looks up a localized string similar to Increasing FileSystemWatcher buffer size from {0} to {1}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.FileSystemWatcherBufferOverflowFormat">
      <summary>
              Looks up a localized string similar to FileSystemWatcher buffer overflow: {0}.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.SubscribedFormat">
      <summary>
              Looks up a localized string similar to Subscribed to observable: {0}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.SubscribingFormat">
      <summary>
              Looks up a localized string similar to Subscribing to observable: {0}..
            </summary>
    </member>
    <member name="T:System.Configuration.ApplicationSettingsBaseExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for <see cref="T:System.Configuration.ApplicationSettingsBase" /> objects.
            </summary>
    </member>
    <member name="M:System.Configuration.ApplicationSettingsBaseExtensions.SettingChanges(System.Configuration.ApplicationSettingsBase)">
      <summary>
            Returns an observable sequence of setting values that have changed.
            </summary>
      <param name="settings">The object that defines the settings to observe.</param>
      <returns>An observable sequence of setting values that have changed.</returns>
      <requires>settings != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SettingsPropertyValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Configuration.ApplicationSettingsBaseExtensions.SettingChanges(System.Configuration.ApplicationSettingsBase,System.String[])">
      <summary>
            Returns an observable sequence of values that have changed for the settings with the specified <paramref name="names" />.
            </summary>
      <param name="settings">The object that defines the settings to observe.</param>
      <param name="names">The names of one or more settings to be observed.</param>
      <returns>An observable sequence of values that have changed for the settings with the specified <paramref name="names" />.</returns>
      <requires>settings != null</requires>
      <requires>names != null</requires>
      <requires>names.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SettingsPropertyValue&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Either">
      <summary>
            Provides <see langword="static" /> factory methods for creating instances of <see cref="T:System.Either`2" /> objects.
            </summary>
    </member>
    <member name="M:System.Either.Left``2(``0)">
      <summary>
            Creates a new instance of <see cref="T:System.Either`2" /> with the specified <paramref name="value" />
            and <see cref="P:System.Either`2.IsLeft" /> set to <see langword="true" />.
            </summary>
      <typeparam name="TLeft">Type of the left value.</typeparam>
      <typeparam name="TRight">Type of the right value.</typeparam>
      <param name="value">The left value.</param>
      <returns>A new instance of <see cref="T:System.Either`2" /> with the specified <paramref name="value" />
            and <see cref="P:System.Either`2.IsLeft" /> set to <see langword="true" />.</returns>
      <ensures>Contract.Result&lt;Either&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Either.Right``2(``1)">
      <summary>
            Creates a new instance of <see cref="T:System.Either`2" /> with the specified <paramref name="value" />
            and <see cref="P:System.Either`2.IsLeft" /> set to <see langword="false" />.
            </summary>
      <typeparam name="TLeft">Type of the left value.</typeparam>
      <typeparam name="TRight">Type of the right value.</typeparam>
      <param name="value">The right value.</param>
      <returns>A new instance of <see cref="T:System.Either`2" /> with the specified <paramref name="value" />
            and <see cref="P:System.Either`2.IsLeft" /> set to <see langword="false" />.</returns>
      <ensures>Contract.Result&lt;Either&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Either.RightValue`2">
      <summary>
            Holds the value of the right side of an <see cref="T:System.Either`2" />.
            </summary>
      <typeparam name="TLeft">Type of the left side.</typeparam>
      <typeparam name="TRight">Type of the right side.</typeparam>
    </member>
    <member name="T:System.Either`2">
      <summary>
            Represents one of two possible values.
            </summary>
      <typeparam name="TLeft">Type of the left value.</typeparam>
      <typeparam name="TRight">Type of the right value.</typeparam>
    </member>
    <member name="M:System.Either`2.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Either`2" /> class for derived classes.
            </summary>
    </member>
    <member name="M:System.Either`2.Switch(System.Action{`0},System.Action{`1})">
      <summary>
            Invokes the specified <paramref name="left" /> or <paramref name="right" /> action depending upon 
            the value of <see cref="P:System.Either`2.IsLeft" />.
            </summary>
      <param name="left">The action to be invoked when <see cref="P:System.Either`2.IsLeft" /> is <see langword="true" />.</param>
      <param name="right">The action to be invoked when <see cref="P:System.Either`2.IsLeft" /> is <see langword="false" />.</param>
      <requires>left != null</requires>
      <requires>right != null</requires>
    </member>
    <member name="M:System.Either`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})">
      <summary>
            Invokes the specified <paramref name="left" /> or <paramref name="right" /> function depending upon 
            the value of <see cref="P:System.Either`2.IsLeft" />.
            </summary>
      <typeparam name="TResult">The type of the result.</typeparam>
      <param name="left">The function to be invoked when <see cref="P:System.Either`2.IsLeft" /> is <see langword="true" />.</param>
      <param name="right">The function to be invoked when <see cref="P:System.Either`2.IsLeft" /> is <see langword="false" />.</param>
      <returns>The return value of either the <paramref name="left" /> or <paramref name="right" /> function
            depending upon the value of <see cref="P:System.Either`2.IsLeft" />.</returns>
      <requires>left != null</requires>
      <requires>right != null</requires>
    </member>
    <member name="P:System.Either`2.IsLeft">
      <summary>
            Gets a value indicating whether the object holds the left value or the right value.
            </summary>
      <value>
        <see langword="true" /> if the object holds the left value; otherwise, <see langword="false" />.</value>
    </member>
    <member name="P:System.Either`2.Left">
      <summary>
            Gets the left value when <see cref="P:System.Either`2.IsLeft" /> is <see langword="true" />.
            </summary>
      <value>The left value when <see cref="P:System.Either`2.IsLeft" /> is <see langword="true" />.</value>
      <getter>
        <requires>IsLeft</requires>
      </getter>
    </member>
    <member name="P:System.Either`2.Right">
      <summary>
            Gets the right value when <see cref="P:System.Either`2.IsLeft" /> is <see langword="false" />.
            </summary>
      <value>The right value when <see cref="P:System.Either`2.IsLeft" /> is <see langword="false" />.</value>
      <getter>
        <requires>!IsLeft</requires>
      </getter>
    </member>
    <member name="M:System.Either.RightValue`2.#ctor(`1)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Either.RightValue`2" /> class.
            </summary>
      <param name="value">The right value.</param>
    </member>
    <member name="M:System.Either.RightValue`2.Switch(System.Action{`0},System.Action{`1})">
      <summary>
            Invokes the specified <paramref name="right" /> action.
            </summary>
      <param name="left">This parameter is ignored.</param>
      <param name="right">The action to be invoked.</param>
      <requires inheritedFrom="M:System.Either`2.Switch(System.Action{`0},System.Action{`1})" inheritedFromTypeName="Either">left != null</requires>
      <requires inheritedFrom="M:System.Either`2.Switch(System.Action{`0},System.Action{`1})" inheritedFromTypeName="Either">right != null</requires>
    </member>
    <member name="M:System.Either.RightValue`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})">
      <summary>
            Invokes the specified <paramref name="right" /> function.
            </summary>
      <typeparam name="TResult">The type of the result.</typeparam>
      <param name="left">This parameter is ignored.</param>
      <param name="right">The function to be invoked.</param>
      <returns>The return value of the <paramref name="right" /> function.</returns>
      <requires inheritedFrom="M:System.Either`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})" inheritedFromTypeName="Either">left != null</requires>
      <requires inheritedFrom="M:System.Either`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})" inheritedFromTypeName="Either">right != null</requires>
    </member>
    <member name="P:System.Either.RightValue`2.IsLeft">
      <summary>
            Gets whether the object holds the left value or the right value.
            </summary>
      <value>Always returns <see langword="false" />.</value>
    </member>
    <member name="P:System.Either.RightValue`2.Left">
      <summary>
            Gets the left value when <see cref="P:System.Either.RightValue`2.IsLeft" /> is <see langword="true" />.
            </summary>
      <value>Always throws <strong>System.Diagnostics.Contracts.ContractException</strong>.</value>
      <getter>
        <requires inheritedFrom="M:System.Either`2.get_Left" inheritedFromTypeName="Either">IsLeft</requires>
      </getter>
    </member>
    <member name="P:System.Either.RightValue`2.Right">
      <summary>
            Gets the right value when <see cref="P:System.Either.RightValue`2.IsLeft" /> is <see langword="false" />.
            </summary>
      <value>Always returns the left value.</value>
      <getter>
        <requires inheritedFrom="M:System.Either`2.get_Right" inheritedFromTypeName="Either">!IsLeft</requires>
      </getter>
    </member>
    <member name="T:System.Either.LeftValue`2">
      <summary>
            Holds the value of the left side of an <see cref="T:System.Either`2" />.
            </summary>
      <typeparam name="TLeft">Type of the left side.</typeparam>
      <typeparam name="TRight">Type of the right side.</typeparam>
    </member>
    <member name="M:System.Either.LeftValue`2.#ctor(`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Either.LeftValue`2" /> class.
            </summary>
      <param name="value">The left value.</param>
    </member>
    <member name="M:System.Either.LeftValue`2.Switch(System.Action{`0},System.Action{`1})">
      <summary>
            Invokes the specified <paramref name="left" /> action.
            </summary>
      <param name="left">The action to be invoked.</param>
      <param name="right">This parameter is ignored.</param>
      <requires inheritedFrom="M:System.Either`2.Switch(System.Action{`0},System.Action{`1})" inheritedFromTypeName="Either">left != null</requires>
      <requires inheritedFrom="M:System.Either`2.Switch(System.Action{`0},System.Action{`1})" inheritedFromTypeName="Either">right != null</requires>
    </member>
    <member name="M:System.Either.LeftValue`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})">
      <summary>
            Invokes the specified <paramref name="left" /> function.
            </summary>
      <typeparam name="TResult">The type of the result.</typeparam>
      <param name="left">The function to be invoked.</param>
      <param name="right">This parameter is ignored.</param>
      <returns>The return value of the <paramref name="left" /> function</returns>
      <requires inheritedFrom="M:System.Either`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})" inheritedFromTypeName="Either">left != null</requires>
      <requires inheritedFrom="M:System.Either`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})" inheritedFromTypeName="Either">right != null</requires>
    </member>
    <member name="P:System.Either.LeftValue`2.IsLeft">
      <summary>
            Gets whether the object holds the left value or the right value.
            </summary>
      <value>Always returns <see langword="true" />.</value>
    </member>
    <member name="P:System.Either.LeftValue`2.Left">
      <summary>
            Gets the left value when <see cref="P:System.Either.LeftValue`2.IsLeft" /> is <see langword="true" />.
            </summary>
      <value>Always returns the left value.</value>
      <getter>
        <requires inheritedFrom="M:System.Either`2.get_Left" inheritedFromTypeName="Either">IsLeft</requires>
      </getter>
    </member>
    <member name="P:System.Either.LeftValue`2.Right">
      <summary>
            Gets the right value when <see cref="P:System.Either.LeftValue`2.IsLeft" /> is <see langword="false" />.
            </summary>
      <value>Always throws <strong>System.Diagnostics.Contracts.ContractException</strong>.</value>
      <getter>
        <requires inheritedFrom="M:System.Either`2.get_Right" inheritedFromTypeName="Either">!IsLeft</requires>
      </getter>
    </member>
    <member name="T:System.IO.DirectoryInfoExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for <see cref="T:System.IO.DirectoryInfo" /> objects.
            </summary>
    </member>
    <member name="M:System.IO.DirectoryInfoExtensions.Collect(System.IO.DirectoryInfo)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" />, and also responds to changes by adding the full paths of files that are created 
            and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.DirectoryInfoExtensions.Collect(System.IO.DirectoryInfo,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" />, and also responds to changes by adding the full paths of files that are created 
            and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.DirectoryInfoExtensions.Collect(System.IO.DirectoryInfo,System.String)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding the full paths of files that are created and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>filter != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.DirectoryInfoExtensions.Collect(System.IO.DirectoryInfo,System.String,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding the full paths of files that are created and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>filter != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.DirectoryInfoExtensions.Collect(System.IO.DirectoryInfo,System.String,System.Boolean)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding the full paths of files that are created and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="includeSubdirectories">Specifies whether to include and watch files from subdirectories.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>filter != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.DirectoryInfoExtensions.Collect(System.IO.DirectoryInfo,System.String,System.Boolean,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding the full paths of files that are created and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="includeSubdirectories">Specifies whether to include and watch files from subdirectories.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>filter != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.DirectoryInfoExtensions.Collect``1(System.IO.DirectoryInfo,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" />, and also responds to changes by adding elements projected from the full paths of files that are created 
            and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.DirectoryInfoExtensions.Collect``1(System.IO.DirectoryInfo,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" />, and also responds to changes by adding elements projected from the full paths of files that are created 
            and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>selector != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.DirectoryInfoExtensions.Collect``1(System.IO.DirectoryInfo,System.String,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding elements projected from the full paths of files that are created and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>filter != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.DirectoryInfoExtensions.Collect``1(System.IO.DirectoryInfo,System.String,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding elements projected from the full paths of files that are created and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>filter != null</requires>
      <requires>selector != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.DirectoryInfoExtensions.Collect``1(System.IO.DirectoryInfo,System.String,System.Boolean,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding elements projected from the full paths of files that are created and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="includeSubdirectories">Specifies whether to include and watch files from subdirectories.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>filter != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.DirectoryInfoExtensions.Collect``1(System.IO.DirectoryInfo,System.String,System.Boolean,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding elements projected from the full paths of files that are created and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="includeSubdirectories">Specifies whether to include and watch files from subdirectories.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>filter != null</requires>
      <requires>selector != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.IO.ObservableDirectory">
      <summary>
            Provides <see langword="static" /> methods for generating in-memory lists that reactively reflect the state of file system directories.
            </summary>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect(System.String)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" />, and also responds to changes by adding the full paths of files that are created 
            and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect(System.String,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" />, and also responds to changes by adding the full paths of files that are created 
            and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect(System.String,System.String)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding the full paths of files that are created and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>filter != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect(System.String,System.String,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding the full paths of files that are created and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>filter != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect(System.String,System.String,System.Boolean)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding the full paths of files that are created and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="includeSubdirectories">Specifies whether to include and watch files from subdirectories.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>filter != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect(System.String,System.String,System.Boolean,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding the full paths of files that are created and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="includeSubdirectories">Specifies whether to include and watch files from subdirectories.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>filter != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect``1(System.String,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" />, and also responds to changes by adding elements projected from the full paths of files that are created 
            and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect``1(System.String,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" />, and also responds to changes by adding elements projected from the full paths of files that are created 
            and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>selector != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect``1(System.String,System.String,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding elements projected from the full paths of files that are created and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>filter != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect``1(System.String,System.String,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding elements projected from the full paths of files that are created and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>filter != null</requires>
      <requires>selector != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect``1(System.String,System.String,System.Boolean,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding elements projected from the full paths of files that are created and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="includeSubdirectories">Specifies whether to include and watch files from subdirectories.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>filter != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect``1(System.String,System.String,System.Boolean,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding elements projected from the full paths of files that are created and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="includeSubdirectories">Specifies whether to include and watch files from subdirectories.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>filter != null</requires>
      <requires>selector != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect(System.Uri)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" />, and also responds to changes by adding the full paths of files that are created 
            and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>!directory.IsAbsoluteUri || directory.IsFile</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect(System.Uri,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" />, and also responds to changes by adding the full paths of files that are created 
            and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>!directory.IsAbsoluteUri || directory.IsFile</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect(System.Uri,System.String)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding the full paths of files that are created and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>!directory.IsAbsoluteUri || directory.IsFile</requires>
      <requires>filter != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect(System.Uri,System.String,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding the full paths of files that are created and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>!directory.IsAbsoluteUri || directory.IsFile</requires>
      <requires>filter != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect(System.Uri,System.String,System.Boolean)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding the full paths of files that are created and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="includeSubdirectories">Specifies whether to include and watch files from subdirectories.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>!directory.IsAbsoluteUri || directory.IsFile</requires>
      <requires>filter != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect(System.Uri,System.String,System.Boolean,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding the full paths of files that are created and removing those that are deleted.
            </summary>
      <param name="directory">The path to be watched.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="includeSubdirectories">Specifies whether to include and watch files from subdirectories.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>!directory.IsAbsoluteUri || directory.IsFile</requires>
      <requires>filter != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect``1(System.Uri,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" />, and also responds to changes by adding elements projected from the full paths of files that are created 
            and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>!directory.IsAbsoluteUri || directory.IsFile</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect``1(System.Uri,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" />, and also responds to changes by adding elements projected from the full paths of files that are created 
            and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>!directory.IsAbsoluteUri || directory.IsFile</requires>
      <requires>selector != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect``1(System.Uri,System.String,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding elements projected from the full paths of files that are created and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>!directory.IsAbsoluteUri || directory.IsFile</requires>
      <requires>filter != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect``1(System.Uri,System.String,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding elements projected from the full paths of files that are created and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched, not including any subdirectories.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>!directory.IsAbsoluteUri || directory.IsFile</requires>
      <requires>filter != null</requires>
      <requires>selector != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect``1(System.Uri,System.String,System.Boolean,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding elements projected from the full paths of files that are created and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="includeSubdirectories">Specifies whether to include and watch files from subdirectories.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>!directory.IsAbsoluteUri || directory.IsFile</requires>
      <requires>filter != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.ObservableDirectory.Collect``1(System.Uri,System.String,System.Boolean,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the specified <paramref name="directory" /> and match the specified <paramref name="filter" />, and also responds to changes by 
            adding elements projected from the full paths of files that are created and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="directory">The path to be watched.</param>
      <param name="filter">The type of files to watch.  For example, "*.txt" includes all text files.</param>
      <param name="includeSubdirectories">Specifies whether to include and watch files from subdirectories.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes in the specified <paramref name="directory" />
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the specified <paramref name="directory" />.</returns>
      <requires>directory != null</requires>
      <requires>!directory.IsAbsoluteUri || directory.IsFile</requires>
      <requires>filter != null</requires>
      <requires>selector != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Maybe">
      <summary>
            Provides methods that construct instances of <see cref="T:System.Maybe`1" />.
            </summary>
    </member>
    <member name="M:System.Maybe.Empty``1">
      <summary>
            Gets a <see cref="T:System.Maybe`1" /> that represents a missing instance of <typeparamref name="T" />.
            </summary>
      <typeparam name="T">Type of object.</typeparam>
      <returns>A <see cref="T:System.Maybe`1" /> with <see cref="P:System.Maybe`1.HasValue" /> set to <see langword="false" />.</returns>
      <ensures>!Contract.Result&lt;Maybe&lt;T&gt;&gt;().HasValue</ensures>
    </member>
    <member name="M:System.Maybe.Return``1(``0)">
      <summary>
            Creates a new instance of <see cref="T:System.Maybe`1" /> with the specified <paramref name="value" />.
            </summary>
      <typeparam name="T">Type of <paramref name="value" /></typeparam>
      <param name="value">The value assigned to the <see cref="P:System.Maybe`1.Value" /> property.</param>
      <returns>A new instance of <see cref="T:System.Maybe`1" /> with the specified <paramref name="value" /> and 
            <see cref="P:System.Maybe`1.HasValue" /> set to <see langword="true" />.</returns>
      <ensures>Contract.Result&lt;Maybe&lt;T&gt;&gt;().HasValue</ensures>
      <ensures>object.Equals(Contract.Result&lt;Maybe&lt;T&gt;&gt;().Value, value)</ensures>
    </member>
    <member name="T:System.Net.Sockets.SocketExtensions">
      <summary>
            Provides <see langword="static" /> extension methods that return observable sequences for accepting, connecting, disconnecting, 
            receiving data and sending data via <see cref="T:System.Net.Sockets.Socket" /> objects.
            </summary>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.ConnectObservable(System.Net.Sockets.Socket,System.Net.EndPoint)">
      <summary>
            Establishes a connection to a remote host.
            </summary>
      <param name="socket">The socket that will create the connection.</param>
      <param name="remoteEndPoint">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</param>
      <returns>A singleton observable sequence that indicates when the connection has been established.</returns>
      <requires>socket != null</requires>
      <requires>remoteEndPoint != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.ConnectObservable(System.Net.Sockets.Socket,System.Net.IPAddress,System.Int32)">
      <summary>
            Establishes a connection to a remote host.
            </summary>
      <param name="socket">The socket that will create the connection.</param>
      <param name="address">The <see cref="T:System.Net.IPAddress" /> of the remote host.</param>
      <param name="port">The port number of the remote host.</param>
      <returns>A singleton observable sequence that indicates when the connection has been established.</returns>
      <requires>socket != null</requires>
      <requires>address != null</requires>
      <requires>port &gt;= IPEndPoint.MinPort</requires>
      <requires>port &lt;= IPEndPoint.MaxPort</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.ConnectObservable(System.Net.Sockets.Socket,System.Net.IPAddress[],System.Int32)">
      <summary>
            Establishes a connection to a remote host.
            </summary>
      <param name="socket">The socket that will create the connection.</param>
      <param name="addresses">At least one <see cref="T:System.Net.IPAddress" />, designating the remote host.</param>
      <param name="port">The port number of the remote host.</param>
      <returns>A singleton observable sequence that indicates when the connection has been established.</returns>
      <requires>socket != null</requires>
      <requires>addresses != null</requires>
      <requires>addresses.Length &gt; 0</requires>
      <requires>port &gt;= IPEndPoint.MinPort</requires>
      <requires>port &lt;= IPEndPoint.MaxPort</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.ConnectObservable(System.Net.Sockets.Socket,System.String,System.Int32)">
      <summary>
            Establishes a connection to a remote host.
            </summary>
      <param name="socket">The socket that will create the connection.</param>
      <param name="host">The name of the remote host.</param>
      <param name="port">The port number of the remote host.</param>
      <returns>A singleton observable sequence that indicates when the connection has been established.</returns>
      <requires>socket != null</requires>
      <requires>host != null</requires>
      <requires>port &gt;= IPEndPoint.MinPort</requires>
      <requires>port &lt;= IPEndPoint.MaxPort</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.DisconnectObservable(System.Net.Sockets.Socket,System.Boolean)">
      <summary>
            Closes the socket connection and allows reuse of the <paramref name="socket" />.
            </summary>
      <param name="socket">The socket that will be disconnected.</param>
      <param name="reuseSocket">
        <see langword="true" /> if this <paramref name="socket" /> can be reused after the 
            connection is closed; otherwise, <see langword="false" />.</param>
      <returns>A singleton observable sequence that indicates when the socket has been disconnected.</returns>
      <requires>socket != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.AcceptObservable(System.Net.Sockets.Socket)">
      <summary>
            Accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" />.
            </summary>
      <param name="socket">The socket that will accept a new connection.</param>
      <returns>A singleton observable sequence containing the connected <see cref="T:System.Net.Sockets.Socket" />.</returns>
      <requires>socket != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Socket&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.AcceptObservable(System.Net.Sockets.Socket,System.Int32)">
      <summary>
            Accepts an incoming connection attempt, creates a new <see cref="T:System.Net.Sockets.Socket" /> and receives the first 
            block of data sent by the client application.
            </summary>
      <param name="socket">The socket that will accept a new connection.</param>
      <param name="receiveSize">The number of bytes to accept from the sender.</param>
      <returns>A singleton paired observable sequence containing the connected <see cref="T:System.Net.Sockets.Socket" /> in the left channel
            and the first block of data in the right channel.</returns>
      <requires>socket != null</requires>
      <requires>receiveSize &gt;= 0</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;Socket, byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.AcceptObservable(System.Net.Sockets.Socket,System.Net.Sockets.Socket,System.Int32)">
      <summary>
            Accepts an incoming connection attempt, creates a new <see cref="T:System.Net.Sockets.Socket" /> and receives the first 
            block of data sent by the client application.
            </summary>
      <param name="socket">The socket that will accept a new connection.</param>
      <param name="acceptSocket">The accepted <see cref="T:System.Net.Sockets.Socket" /> object.  This value may be <see langword="null" />.</param>
      <param name="receiveSize">The maximum number of bytes to receive.</param>
      <returns>A singleton paired observable sequence containing the connected <see cref="T:System.Net.Sockets.Socket" /> in the left channel
            and the first block of data in the right channel.</returns>
      <requires>socket != null</requires>
      <requires>receiveSize &gt;= 0</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;Socket, byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.SendObservable(System.Net.Sockets.Socket,System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
      <summary>
            Sends the data in the specified <paramref name="buffers" /> to a connected <see cref="T:System.Net.Sockets.Socket" />.
            </summary>
      <param name="socket">The socket that will send the data.</param>
      <param name="buffers">The data to send.</param>
      <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
      <returns>A singleton observable sequence containing the number of bytes that were sent.</returns>
      <requires>socket != null</requires>
      <requires>buffers != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.SendObservable(System.Net.Sockets.Socket,System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
      <summary>
            Sends the data in the specified <paramref name="buffer" /> to a connected <see cref="T:System.Net.Sockets.Socket" />.
            </summary>
      <param name="socket">The socket that will send the data.</param>
      <param name="buffer">The data to send.</param>
      <param name="offset">The zero-based position in the buffer parameter at which to begin sending data.</param>
      <param name="size">The number of bytes to send.</param>
      <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
      <returns>A singleton observable sequence containing the number of bytes that were sent.</returns>
      <requires>socket != null</requires>
      <requires>buffer != null</requires>
      <requires>offset &gt;= 0</requires>
      <requires>offset &lt;= buffer.Length</requires>
      <requires>size &gt;= 0</requires>
      <requires>size &lt;= buffer.Length - offset</requires>
      <ensures>Contract.Result&lt;IObservable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.SendUntilCompleted(System.Net.Sockets.Socket,System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
      <summary>
            Sends the data in the specified <paramref name="buffer" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> until the specified 
            <paramref name="size" /> has been reached.
            </summary>
      <param name="socket">The socket that will send the data.</param>
      <param name="buffer">The data to send.</param>
      <param name="offset">The zero-based position in the buffer parameter at which to begin sending data.</param>
      <param name="size">The number of bytes to send.</param>
      <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
      <returns>A singleton observable sequence that indicates when the data has been sent.</returns>
      <requires>socket != null</requires>
      <requires>buffer != null</requires>
      <requires>offset &gt;= 0</requires>
      <requires>offset &lt;= buffer.Length</requires>
      <requires>size &gt;= 0</requires>
      <requires>size &lt;= buffer.Length - offset</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.SendFileObservable(System.Net.Sockets.Socket,System.String)">
      <summary>
            Sends the specified file to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the 
            <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flag.
            </summary>
      <param name="socket">The socket that will send the file.</param>
      <param name="fileName">The path and name of the file to send.  This parameter can be <see langword="null" />.</param>
      <returns>A singleton observable sequence that indicates when the file has been sent.</returns>
      <requires>socket != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.SendFileObservable(System.Net.Sockets.Socket,System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
      <summary>
            Sends the specified file to a connected <see cref="T:System.Net.Sockets.Socket" /> object.
            </summary>
      <param name="socket">The socket that will send the file.</param>
      <param name="fileName">The path and name of the file to send.  This parameter can be <see langword="null" />.</param>
      <param name="preBuffer">The data to be sent before the file is sent.  This parameter can be <see langword="null" />.</param>
      <param name="postBuffer">The data to be sent after the file is sent.  This parameter can be <see langword="null" />.</param>
      <param name="flags">A bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</param>
      <returns>A singleton observable sequence that indicates when the file has been sent.</returns>
      <requires>socket != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.SendToObservable(System.Net.Sockets.Socket,System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
      <summary>
            Sends the data in the specified <paramref name="buffer" /> to a connected <see cref="T:System.Net.Sockets.Socket" />.
            </summary>
      <param name="socket">The socket that will send the data.</param>
      <param name="buffer">The data to send.</param>
      <param name="offset">The zero-based position in the buffer parameter at which to begin sending data.</param>
      <param name="size">The number of bytes to send.</param>
      <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
      <param name="remoteEndPoint">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</param>
      <returns>A singleton observable sequence containing the number of bytes that were sent.</returns>
      <requires>socket != null</requires>
      <requires>buffer != null</requires>
      <requires>offset &gt;= 0</requires>
      <requires>offset &lt;= buffer.Length</requires>
      <requires>size &gt;= 0</requires>
      <requires>size &lt;= buffer.Length - offset</requires>
      <requires>remoteEndPoint != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.SendToUntilCompleted(System.Net.Sockets.Socket,System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
      <summary>
            Sends the data in the specified <paramref name="buffer" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> until the specified 
            <paramref name="size" /> has been reached.
            </summary>
      <param name="socket">The socket that will send the data.</param>
      <param name="buffer">The data to send.</param>
      <param name="offset">The zero-based position in the buffer parameter at which to begin sending data.</param>
      <param name="size">The number of bytes to send.</param>
      <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
      <param name="remoteEndPoint">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</param>
      <returns>A singleton observable sequence that indicates when the data has been sent.</returns>
      <requires>socket != null</requires>
      <requires>buffer != null</requires>
      <requires>offset &gt;= 0</requires>
      <requires>offset &lt;= buffer.Length</requires>
      <requires>size &gt;= 0</requires>
      <requires>size &lt;= buffer.Length - offset</requires>
      <requires>remoteEndPoint != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.ReceiveObservable(System.Net.Sockets.Socket,System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
      <summary>
            Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the specified <paramref name="buffers" />.
            </summary>
      <param name="socket">The socket that will receive the data.</param>
      <param name="buffers">The storage location for the received data.</param>
      <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
      <returns>A singleton observable sequence containing the number of bytes that were received.</returns>
      <requires>socket != null</requires>
      <requires>buffers != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.ReceiveObservable(System.Net.Sockets.Socket,System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
      <summary>
            Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the specified <paramref name="buffer" />.
            </summary>
      <param name="socket">The socket that will receive the data.</param>
      <param name="buffer">The storage location for the received data.</param>
      <param name="offset">The zero-based position in the <paramref name="buffer" /> at which to store the received data.</param>
      <param name="size">The number of bytes to receive.</param>
      <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
      <returns>A singleton observable sequence containing the number of bytes that were received.</returns>
      <requires>socket != null</requires>
      <requires>buffer != null</requires>
      <requires>offset &gt;= 0</requires>
      <requires>offset &lt;= buffer.Length</requires>
      <requires>size &gt;= 0</requires>
      <requires>size &lt;= buffer.Length - offset</requires>
      <ensures>Contract.Result&lt;IObservable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.ReceiveUntilCompleted(System.Net.Sockets.Socket,System.Net.Sockets.SocketFlags)">
      <summary>
            Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a sequence of <see cref="T:System.Byte" /> arrays until the host shuts down 
            the connection.
            </summary>
      <remarks>
        <alert type="warn">
            Unlike many of the other <see cref="T:System.Net.Sockets.ObservableSocket" /> methods, 	<see cref="M:System.Net.Sockets.SocketExtensions.ReceiveUntilCompleted(System.Net.Sockets.Socket,System.Net.Sockets.SocketFlags)" />
            returns a <strong>cold</strong> observable.  This is to ensure that observers do not miss any of the byte arrays in the sequence; otherwise, 
            buffering would be required for the entire sequence, similar to how <see cref="M:System.Reactive.Linq.Observable.FromAsyncPattern(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})" /> 
            buffers the first result and then replays it to all subscribers.  Another consequence of the <strong>cold</strong> behavior is that 
            subscriptions are not shared, thus every new subscription will perform an independent receive operation on the <paramref name="socket" />.
            </alert>
      </remarks>
      <param name="socket">The socket that will receive the data.</param>
      <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
      <returns>An observable sequence of <see cref="T:System.Byte" /> arrays containing the data that was received.</returns>
      <requires>socket != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.ReceiveFromObservable(System.Net.Sockets.Socket,System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
      <summary>
            Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the specified <paramref name="buffer" /> and stores the 
            actual <see cref="T:System.Net.EndPoint" />.
            </summary>
      <param name="socket">The socket that will receive the data.</param>
      <param name="buffer">The storage location for the received data.</param>
      <param name="offset">The zero-based position in the <paramref name="buffer" /> at which to store the received data.</param>
      <param name="size">The number of bytes to receive.</param>
      <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
      <param name="remoteEndPoint">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</param>
      <returns>A singleton observable sequence containing a tuple that indicates the number of bytes that were received
            and the actual <see cref="T:System.Net.EndPoint" /> from which the data was received.</returns>
      <requires>socket != null</requires>
      <requires>buffer != null</requires>
      <requires>offset &gt;= 0</requires>
      <requires>offset &lt;= buffer.Length</requires>
      <requires>size &gt;= 0</requires>
      <requires>size &lt;= buffer.Length - offset</requires>
      <requires>remoteEndPoint != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Tuple&lt;int, EndPoint&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.SocketExtensions.ReceiveMessageFromObservable(System.Net.Sockets.Socket,System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
      <summary>
            Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the specified <paramref name="buffer" /> and stores the 
            actual <see cref="T:System.Net.Sockets.SocketFlags" />, <see cref="T:System.Net.EndPoint" /> and packet information.
            </summary>
      <param name="socket">The socket that will receive the data.</param>
      <param name="buffer">The storage location for the received data.</param>
      <param name="offset">The zero-based position in the <paramref name="buffer" /> at which to store the received data.</param>
      <param name="size">The number of bytes to receive.</param>
      <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
      <param name="remoteEndPoint">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</param>
      <returns>A singleton observable sequence containing a tuple that indicates the number of bytes that were received
            and the actual <see cref="T:System.Net.EndPoint" /> from which the data was received.</returns>
      <requires>socket != null</requires>
      <requires>buffer != null</requires>
      <requires>offset &gt;= 0</requires>
      <requires>offset &lt;= buffer.Length</requires>
      <requires>size &gt;= 0</requires>
      <requires>size &lt;= buffer.Length - offset</requires>
      <requires>remoteEndPoint != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Tuple&lt;int, SocketFlags, EndPoint, IPPacketInformation&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Net.WebClientExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for asynchronously sending and receiving data from <see cref="T:System.Net.WebClient" /> objects.
            </summary>
    </member>
    <member name="M:System.Net.WebClientExtensions.DownloadFileObservable(System.Net.WebClient,System.Uri,System.String)">
      <summary>
            Downloads the specified resource as a file.
            </summary>
      <param name="client">The object that downloads the resource.</param>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <param name="fileName">The file to create or overwrite with the resource.</param>
      <returns>An observable that caches the result of the download and replays it to observers.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <requires>fileName != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.DownloadFileWithProgress(System.Net.WebClient,System.Uri,System.String)">
      <summary>
            Downloads the specified resource as a file and includes a channel for progress notifications.
            </summary>
      <param name="client">The object that downloads the resource.</param>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <param name="fileName">The file to create or overwrite with the resource.</param>
      <returns>A paired observable that pushes progress notifications through the left channel, caches the result of the 
            download in the right channel and replays the result to observers.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <requires>fileName != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;DownloadProgressChangedEventArgs, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.DownloadStringObservable(System.Net.WebClient,System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.String" />.
            </summary>
      <param name="client">The object that downloads the resource.</param>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>An observable that caches the result of the download and replays it to observers.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.OpenReadObservable(System.Net.WebClient,System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.IO.Stream" />.
            </summary>
      <param name="client">The object that downloads the resource.</param>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>An observable containing the readable stream that reads data from the resource.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.OpenReadWithProgress(System.Net.WebClient,System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.IO.Stream" /> and includes a channel for progress notifications.
            </summary>
      <param name="client">The object that downloads the resource.</param>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>A paired observable that pushes progress notifications through the left channel and 
            contains the readable stream that reads data from the resource in the right channel.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;DownloadProgressChangedEventArgs, Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.OpenWriteObservable(System.Net.WebClient,System.Uri,System.String)">
      <summary>
            Opens a writeable stream to the specified resource.
            </summary>
      <param name="client">The object that uploads to the resource.</param>
      <param name="address">The URI of the resource to receive the stream.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <returns>An observable containing the writeable stream that sends data to the resource.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <requires>method != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.UploadDataObservable(System.Net.WebClient,System.Uri,System.String,System.Byte[])">
      <summary>
            Uploads a <see cref="T:System.Byte" /> array to the specified resource.
            </summary>
      <param name="client">The object that uploads to the resource.</param>
      <param name="address">The URI of the resource to receive the data.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="data">The bytes to upload to the resource.</param>
      <returns>An observable that caches the response from the server and replays it to observers.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <requires>data != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.UploadDataWithProgress(System.Net.WebClient,System.Uri,System.String,System.Byte[])">
      <summary>
            Uploads a <see cref="T:System.Byte" /> array to the specified resource and includes a channel for progress notifications.
            </summary>
      <param name="client">The object that uploads to the resource.</param>
      <param name="address">The URI of the resource to receive the data.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="data">The bytes to upload to the resource.</param>
      <returns>A paired observable that pushes progress notifications through the left channel, caches the response from the 
            server in the right channel and replays the response to observers.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <requires>data != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;UploadProgressChangedEventArgs, byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.UploadFileObservable(System.Net.WebClient,System.Uri,System.String,System.String)">
      <summary>
            Uploads a file to the specified resource.
            </summary>
      <param name="client">The object that uploads to the resource.</param>
      <param name="address">The URI of the resource to receive the file.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="fileName">The file to upload to the resource.</param>
      <returns>An observable that caches the response from the server and replays it to observers.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <requires>fileName != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.UploadFileWithProgress(System.Net.WebClient,System.Uri,System.String,System.String)">
      <summary>
            Uploads a file to the specified resource and includes a channel for progress notifications.
            </summary>
      <param name="client">The object that uploads to the resource.</param>
      <param name="address">The URI of the resource to receive the file.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="fileName">The file to upload to the resource.</param>
      <returns>A paired observable that pushes progress notifications through the left channel, caches the response from the 
            server in the right channel and replays the response to observers.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <requires>fileName != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;UploadProgressChangedEventArgs, byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.UploadStringObservable(System.Net.WebClient,System.Uri,System.String,System.String)">
      <summary>
            Uploads a string to the specified resource.
            </summary>
      <param name="client">The object that uploads to the resource.</param>
      <param name="address">The URI of the resource to receive the string.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="data">The string to send to the resource.</param>
      <returns>An observable that caches the response from the server and replays it to observers.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <requires>method != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.UploadValuesObservable(System.Net.WebClient,System.Uri,System.String,System.Collections.Specialized.NameValueCollection)">
      <summary>
            Uploads data to the specified resource.
            </summary>
      <param name="client">The object that uploads to the resource.</param>
      <param name="address">The URI of the resource to receive the collection.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="values">The collection of data as name/value pairs to send to the resource.</param>
      <returns>An observable that caches the response from the server and replays it to observers.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <requires>values != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.UploadValuesWithProgress(System.Net.WebClient,System.Uri,System.String,System.Collections.Specialized.NameValueCollection)">
      <summary>
            Uploads data to the specified resource and includes a channel for progress notifications.
            </summary>
      <param name="client">The object that uploads to the resource.</param>
      <param name="address">The URI of the resource to receive the collection.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="values">The collection of data as name/value pairs to send to the resource.</param>
      <returns>A paired observable that pushes progress notifications through the left channel, caches the response from the 
            server in the right channel and replays the response to observers.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <requires>values != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;UploadProgressChangedEventArgs, byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.DownloadDataObservable(System.Net.WebClient,System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.Byte" /> array.
            </summary>
      <param name="client">The object that downloads the resource.</param>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>An observable that caches the result of the download and replays it to observers.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.DownloadDataWithProgress(System.Net.WebClient,System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.Byte" /> array and includes a channel for progress notifications.
            </summary>
      <param name="client">The object that downloads the resource.</param>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>A paired observable that pushes progress notifications through the left channel, caches the result of the 
            download in the right channel and replays the result to observers.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;DownloadProgressChangedEventArgs, byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Net.HttpListenerExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for creating HTTP request observables from <see cref="T:System.Net.HttpListener" /> objects.
            </summary>
    </member>
    <member name="M:System.Net.HttpListenerExtensions.StartObservable(System.Net.HttpListener)">
      <summary>
            Returns an observable of concurrent HTTP requests.
            </summary>
      <remarks>
        <alert type="warn">
          <see cref="M:System.Net.HttpListenerExtensions.StartObservable(System.Net.HttpListener)" /> does not guarantee the serializability of notifications that is recommended in the 
            Rx Design Guidelines.  This allows observers to receive multiple requests concurrently, as is common in 
            hosting scenarios.
            </alert>
      </remarks>
      <param name="listener">The object that listens for requests.</param>
      <returns>An observable of concurrent HTTP requests.</returns>
      <requires>listener != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;HttpListenerContext&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.HttpListenerExtensions.StartObservable(System.Net.HttpListener,System.Int32)">
      <summary>
            Returns an observable of concurrent HTTP requests.
            </summary>
      <remarks>
        <alert type="warn">
          <see cref="M:System.Net.HttpListenerExtensions.StartObservable(System.Net.HttpListener,System.Int32)" /> does not guarantee the serializability of notifications that is recommended in the 
            Rx Design Guidelines.  This allows observers to receive multiple requests concurrently, as is common in 
            hosting scenarios.
            </alert>
      </remarks>
      <param name="listener">The object that listens for requests.</param>
      <param name="maxConcurrent">The maximum number of requests that can be pushed through the observable simultaneously.</param>
      <returns>An observable of concurrent HTTP requests.</returns>
      <requires>listener != null</requires>
      <requires>maxConcurrent &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;HttpListenerContext&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Net.Mail.SmtpClientExtensions">
      <summary>
            Provides <see langword="static" /> extension methods on <see cref="T:System.Net.Mail.SmtpClient" /> objects that asynchronously send data to and observe data from a resource identified by a URI.
            </summary>
    </member>
    <member name="M:System.Net.Mail.SmtpClientExtensions.SendObservable(System.Net.Mail.SmtpClient,System.Net.Mail.MailMessage)">
      <summary>
            Sends the specified e-mail message to an SMTP server for delivery.
            </summary>
      <param name="client">The object that sends the e-mail message.</param>
      <param name="message">A <see cref="T:System.Net.Mail.MailMessage" /> that contains the message to send.</param>
      <returns>A singleton observable that contains the cached result of sending the specified <paramref name="message" />.</returns>
      <requires>client != null</requires>
      <requires>message != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;AsyncCompletedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Mail.SmtpClientExtensions.SendObservable(System.Net.Mail.SmtpClient,System.String,System.String,System.String,System.String)">
      <summary>
            Sends an e-mail message to an SMTP server for delivery.
            </summary>
      <param name="client">The object that sends the e-mail message.</param>
      <param name="from">Contains the address information of the message sender.</param>
      <param name="recipients">Contains the addresses that the message is sent to.</param>
      <param name="subject">Contains the subject line for the message.</param>
      <param name="body">Contains the message body.</param>
      <returns>A singleton observable that contains the cached result of sending the message.</returns>
      <requires>client != null</requires>
      <requires>!string.IsNullOrEmpty(from)</requires>
      <requires>!string.IsNullOrEmpty(recipients)</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;AsyncCompletedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Net.NetworkInformation.PingExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for <see cref="T:System.Net.NetworkInformation.Ping" /> objects that asynchronously determine whether a remote computer is accessible over the network.
            </summary>
    </member>
    <member name="M:System.Net.NetworkInformation.PingExtensions.SendObservable(System.Net.NetworkInformation.Ping,System.Net.IPAddress)">
      <summary>
            Asynchronously attempts to send an Internet Control Message Protocol (ICMP) echo message to the computer that has the specified <see cref="T:System.Net.IPAddress" />, and receive a corresponding ICMP echo reply message from that computer.
            </summary>
      <param name="ping">The object that sends the ICMP echo message.</param>
      <param name="address">An <see cref="T:System.Net.IPAddress" /> that identifies the computer that is the destination for the ICMP echo message.</param>
      <returns>A hot observable containing a <see cref="T:System.Net.NetworkInformation.PingReply" /> instance that provides information about the ICMP echo reply message, if one was received, or describes the reason for the failure if no message was received.</returns>
      <requires>ping != null</requires>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;PingReply&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.NetworkInformation.PingExtensions.SendObservable(System.Net.NetworkInformation.Ping,System.String)">
      <summary>
            Asynchronously attempts to send an Internet Control Message Protocol (ICMP) echo message to the specified computer, and receive a corresponding ICMP echo reply message from that computer.
            </summary>
      <param name="ping">The object that sends the ICMP echo message.</param>
      <param name="hostNameOrAddress">A <see cref="T:System.String" /> that identifies the computer that is the destination for the ICMP echo message. The value specified for this parameter can be a host name or a string representation of an IP address.</param>
      <returns>A hot observable containing a <see cref="T:System.Net.NetworkInformation.PingReply" /> instance that provides information about the ICMP echo reply message, if one was received, or describes the reason for the failure if no message was received.</returns>
      <requires>ping != null</requires>
      <requires>!string.IsNullOrWhiteSpace(hostNameOrAddress)</requires>
      <ensures>Contract.Result&lt;IObservable&lt;PingReply&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.NetworkInformation.PingExtensions.SendObservable(System.Net.NetworkInformation.Ping,System.Net.IPAddress,System.Int32)">
      <summary>
            Asynchronously attempts to send an Internet Control Message Protocol (ICMP) echo message to the computer that has the specified <see cref="T:System.Net.IPAddress" />, and receive a corresponding ICMP echo reply message from that computer.
            </summary>
      <param name="ping">The object that sends the ICMP echo message.</param>
      <param name="address">An <see cref="T:System.Net.IPAddress" /> that identifies the computer that is the destination for the ICMP echo message.</param>
      <param name="timeout">An <see cref="T:System.Int32" /> value that specifies the maximum number of milliseconds (after sending the echo message) to wait for the ICMP echo reply message.</param>
      <returns>A hot observable containing a <see cref="T:System.Net.NetworkInformation.PingReply" /> instance that provides information about the ICMP echo reply message, if one was received, or describes the reason for the failure if no message was received.</returns>
      <requires>ping != null</requires>
      <requires>address != null</requires>
      <requires>timeout &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;PingReply&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.NetworkInformation.PingExtensions.SendObservable(System.Net.NetworkInformation.Ping,System.String,System.Int32)">
      <summary>
            Asynchronously attempts to send an Internet Control Message Protocol (ICMP) echo message to the specified computer, and receive a corresponding ICMP echo reply message from that computer. This overload allows you to specify a time-out value for the operation.
            </summary>
      <param name="ping">The object that sends the ICMP echo message.</param>
      <param name="hostNameOrAddress">A <see cref="T:System.String" /> that identifies the computer that is the destination for the ICMP echo message. The value specified for this parameter can be a host name or a string representation of an IP address.</param>
      <param name="timeout">An <see cref="T:System.Int32" /> value that specifies the maximum number of milliseconds (after sending the echo message) to wait for the ICMP echo reply message.</param>
      <returns>A hot observable containing a <see cref="T:System.Net.NetworkInformation.PingReply" /> instance that provides information about the ICMP echo reply message, if one was received, or describes the reason for the failure if no message was received.</returns>
      <requires>ping != null</requires>
      <requires>!string.IsNullOrWhiteSpace(hostNameOrAddress)</requires>
      <requires>timeout &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;PingReply&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.NetworkInformation.PingExtensions.SendObservable(System.Net.NetworkInformation.Ping,System.Net.IPAddress,System.Int32,System.Byte[])">
      <summary>
            Asynchronously attempts to send an Internet Control Message Protocol (ICMP) echo message with the specified data buffer to the computer that has the specified <see cref="T:System.Net.IPAddress" />, and receive a corresponding ICMP echo reply message from that computer. This overload allows you to specify a time-out value for the operation.
            </summary>
      <param name="ping">The object that sends the ICMP echo message.</param>
      <param name="address">An <see cref="T:System.Net.IPAddress" /> that identifies the computer that is the destination for the ICMP echo message.</param>
      <param name="timeout">An <see cref="T:System.Int32" /> value that specifies the maximum number of milliseconds (after sending the echo message) to wait for the ICMP echo reply message.</param>
      <param name="buffer">A <see cref="T:System.Byte" /> array that contains data to be sent with the ICMP echo message and returned in the ICMP echo reply message. The array cannot contain more than 65,500 bytes.</param>
      <returns>A hot observable containing a <see cref="T:System.Net.NetworkInformation.PingReply" /> instance that provides information about the ICMP echo reply message, if one was received, or describes the reason for the failure if no message was received.</returns>
      <requires>ping != null</requires>
      <requires>address != null</requires>
      <requires>timeout &gt;= 0</requires>
      <requires>buffer != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;PingReply&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.NetworkInformation.PingExtensions.SendObservable(System.Net.NetworkInformation.Ping,System.String,System.Int32,System.Byte[])">
      <summary>
            Asynchronously attempts to send an Internet Control Message Protocol (ICMP) echo message with the specified data buffer to the specified computer, and receive a corresponding ICMP echo reply message from that computer. This overload allows you to specify a time-out value for the operation.
            </summary>
      <param name="ping">The object that sends the ICMP echo message.</param>
      <param name="hostNameOrAddress">A <see cref="T:System.String" /> that identifies the computer that is the destination for the ICMP echo message. The value specified for this parameter can be a host name or a string representation of an IP address.</param>
      <param name="timeout">An <see cref="T:System.Int32" /> value that specifies the maximum number of milliseconds (after sending the echo message) to wait for the ICMP echo reply message.</param>
      <param name="buffer">A <see cref="T:System.Byte" /> array that contains data to be sent with the ICMP echo message and returned in the ICMP echo reply message. The array cannot contain more than 65,500 bytes.</param>
      <returns>A hot observable containing a <see cref="T:System.Net.NetworkInformation.PingReply" /> instance that provides information about the ICMP echo reply message, if one was received, or describes the reason for the failure if no message was received.</returns>
      <requires>ping != null</requires>
      <requires>!string.IsNullOrWhiteSpace(hostNameOrAddress)</requires>
      <requires>timeout &gt;= 0</requires>
      <requires>buffer != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;PingReply&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.NetworkInformation.PingExtensions.SendObservable(System.Net.NetworkInformation.Ping,System.Net.IPAddress,System.Int32,System.Byte[],System.Net.NetworkInformation.PingOptions)">
      <summary>
            Asynchronously attempts to send an Internet Control Message Protocol (ICMP) echo message with the specified data buffer to the computer that has the specified <see cref="T:System.Net.IPAddress" />, and receive a corresponding ICMP echo reply message from that computer. This overload allows you to specify a time-out value for the operation and control fragmentation and Time-to-Live values for the ICMP echo message packet.
            </summary>
      <param name="ping">The object that sends the ICMP echo message.</param>
      <param name="address">An <see cref="T:System.Net.IPAddress" /> that identifies the computer that is the destination for the ICMP echo message.</param>
      <param name="timeout">An <see cref="T:System.Int32" /> value that specifies the maximum number of milliseconds (after sending the echo message) to wait for the ICMP echo reply message.</param>
      <param name="buffer">A <see cref="T:System.Byte" /> array that contains data to be sent with the ICMP echo message and returned in the ICMP echo reply message. The array cannot contain more than 65,500 bytes.</param>
      <param name="options">A <see cref="T:System.Net.NetworkInformation.PingOptions" /> object used to control fragmentation and Time-to-Live values for the ICMP echo message packet.</param>
      <returns>A hot observable containing a <see cref="T:System.Net.NetworkInformation.PingReply" /> instance that provides information about the ICMP echo reply message, if one was received, or describes the reason for the failure if no message was received.</returns>
      <requires>ping != null</requires>
      <requires>address != null</requires>
      <requires>timeout &gt;= 0</requires>
      <requires>buffer != null</requires>
      <requires>options != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;PingReply&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.NetworkInformation.PingExtensions.SendObservable(System.Net.NetworkInformation.Ping,System.String,System.Int32,System.Byte[],System.Net.NetworkInformation.PingOptions)">
      <summary>
            Asynchronously attempts to send an Internet Control Message Protocol (ICMP) echo message with the specified data buffer to the specified computer, and receive a corresponding ICMP echo reply message from that computer. This overload allows you to specify a time-out value for the operation and control fragmentation and Time-to-Live values for the ICMP packet.
            </summary>
      <param name="ping">The object that sends the ICMP echo message.</param>
      <param name="hostNameOrAddress">A <see cref="T:System.String" /> that identifies the computer that is the destination for the ICMP echo message. The value specified for this parameter can be a host name or a string representation of an IP address.</param>
      <param name="timeout">An <see cref="T:System.Int32" /> value that specifies the maximum number of milliseconds (after sending the echo message) to wait for the ICMP echo reply message.</param>
      <param name="buffer">A <see cref="T:System.Byte" /> array that contains data to be sent with the ICMP echo message and returned in the ICMP echo reply message. The array cannot contain more than 65,500 bytes.</param>
      <param name="options">A <see cref="T:System.Net.NetworkInformation.PingOptions" /> object used to control fragmentation and Time-to-Live values for the ICMP echo message packet.</param>
      <returns>A hot observable containing a <see cref="T:System.Net.NetworkInformation.PingReply" /> instance that provides information about the ICMP echo reply message, if one was received, or describes the reason for the failure if no message was received.</returns>
      <requires>ping != null</requires>
      <requires>!string.IsNullOrWhiteSpace(hostNameOrAddress)</requires>
      <requires>timeout &gt;= 0</requires>
      <requires>buffer != null</requires>
      <requires>options != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;PingReply&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Net.NetworkInformation.ObservablePing">
      <summary>
            Provides <see langword="static" /> methods for asynchronously determining whether a remote computer is accessible over the network.
            </summary>
    </member>
    <member name="M:System.Net.NetworkInformation.ObservablePing.Send(System.Net.IPAddress)">
      <summary>
            Asynchronously attempts to send an Internet Control Message Protocol (ICMP) echo message to the computer that has the specified <see cref="T:System.Net.IPAddress" />, and receive a corresponding ICMP echo reply message from that computer.
            </summary>
      <param name="address">An <see cref="T:System.Net.IPAddress" /> that identifies the computer that is the destination for the ICMP echo message.</param>
      <returns>A hot observable containing a <see cref="T:System.Net.NetworkInformation.PingReply" /> instance that provides information about the ICMP echo reply message, if one was received, or describes the reason for the failure if no message was received.</returns>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;PingReply&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.NetworkInformation.ObservablePing.Send(System.String)">
      <summary>
            Asynchronously attempts to send an Internet Control Message Protocol (ICMP) echo message to the specified computer, and receive a corresponding ICMP echo reply message from that computer.
            </summary>
      <param name="hostNameOrAddress">A <see cref="T:System.String" /> that identifies the computer that is the destination for the ICMP echo message. The value specified for this parameter can be a host name or a string representation of an IP address.</param>
      <returns>A hot observable containing a <see cref="T:System.Net.NetworkInformation.PingReply" /> instance that provides information about the ICMP echo reply message, if one was received, or describes the reason for the failure if no message was received.</returns>
      <requires>!string.IsNullOrWhiteSpace(hostNameOrAddress)</requires>
      <ensures>Contract.Result&lt;IObservable&lt;PingReply&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.NetworkInformation.ObservablePing.Send(System.Net.IPAddress,System.Int32)">
      <summary>
            Asynchronously attempts to send an Internet Control Message Protocol (ICMP) echo message to the computer that has the specified <see cref="T:System.Net.IPAddress" />, and receive a corresponding ICMP echo reply message from that computer.
            </summary>
      <param name="address">An <see cref="T:System.Net.IPAddress" /> that identifies the computer that is the destination for the ICMP echo message.</param>
      <param name="timeout">An <see cref="T:System.Int32" /> value that specifies the maximum number of milliseconds (after sending the echo message) to wait for the ICMP echo reply message.</param>
      <returns>A hot observable containing a <see cref="T:System.Net.NetworkInformation.PingReply" /> instance that provides information about the ICMP echo reply message, if one was received, or describes the reason for the failure if no message was received.</returns>
      <requires>address != null</requires>
      <requires>timeout &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;PingReply&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.NetworkInformation.ObservablePing.Send(System.String,System.Int32)">
      <summary>
            Asynchronously attempts to send an Internet Control Message Protocol (ICMP) echo message to the specified computer, and receive a corresponding ICMP echo reply message from that computer. This overload allows you to specify a time-out value for the operation.
            </summary>
      <param name="hostNameOrAddress">A <see cref="T:System.String" /> that identifies the computer that is the destination for the ICMP echo message. The value specified for this parameter can be a host name or a string representation of an IP address.</param>
      <param name="timeout">An <see cref="T:System.Int32" /> value that specifies the maximum number of milliseconds (after sending the echo message) to wait for the ICMP echo reply message.</param>
      <returns>A hot observable containing a <see cref="T:System.Net.NetworkInformation.PingReply" /> instance that provides information about the ICMP echo reply message, if one was received, or describes the reason for the failure if no message was received.</returns>
      <requires>!string.IsNullOrWhiteSpace(hostNameOrAddress)</requires>
      <requires>timeout &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;PingReply&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.NetworkInformation.ObservablePing.Send(System.Net.IPAddress,System.Int32,System.Byte[])">
      <summary>
            Asynchronously attempts to send an Internet Control Message Protocol (ICMP) echo message with the specified data buffer to the computer that has the specified <see cref="T:System.Net.IPAddress" />, and receive a corresponding ICMP echo reply message from that computer. This overload allows you to specify a time-out value for the operation.
            </summary>
      <param name="address">An <see cref="T:System.Net.IPAddress" /> that identifies the computer that is the destination for the ICMP echo message.</param>
      <param name="timeout">An <see cref="T:System.Int32" /> value that specifies the maximum number of milliseconds (after sending the echo message) to wait for the ICMP echo reply message.</param>
      <param name="buffer">A <see cref="T:System.Byte" /> array that contains data to be sent with the ICMP echo message and returned in the ICMP echo reply message. The array cannot contain more than 65,500 bytes.</param>
      <returns>A hot observable containing a <see cref="T:System.Net.NetworkInformation.PingReply" /> instance that provides information about the ICMP echo reply message, if one was received, or describes the reason for the failure if no message was received.</returns>
      <requires>address != null</requires>
      <requires>timeout &gt;= 0</requires>
      <requires>buffer != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;PingReply&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.NetworkInformation.ObservablePing.Send(System.String,System.Int32,System.Byte[])">
      <summary>
            Asynchronously attempts to send an Internet Control Message Protocol (ICMP) echo message with the specified data buffer to the specified computer, and receive a corresponding ICMP echo reply message from that computer. This overload allows you to specify a time-out value for the operation.
            </summary>
      <param name="hostNameOrAddress">A <see cref="T:System.String" /> that identifies the computer that is the destination for the ICMP echo message. The value specified for this parameter can be a host name or a string representation of an IP address.</param>
      <param name="timeout">An <see cref="T:System.Int32" /> value that specifies the maximum number of milliseconds (after sending the echo message) to wait for the ICMP echo reply message.</param>
      <param name="buffer">A <see cref="T:System.Byte" /> array that contains data to be sent with the ICMP echo message and returned in the ICMP echo reply message. The array cannot contain more than 65,500 bytes.</param>
      <returns>A hot observable containing a <see cref="T:System.Net.NetworkInformation.PingReply" /> instance that provides information about the ICMP echo reply message, if one was received, or describes the reason for the failure if no message was received.</returns>
      <requires>!string.IsNullOrWhiteSpace(hostNameOrAddress)</requires>
      <requires>timeout &gt;= 0</requires>
      <requires>buffer != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;PingReply&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.NetworkInformation.ObservablePing.Send(System.Net.IPAddress,System.Int32,System.Byte[],System.Net.NetworkInformation.PingOptions)">
      <summary>
            Asynchronously attempts to send an Internet Control Message Protocol (ICMP) echo message with the specified data buffer to the computer that has the specified <see cref="T:System.Net.IPAddress" />, and receive a corresponding ICMP echo reply message from that computer. This overload allows you to specify a time-out value for the operation and control fragmentation and Time-to-Live values for the ICMP echo message packet.
            </summary>
      <param name="address">An <see cref="T:System.Net.IPAddress" /> that identifies the computer that is the destination for the ICMP echo message.</param>
      <param name="timeout">An <see cref="T:System.Int32" /> value that specifies the maximum number of milliseconds (after sending the echo message) to wait for the ICMP echo reply message.</param>
      <param name="buffer">A <see cref="T:System.Byte" /> array that contains data to be sent with the ICMP echo message and returned in the ICMP echo reply message. The array cannot contain more than 65,500 bytes.</param>
      <param name="options">A <see cref="T:System.Net.NetworkInformation.PingOptions" /> object used to control fragmentation and Time-to-Live values for the ICMP echo message packet.</param>
      <returns>A hot observable containing a <see cref="T:System.Net.NetworkInformation.PingReply" /> instance that provides information about the ICMP echo reply message, if one was received, or describes the reason for the failure if no message was received.</returns>
      <requires>address != null</requires>
      <requires>timeout &gt;= 0</requires>
      <requires>buffer != null</requires>
      <requires>options != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;PingReply&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.NetworkInformation.ObservablePing.Send(System.String,System.Int32,System.Byte[],System.Net.NetworkInformation.PingOptions)">
      <summary>
            Asynchronously attempts to send an Internet Control Message Protocol (ICMP) echo message with the specified data buffer to the specified computer, and receive a corresponding ICMP echo reply message from that computer. This overload allows you to specify a time-out value for the operation and control fragmentation and Time-to-Live values for the ICMP packet.
            </summary>
      <param name="hostNameOrAddress">A <see cref="T:System.String" /> that identifies the computer that is the destination for the ICMP echo message. The value specified for this parameter can be a host name or a string representation of an IP address.</param>
      <param name="timeout">An <see cref="T:System.Int32" /> value that specifies the maximum number of milliseconds (after sending the echo message) to wait for the ICMP echo reply message.</param>
      <param name="buffer">A <see cref="T:System.Byte" /> array that contains data to be sent with the ICMP echo message and returned in the ICMP echo reply message. The array cannot contain more than 65,500 bytes.</param>
      <param name="options">A <see cref="T:System.Net.NetworkInformation.PingOptions" /> object used to control fragmentation and Time-to-Live values for the ICMP echo message packet.</param>
      <returns>A hot observable containing a <see cref="T:System.Net.NetworkInformation.PingReply" /> instance that provides information about the ICMP echo reply message, if one was received, or describes the reason for the failure if no message was received.</returns>
      <requires>!string.IsNullOrWhiteSpace(hostNameOrAddress)</requires>
      <requires>timeout &gt;= 0</requires>
      <requires>buffer != null</requires>
      <requires>options != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;PingReply&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Net.WebRequestExtensions">
      <summary>
            Provides <see langword="static" /> extension methods that return observable sequences for various asynchronous methods defined 
            by the <see cref="T:System.Net.WebRequest" />, <see cref="T:System.Net.FtpWebRequest" /> and <see cref="T:System.Net.HttpWebRequest" /> classes.
            </summary>
    </member>
    <member name="M:System.Net.WebRequestExtensions.GetRequestStreamObservable(System.Net.WebRequest)">
      <summary>
            Creates a <see cref="T:System.IO.Stream" /> for writing data to the Internet resource.
            </summary>
      <param name="request">The <see cref="T:System.Net.WebRequest" /> that provides the writable stream.</param>
      <returns>A singleton observable containing the writable <see cref="T:System.IO.Stream" />.</returns>
      <requires>request != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebRequestExtensions.GetRequestStreamObservable(System.Net.HttpWebRequest)">
      <summary>
            Creates a <see cref="T:System.IO.Stream" /> for writing data to the Internet resource.
            </summary>
      <param name="request">The <see cref="T:System.Net.HttpWebRequest" /> that provides the writable stream.</param>
      <returns>A singleton observable containing a tuple with the writable <see cref="T:System.IO.Stream" /> as the first item
            and the <see cref="T:System.Net.TransportContext" /> as the second item.</returns>
      <requires>request != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Tuple&lt;Stream, TransportContext&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebRequestExtensions.GetResponseObservable(System.Net.WebRequest)">
      <summary>
            Returns a response to an Internet request.
            </summary>
      <param name="request">The <see cref="T:System.Net.WebRequest" /> that creates the response.</param>
      <returns>A singleton observable containing the response.</returns>
      <requires>request != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;WebResponse&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebRequestExtensions.GetResponseObservable(System.Net.HttpWebRequest)">
      <summary>
            Returns a response to an Internet request.
            </summary>
      <param name="request">The <see cref="T:System.Net.HttpWebRequest" /> that creates the response.</param>
      <returns>A singleton observable containing the response.</returns>
      <requires>request != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;HttpWebResponse&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebRequestExtensions.GetResponseObservable(System.Net.FtpWebRequest)">
      <summary>
            Returns the FTP server response.
            </summary>
      <param name="request">The <see cref="T:System.Net.FtpWebRequest" /> that creates the response.</param>
      <returns>A singleton observable containing the response.</returns>
      <requires>request != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;FtpWebResponse&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Net.Mail.ObservableSmtpClient">
      <summary>
            Provides <see langword="static" /> methods for asynchronously sending data to and observing data from a resource identified by a URI.
            </summary>
    </member>
    <member name="M:System.Net.Mail.ObservableSmtpClient.Send(System.String,System.String,System.String,System.String)">
      <summary>
            Sends an e-mail message to an SMTP server for delivery.
            </summary>
      <param name="from">Contains the address information of the message sender.</param>
      <param name="recipients">Contains the addresses that the message is sent to.</param>
      <param name="subject">Contains the subject line for the message.</param>
      <param name="body">Contains the message body.</param>
      <returns>A singleton observable that contains the cached result of sending the message.</returns>
      <requires>!string.IsNullOrEmpty(from)</requires>
      <requires>!string.IsNullOrEmpty(recipients)</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;AsyncCompletedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Mail.ObservableSmtpClient.Send(System.Net.Mail.MailMessage)">
      <summary>
            Sends the specified e-mail message to an SMTP server for delivery.
            </summary>
      <param name="message">A <see cref="T:System.Net.Mail.MailMessage" /> that contains the message to send.</param>
      <returns>A singleton observable that contains the cached result of sending the specified <paramref name="message" />.</returns>
      <requires>message != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;AsyncCompletedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Net.ObservableDns">
      <summary>
            Provides <see langword="static" /> methods for asynchronously resolving domain names.
            </summary>
    </member>
    <member name="M:System.Net.ObservableDns.GetHostEntry(System.Net.IPAddress)">
      <summary>
            Resolves an IP address to an <see cref="T:System.Net.IPHostEntry" /> instance asynchronously.
            </summary>
      <param name="address">An IP address.</param>
      <returns>A singleton observable containing an <see cref="T:System.Net.IPHostEntry" /> instance that contains address information about
            the host specified in <paramref name="address" />.</returns>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IPHostEntry&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableDns.GetHostEntry(System.String)">
      <summary>
            Resolves a host name or IP address to an <see cref="T:System.Net.IPHostEntry" /> instance asynchronously.
            </summary>
      <param name="hostNameOrAddress">The host name or IP address to resolve.</param>
      <returns>A singleton observable containing an <see cref="T:System.Net.IPHostEntry" /> instance that contains address information about
            the host specified in <paramref name="hostNameOrAddress" />.</returns>
      <requires>hostNameOrAddress != null</requires>
      <requires>hostNameOrAddress.Length &lt; 256</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IPHostEntry&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableDns.GetHostAddresses(System.String)">
      <summary>
            Returns a singleton observable containing the Internet Protocol (IP) addresses for the specified host.
            </summary>
      <param name="hostNameOrAddress">The host name or IP address to resolve.</param>
      <returns>A singleton observable containing an array of type <see cref="T:System.Net.IPAddress" /> that holds the IP addresses for the
            host that is specified by the <paramref name="hostNameOrAddress" /> parameter.</returns>
      <requires>hostNameOrAddress != null</requires>
      <requires>hostNameOrAddress.Length &lt; 256</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IPAddress[]&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Net.NetworkInformation.ObservableNetworkChange">
      <summary>
            Provides common properties for subscribing to changes in network status.
            </summary>
    </member>
    <member name="P:System.Net.NetworkInformation.ObservableNetworkChange.NetworkAvailability">
      <summary>
            Gets an observable that will notify the subscriber of current network availability and then any changes to network availability.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservable&lt;bool&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:System.Net.NetworkInformation.ObservableNetworkChange.NetworkAddress">
      <summary>
            Gets an observable that will notify the subscriber of the current network address and then any changes to the network address.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservable&lt;bool&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:System.Net.Sockets.ObservableSocket">
      <summary>
            Provides <see langword="static" /> methods that return observable sequences for accepting and connecting sockets.
            </summary>
    </member>
    <member name="M:System.Net.Sockets.ObservableSocket.Connect(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.EndPoint)">
      <summary>
            Establishes a connection to a remote host.
            </summary>
      <param name="addressFamily">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</param>
      <param name="socketType">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</param>
      <param name="protocolType">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</param>
      <param name="remoteEndPoint">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</param>
      <returns>A singleton observable sequence containing the connected <see cref="T:System.Net.Sockets.Socket" />.</returns>
      <requires>remoteEndPoint != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Socket&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.ObservableSocket.Connect(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.IPAddress,System.Int32)">
      <summary>
            Establishes a connection to a remote host.
            </summary>
      <param name="addressFamily">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</param>
      <param name="socketType">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</param>
      <param name="protocolType">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</param>
      <param name="address">The <see cref="T:System.Net.IPAddress" /> of the remote host.</param>
      <param name="port">The port number of the remote host.</param>
      <returns>A singleton observable sequence containing the connected <see cref="T:System.Net.Sockets.Socket" />.</returns>
      <requires>address != null</requires>
      <requires>port &gt;= IPEndPoint.MinPort</requires>
      <requires>port &lt;= IPEndPoint.MaxPort</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Socket&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.ObservableSocket.Connect(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.IPAddress[],System.Int32)">
      <summary>
            Establishes a connection to a remote host.
            </summary>
      <param name="addressFamily">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</param>
      <param name="socketType">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</param>
      <param name="protocolType">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</param>
      <param name="addresses">At least one <see cref="T:System.Net.IPAddress" />, designating the remote host.</param>
      <param name="port">The port number of the remote host.</param>
      <returns>A singleton observable sequence containing the connected <see cref="T:System.Net.Sockets.Socket" />.</returns>
      <requires>addresses != null</requires>
      <requires>addresses.Length &gt; 0</requires>
      <requires>port &gt;= IPEndPoint.MinPort</requires>
      <requires>port &lt;= IPEndPoint.MaxPort</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Socket&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.ObservableSocket.Connect(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.String,System.Int32)">
      <summary>
            Establishes a connection to a remote host.
            </summary>
      <param name="addressFamily">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</param>
      <param name="socketType">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</param>
      <param name="protocolType">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</param>
      <param name="host">The name of the remote host.</param>
      <param name="port">The port number of the remote host.</param>
      <returns>A singleton observable sequence containing the connected <see cref="T:System.Net.Sockets.Socket" />.</returns>
      <requires>host != null</requires>
      <requires>port &gt;= IPEndPoint.MinPort</requires>
      <requires>port &lt;= IPEndPoint.MaxPort</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Socket&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.Sockets.ObservableSocket.Accept(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.IPEndPoint,System.Int32)">
      <summary>
            Accepts the specified number of incoming connection attempts and creates new <see cref="T:System.Net.Sockets.Socket" /> objects.
            </summary>
      <param name="addressFamily">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</param>
      <param name="socketType">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</param>
      <param name="protocolType">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</param>
      <param name="localEndPoint">The local <see cref="T:System.Net.EndPoint" /> to associate with the <see cref="T:System.Net.Sockets.Socket" /> that 
            will be accepting connections.</param>
      <param name="count">The maximum number of connections to accept.</param>
      <returns>An observable sequence containing the connected <see cref="T:System.Net.Sockets.Socket" /> objects.</returns>
      <requires>localEndPoint != null</requires>
      <requires>count &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Socket&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.IPairedObserver`2">
      <summary>
            Provides a mechanism for receiving push-based notifications from an <see cref="T:System.Reactive.IPairedObservable`2" />.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
    </member>
    <member name="M:System.Reactive.IPairedObserver`2.OnNextLeft(`0)">
      <summary>
            Notifies left observers of a new value in the sequence.
            </summary>
      <param name="left">The current left notification information.</param>
    </member>
    <member name="M:System.Reactive.IPairedObserver`2.OnNextRight(`1)">
      <summary>
            Notifies right observers of a new value in the sequence.
            </summary>
      <param name="right">The current right notification information.</param>
    </member>
    <member name="M:System.Reactive.AnonymousPairedObserver`2.#ctor(System.IObserver{System.Either{`0,`1}})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.AnonymousPairedObserver`2" /> class.
            </summary>
      <param name="observer">The observer that receives notifications.</param>
      <requires>observer != null</requires>
    </member>
    <member name="T:System.Reactive.IPairedObservable`2">
      <summary>
            Represents an observable with two notification channels for values.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
    </member>
    <member name="M:System.Reactive.IPairedObservable`2.Subscribe(System.Reactive.IPairedObserver{`0,`1})">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <param name="observer">The object that is to receive notifications.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>observer != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.FileSystemWatcherBufferOverflowException.#ctor(System.Exception)">
      <summary>
            Constructs a new instance of the <see cref="T:System.IO.FileSystemWatcherBufferOverflowException" /> class.
            </summary>
      <param name="innerException">The exception that was thrown by the buffer overflow.</param>
      <requires>innerException != null</requires>
    </member>
    <member name="T:System.IO.FileSystemWatcherExtensions">
      <summary>
            Provides extension methods for <see cref="T:System.IO.FileSystemWatcher" />.
            </summary>
    </member>
    <member name="M:System.IO.FileSystemWatcherExtensions.Watch(System.IO.FileSystemWatcher,System.IO.WatcherChangeTypes)">
      <summary>
            Creates an observable sequence of file system change notifications of the specified types.
            </summary>
      <param name="watcher">Watches the file system for changes.</param>
      <param name="changes">Specifies the types of changes to watch.</param>
      <remarks>
        <see cref="T:System.IO.FileSystemWatcher" /> events are raised on a thread-pool thread by default.
            See <see href="http://msdn.microsoft.com/en-us/library/system.io.filesystemwatcher.synchronizingobject.aspx">
            FileSystemNotification.SynchronizingObject
            </see> for more information.
            </remarks>
      <returns>An observable sequence of file system change notifications.</returns>
      <requires>watcher != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;FileSystemNotification&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.FileSystemWatcherExtensions.Collect(System.IO.FileSystemWatcher)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the scope of the specified <see cref="T:System.IO.FileSystemWatcher" />, and also responds to changes by adding the full paths of files 
            that are created and removing those that are deleted.
            </summary>
      <param name="watcher">The object that specifies the directory to be watched and the files to be included.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes from the specified <see cref="T:System.IO.FileSystemWatcher" /> 
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the scope of the specified <see cref="T:System.IO.FileSystemWatcher" />.</returns>
      <requires>watcher != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.FileSystemWatcherExtensions.Collect(System.IO.FileSystemWatcher,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with the full paths to all of the files that currently exist within 
            the scope of the specified <see cref="T:System.IO.FileSystemWatcher" />, and also responds to changes by adding the full paths of files 
            that are created and removing those that are deleted.
            </summary>
      <param name="watcher">The object that specifies the directory to be watched and the files to be included.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes from the specified <see cref="T:System.IO.FileSystemWatcher" /> 
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the scope of the specified <see cref="T:System.IO.FileSystemWatcher" />.</returns>
      <requires>watcher != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.FileSystemWatcherExtensions.Collect``1(System.IO.FileSystemWatcher,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the scope of the specified <see cref="T:System.IO.FileSystemWatcher" />, and also responds to changes by adding elements projected from the full paths of files 
            that are created and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="watcher">The object that specifies the directory to be watched and the files to be included.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes from the specified <see cref="T:System.IO.FileSystemWatcher" /> 
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the scope of the specified <see cref="T:System.IO.FileSystemWatcher" />.</returns>
      <requires>watcher != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.FileSystemWatcherExtensions.Collect``1(System.IO.FileSystemWatcher,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements projected from the full paths to all of the files that currently exist within 
            the scope of the specified <see cref="T:System.IO.FileSystemWatcher" />, and also responds to changes by adding elements projected from the full paths of files 
            that are created and removing those that are deleted.
            </summary>
      <typeparam name="TResult">The type of the projected elements in the list.</typeparam>
      <param name="watcher">The object that specifies the directory to be watched and the files to be included.</param>
      <param name="selector">Projects a sequence of file change notifications into a sequence from which the list is populated.</param>
      <param name="scheduler">Schedules changes to the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> and notifications to its subscribers.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that responds to changes from the specified <see cref="T:System.IO.FileSystemWatcher" /> 
            by adding the full paths of files that are created and removing those that are deleted, and also adds the full paths to all 
            of the files that initially exist within the scope of the specified <see cref="T:System.IO.FileSystemWatcher" />.</returns>
      <requires>watcher != null</requires>
      <requires>selector != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.IO.FileSystemNotification">
      <summary>
            Holds the information for a file system change event.
            </summary>
      <invariant>Enum.IsDefined(typeof(WatcherChangeTypes), change)</invariant>
      <invariant>!string.IsNullOrEmpty(name)</invariant>
      <invariant>!string.IsNullOrEmpty(fullPath)</invariant>
      <invariant>change != WatcherChangeTypes.Renamed || !string.IsNullOrEmpty(oldName)</invariant>
      <invariant>change == WatcherChangeTypes.Renamed || oldName == null</invariant>
      <invariant>change != WatcherChangeTypes.Renamed || !string.IsNullOrEmpty(oldFullPath)</invariant>
      <invariant>change == WatcherChangeTypes.Renamed || oldFullPath == null</invariant>
    </member>
    <member name="M:System.IO.FileSystemNotification.#ctor(System.IO.WatcherChangeTypes,System.String,System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:System.IO.FileSystemNotification" /> class for all change types other than <see cref="F:System.IO.WatcherChangeTypes.Renamed" />.
            </summary>
      <param name="change">The type of change that occurred.</param>
      <param name="name">The name of the file or directory that changed.</param>
      <param name="fullPath">The full path to the file or directory that changed.</param>
      <requires>change != WatcherChangeTypes.Renamed</requires>
      <requires>Enum.IsDefined(typeof(WatcherChangeTypes), change)</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>!string.IsNullOrEmpty(fullPath)</requires>
    </member>
    <member name="M:System.IO.FileSystemNotification.#ctor(System.String,System.String,System.String,System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:System.IO.FileSystemNotification" /> class for <see cref="F:System.IO.WatcherChangeTypes.Renamed" />.
            </summary>
      <param name="oldName">The previous name of the file or directory that was renamed.</param>
      <param name="oldFullPath">The previous full path of the file or directory that was renamed.</param>
      <param name="name">The new name of the file or directory.</param>
      <param name="fullPath">The new full path of the file or directory.</param>
      <requires>!string.IsNullOrEmpty(oldName)</requires>
      <requires>!string.IsNullOrEmpty(oldFullPath)</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>!string.IsNullOrEmpty(fullPath)</requires>
      <ensures>change == WatcherChangeTypes.Renamed</ensures>
    </member>
    <member name="M:System.IO.FileSystemNotification.ToString">
      <summary>
            Gets a string representation of the file system change notification.
            </summary>
      <returns>String the represents the notification.</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:System.IO.FileSystemNotification.Change">
      <summary>
            Gets the kind of change that the <see cref="T:System.IO.FileSystemNotification" /> represents.
            </summary>
      <getter>
        <ensures>Enum.IsDefined(typeof(WatcherChangeTypes), Contract.Result&lt;WatcherChangeTypes&gt;())</ensures>
      </getter>
    </member>
    <member name="P:System.IO.FileSystemNotification.Name">
      <summary>
            Gets the name of the file or directory that changed.
            </summary>
      <getter>
        <ensures>!string.IsNullOrEmpty(Contract.Result&lt;string&gt;())</ensures>
      </getter>
    </member>
    <member name="P:System.IO.FileSystemNotification.FullPath">
      <summary>
            Gets the full path of the file or directory that changed.
            </summary>
      <getter>
        <ensures>!string.IsNullOrEmpty(Contract.Result&lt;string&gt;())</ensures>
      </getter>
    </member>
    <member name="P:System.IO.FileSystemNotification.OldName">
      <summary>
            Gets the previous name of the file or directory, or <see langword="null" />.
            </summary>
      <value>Returns the previous name of the file or directory when <see cref="P:System.IO.FileSystemNotification.Change" /> is <see cref="F:System.IO.WatcherChangeTypes.Renamed" />;
            otherwise, returns <see langword="null" />.</value>
      <getter>
        <ensures>Change != WatcherChangeTypes.Renamed || !string.IsNullOrEmpty(Contract.Result&lt;string&gt;())</ensures>
        <ensures>Change == WatcherChangeTypes.Renamed || Contract.Result&lt;string&gt;() == null</ensures>
      </getter>
    </member>
    <member name="P:System.IO.FileSystemNotification.OldFullPath">
      <summary>
            Gets the previous full path of the file or directory, or <see langword="null" />.
            </summary>
      <value>Returns the previous full path of the file or directory when <see cref="P:System.IO.FileSystemNotification.Change" /> is <see cref="F:System.IO.WatcherChangeTypes.Renamed" />;
            otherwise, returns <see langword="null" />.</value>
      <getter>
        <ensures>Change != WatcherChangeTypes.Renamed || !string.IsNullOrEmpty(Contract.Result&lt;string&gt;())</ensures>
        <ensures>Change == WatcherChangeTypes.Renamed || Contract.Result&lt;string&gt;() == null</ensures>
      </getter>
    </member>
    <member name="T:System.Reactive.Linq.PairedObservable">
      <summary>
            Provides extension and factory methods for <see cref="T:System.Reactive.IPairedObservable`2" />.
            </summary>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.ForEachPair``2(System.IObservable{System.Either{``0,``1}},System.Action{``0},System.Action{``1})">
      <summary>
            Invokes the actions for their side-effects on each value in the observable sequence and blocks till the sequence is terminated.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable for which a subscription is created.</param>
      <param name="onNextLeft">The handler of notifications in the left channel.</param>
      <param name="onNextRight">The handler of notifications in the right channel.</param>
      <requires>source != null</requires>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.TakeLeft``2(System.IObservable{System.Either{``0,``1}})">
      <summary>
            Returns an observable that contains only the values from the left notification channel.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable from which values are taken.</param>
      <returns>An observable of values from the left notification channel.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TLeft&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.TakeRight``2(System.IObservable{System.Either{``0,``1}})">
      <summary>
            Returns an observable that contains only the values from the right notification channel.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable from which values are taken.</param>
      <returns>An observable of values from the right notification channel.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.TakeLeft``2(System.IObservable{System.Either{``0,``1}},System.Int32)">
      <summary>
            Returns an observable that contains only the values from the left notification channel
            up to the specified <paramref name="count" />.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable from which values are taken.</param>
      <param name="count">The number of values to take.</param>
      <returns>An observable of values from the left notification channel.</returns>
      <requires>source != null</requires>
      <requires>count &gt;= 0</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.TakeRight``2(System.IObservable{System.Either{``0,``1}},System.Int32)">
      <summary>
            Returns an observable that contains only the values from the right notification channel
            up to the specified <paramref name="count" />.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable from which values are taken.</param>
      <param name="count">The number of values to take.</param>
      <returns>An observable of values from the right notification channel.</returns>
      <requires>source != null</requires>
      <requires>count &gt;= 0</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.Select``4(System.IObservable{System.Either{``0,``1}},System.Func{``0,``2},System.Func{``1,``3})">
      <summary>
            Projects the values from both notification channels into a new sequence.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <typeparam name="TLeftResult">Result type of the left notification channel.</typeparam>
      <typeparam name="TRightResult">Result type of the right notification channel.</typeparam>
      <param name="source">The observable from which values are projected.</param>
      <param name="leftSelector">Projects values from the left notification channel.</param>
      <param name="rightSelector">Projects value from the right notification channel.</param>
      <returns>A paired observable of results from the projection of values in both notification channels.</returns>
      <requires>source != null</requires>
      <requires>leftSelector != null</requires>
      <requires>rightSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeftResult, TRightResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.SelectLeft``3(System.IObservable{System.Either{``0,``1}},System.Func{``0,``2})">
      <summary>
            Projects the values from the left notification channel into a new sequence.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <typeparam name="TResult">Type of the result.</typeparam>
      <param name="source">The observable from which values are projected.</param>
      <param name="selector">Projects values from the left notification channel.</param>
      <returns>An observable of results from the projection of values in the left notification channel.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.SelectRight``3(System.IObservable{System.Either{``0,``1}},System.Func{``1,``2})">
      <summary>
            Projects the values from the right notification channel into a new sequence.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <typeparam name="TResult">Type of the result.</typeparam>
      <param name="source">The observable from which values are projected.</param>
      <param name="selector">Projects values from the right notification channel.</param>
      <returns>An observable of results from the projection of values in the right notification channel.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.Combine``3(System.IObservable{System.Either{``0,``1}},System.Func{``0,``1,``2})">
      <summary>
            Combines the latest values from both notification channels and projects the results into a new sequence.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <typeparam name="TResult">Type of the result.</typeparam>
      <param name="source">The observable from which values are combined.</param>
      <param name="selector">Combines values from both notification channels.</param>
      <remarks>
        <see cref="M:System.Reactive.Linq.PairedObservable.Combine``3(System.IObservable{System.Either{``0,``1}},System.Func{``0,``1,``2})" /> is similar to <see cref="M:System.Reactive.Linq.Observable.CombineLatest``3(System.IObservable{``0},System.IObservable{``1},System.Func{``0,``1,``2})" />.
            </remarks>
      <returns>An observable of results from the combination of the latest values in both notification channels.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.Create``2(System.Func{System.Reactive.IPairedObserver{``0,``1},System.Action})">
      <summary>
            Creates a paired observable sequence from the <paramref name="subscribe" /> implementation.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="subscribe">Subscribes observers to the paired observable.</param>
      <returns>A paired observable that calls the specified <paramref name="subscribe" /> function when an observer subscribes.</returns>
      <requires>subscribe != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.Create``2(System.Func{System.Reactive.IPairedObserver{``0,``1},System.IDisposable})">
      <summary>
            Creates a paired observable sequence from the <paramref name="subscribe" /> implementation.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="subscribe">Subscribes observers to the paired observable.</param>
      <returns>A paired observable that calls the specified <paramref name="subscribe" /> function when an observer subscribes.</returns>
      <requires>subscribe != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.Linq.PairDirection">
      <summary>
            Indicates whether an observed value being projected into an <see cref="T:System.Reactive.IPairedObservable`2" /> is a
            left value, right value, neither or both.
            </summary>
    </member>
    <member name="F:System.Reactive.Linq.PairDirection.Neither">
      <summary>
            The value is excluded.
            </summary>
    </member>
    <member name="F:System.Reactive.Linq.PairDirection.Left">
      <summary>
            The value is for the left channel.
            </summary>
    </member>
    <member name="F:System.Reactive.Linq.PairDirection.Right">
      <summary>
            The value is for the right channel.
            </summary>
    </member>
    <member name="F:System.Reactive.Linq.PairDirection.Both">
      <summary>
            Ths value is for both the left and right channels.
            </summary>
    </member>
    <member name="T:System.Net.ObservableHttpListener">
      <summary>
            Provides <see langword="static" /> methods for creating HTTP request observables.
            </summary>
    </member>
    <member name="M:System.Net.ObservableHttpListener.Start(System.Net.IPEndPoint)">
      <summary>
            Returns an observable of concurrent HTTP requests.
            </summary>
      <remarks>
        <alert type="warn">
          <see cref="M:System.Net.ObservableHttpListener.Start(System.Net.IPEndPoint)" /> does not guarantee the serializability of notifications that is recommended in the 
            Rx Design Guidelines.  This allows observers to receive multiple requests concurrently, as is common in 
            hosting scenarios.
            </alert>
      </remarks>
      <param name="endPoint">The local end point on which to listen for requests.</param>
      <returns>An observable of concurrent HTTP requests.</returns>
      <requires>endPoint != null</requires>
      <requires>endPoint.Address != null</requires>
      <requires>endPoint.Port &gt;= IPEndPoint.MinPort &amp;&amp; endPoint.Port &lt;= IPEndPoint.MaxPort</requires>
      <ensures>Contract.Result&lt;IObservable&lt;HttpListenerContext&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableHttpListener.Start(System.Net.IPEndPoint,System.Int32)">
      <summary>
            Returns an observable of concurrent HTTP requests.
            </summary>
      <remarks>
        <alert type="warn">
          <see cref="M:System.Net.ObservableHttpListener.Start(System.Net.IPEndPoint,System.Int32)" /> does not guarantee the serializability of notifications that is recommended in the 
            Rx Design Guidelines.  This allows observers to receive multiple requests concurrently, as is common in 
            hosting scenarios.
            </alert>
      </remarks>
      <param name="endPoint">The local end point on which to listen for requests.</param>
      <param name="maxConcurrent">The maximum number of requests that can be pushed through the observable simultaneously.</param>
      <returns>An observable of concurrent HTTP requests.</returns>
      <requires>endPoint != null</requires>
      <requires>endPoint.Address != null</requires>
      <requires>endPoint.Port &gt;= IPEndPoint.MinPort &amp;&amp; endPoint.Port &lt;= IPEndPoint.MaxPort</requires>
      <requires>maxConcurrent &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;HttpListenerContext&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableHttpListener.Start(System.Net.IPEndPoint,System.String)">
      <summary>
            Returns an observable of concurrent HTTP requests.
            </summary>
      <remarks>
        <alert type="warn">
          <see cref="M:System.Net.ObservableHttpListener.Start(System.Net.IPEndPoint,System.String)" /> does not guarantee the serializability of notifications that is recommended in the 
            Rx Design Guidelines.  This allows observers to receive multiple requests concurrently, as is common in 
            hosting scenarios.
            </alert>
      </remarks>
      <param name="endPoint">The local end point on which to listen for requests.</param>
      <param name="path">The path at which requests will be served.</param>
      <returns>An observable of concurrent HTTP requests.</returns>
      <requires>endPoint != null</requires>
      <requires>endPoint.Address != null</requires>
      <requires>endPoint.Port &gt;= IPEndPoint.MinPort &amp;&amp; endPoint.Port &lt;= IPEndPoint.MaxPort</requires>
      <ensures>Contract.Result&lt;IObservable&lt;HttpListenerContext&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableHttpListener.Start(System.Net.IPEndPoint,System.String,System.Int32)">
      <summary>
            Returns an observable of concurrent HTTP requests.
            </summary>
      <remarks>
        <alert type="warn">
          <see cref="M:System.Net.ObservableHttpListener.Start(System.Net.IPEndPoint,System.String,System.Int32)" /> does not guarantee the serializability of notifications that is recommended in the 
            Rx Design Guidelines.  This allows observers to receive multiple requests concurrently, as is common in 
            hosting scenarios.
            </alert>
      </remarks>
      <param name="endPoint">The local end point on which to listen for requests.</param>
      <param name="path">The path at which requests will be served.</param>
      <param name="maxConcurrent">The maximum number of requests that can be pushed through the observable simultaneously.</param>
      <returns>An observable of concurrent HTTP requests.</returns>
      <requires>endPoint != null</requires>
      <requires>endPoint.Address != null</requires>
      <requires>endPoint.Port &gt;= IPEndPoint.MinPort &amp;&amp; endPoint.Port &lt;= IPEndPoint.MaxPort</requires>
      <requires>maxConcurrent &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;HttpListenerContext&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableHttpListener.Start(System.String)">
      <summary>
            Returns an observable of concurrent HTTP requests.
            </summary>
      <remarks>
        <alert type="warn">
          <see cref="M:System.Net.ObservableHttpListener.Start(System.String)" /> does not guarantee the serializability of notifications that is recommended in the 
            Rx Design Guidelines.  This allows observers to receive multiple requests concurrently, as is common in 
            hosting scenarios.
            </alert>
      </remarks>
      <param name="domain">The domain name on which to listen for requests.</param>
      <returns>An observable of concurrent HTTP requests.</returns>
      <requires>!string.IsNullOrEmpty(domain)</requires>
      <ensures>Contract.Result&lt;IObservable&lt;HttpListenerContext&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableHttpListener.Start(System.String,System.Int32)">
      <summary>
            Returns an observable of concurrent HTTP requests.
            </summary>
      <remarks>
        <alert type="warn">
          <see cref="M:System.Net.ObservableHttpListener.Start(System.String,System.Int32)" /> does not guarantee the serializability of notifications that is recommended in the 
            Rx Design Guidelines.  This allows observers to receive multiple requests concurrently, as is common in 
            hosting scenarios.
            </alert>
      </remarks>
      <param name="domain">The domain name on which to listen for requests.</param>
      <param name="port">The port number on which to listen for requests.</param>
      <returns>An observable of concurrent HTTP requests.</returns>
      <requires>!string.IsNullOrEmpty(domain)</requires>
      <requires>port &gt;= IPEndPoint.MinPort &amp;&amp; port &lt;= IPEndPoint.MaxPort</requires>
      <ensures>Contract.Result&lt;IObservable&lt;HttpListenerContext&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableHttpListener.Start(System.String,System.Int32,System.Int32)">
      <summary>
            Returns an observable of concurrent HTTP requests.
            </summary>
      <remarks>
        <alert type="warn">
          <see cref="M:System.Net.ObservableHttpListener.Start(System.String,System.Int32,System.Int32)" /> does not guarantee the serializability of notifications that is recommended in the 
            Rx Design Guidelines.  This allows observers to receive multiple requests concurrently, as is common in 
            hosting scenarios.
            </alert>
      </remarks>
      <param name="domain">The domain name on which to listen for requests.</param>
      <param name="port">The port number on which to listen for requests.</param>
      <param name="maxConcurrent">The maximum number of requests that can be pushed through the observable simultaneously.</param>
      <returns>An observable of concurrent HTTP requests.</returns>
      <requires>!string.IsNullOrEmpty(domain)</requires>
      <requires>port &gt;= IPEndPoint.MinPort &amp;&amp; port &lt;= IPEndPoint.MaxPort</requires>
      <requires>maxConcurrent &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;HttpListenerContext&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableHttpListener.Start(System.String,System.Int32,System.String)">
      <summary>
            Returns an observable of concurrent HTTP requests.
            </summary>
      <remarks>
        <alert type="warn">
          <see cref="M:System.Net.ObservableHttpListener.Start(System.String,System.Int32,System.String)" /> does not guarantee the serializability of notifications that is recommended in the 
            Rx Design Guidelines.  This allows observers to receive multiple requests concurrently, as is common in 
            hosting scenarios.
            </alert>
      </remarks>
      <param name="domain">The domain name on which to listen for requests.</param>
      <param name="port">The port number on which to listen for requests.</param>
      <param name="path">The path at which requests will be served.</param>
      <returns>An observable of concurrent HTTP requests.</returns>
      <requires>!string.IsNullOrEmpty(domain)</requires>
      <requires>port &gt;= IPEndPoint.MinPort &amp;&amp; port &lt;= IPEndPoint.MaxPort</requires>
      <ensures>Contract.Result&lt;IObservable&lt;HttpListenerContext&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableHttpListener.Start(System.String,System.Int32,System.String,System.Int32)">
      <summary>
            Returns an observable of concurrent HTTP requests.
            </summary>
      <remarks>
        <alert type="warn">
          <see cref="M:System.Net.ObservableHttpListener.Start(System.String,System.Int32,System.String,System.Int32)" /> does not guarantee the serializability of notifications that is recommended in the 
            Rx Design Guidelines.  This allows observers to receive multiple requests concurrently, as is common in 
            hosting scenarios.
            </alert>
      </remarks>
      <param name="domain">The domain name on which to listen for requests.</param>
      <param name="port">The port number on which to listen for requests.</param>
      <param name="path">The path at which requests will be served.</param>
      <param name="maxConcurrent">The maximum number of requests that can be pushed through the observable simultaneously.</param>
      <returns>An observable of concurrent HTTP requests.</returns>
      <requires>!string.IsNullOrEmpty(domain)</requires>
      <requires>port &gt;= IPEndPoint.MinPort &amp;&amp; port &lt;= IPEndPoint.MaxPort</requires>
      <requires>maxConcurrent &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;HttpListenerContext&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.PairedObservableExtensions">
      <summary>
            Provides extension methods for <see cref="T:System.Reactive.IPairedObservable`2" />.
            </summary>
    </member>
    <member name="M:System.Reactive.PairedObservableExtensions.SubscribePair``2(System.IObservable{System.Either{``0,``1}},System.Action{``0},System.Action{``1})">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable for which a subscription is created.</param>
      <param name="onNextLeft">The handler of notifications in the left channel.</param>
      <param name="onNextRight">The handler of notifications in the right channel.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>source != null</requires>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObservableExtensions.SubscribePair``2(System.IObservable{System.Either{``0,``1}},System.Action{``0},System.Action{``1},System.Action{System.Exception})">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable for which a subscription is created.</param>
      <param name="onNextLeft">The handler of notifications in the left channel.</param>
      <param name="onNextRight">The handler of notifications in the right channel.</param>
      <param name="onError">The handler of an error notification.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>source != null</requires>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onError != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObservableExtensions.SubscribePair``2(System.IObservable{System.Either{``0,``1}},System.Action{``0},System.Action{``1},System.Action)">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable for which a subscription is created.</param>
      <param name="onNextLeft">The handler of notifications in the left channel.</param>
      <param name="onNextRight">The handler of notifications in the right channel.</param>
      <param name="onCompleted">The handler of a completion notification.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>source != null</requires>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onCompleted != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObservableExtensions.SubscribePair``2(System.IObservable{System.Either{``0,``1}},System.Action{``0},System.Action{``1},System.Action{System.Exception},System.Action)">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable for which a subscription is created.</param>
      <param name="onNextLeft">The handler of notifications in the left channel.</param>
      <param name="onNextRight">The handler of notifications in the right channel.</param>
      <param name="onError">The handler of an error notification.</param>
      <param name="onCompleted">The handler of a completion notification.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>source != null</requires>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onError != null</requires>
      <requires>onCompleted != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.AnonymousPairedObservable`2.#ctor(System.IObservable{System.Either{`0,`1}})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.AnonymousPairedObservable`2" /> class.
            </summary>
      <param name="observable">The observable that receives subscriptions.</param>
      <requires>observable != null</requires>
    </member>
    <member name="T:System.Reactive.PairedObserver">
      <summary>
            Provides extension and factory methods for <see cref="T:System.Reactive.IPairedObserver`2" />.
            </summary>
    </member>
    <member name="M:System.Reactive.PairedObserver.Create``2(System.Action{``0},System.Action{``1})">
      <summary>
            Creates an observer that is capable of observing paired observables using the specified actions.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="onNextLeft">Handler for notifications from the left channel.</param>
      <param name="onNextRight">Handler for notifications from the right channel.</param>
      <returns>An observer capable of observing paired observables.</returns>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <ensures>Contract.Result&lt;IPairedObserver&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObserver.Create``2(System.Action{``0},System.Action{``1},System.Action{System.Exception})">
      <summary>
            Creates an observer that is capable of observing paired observables using the specified actions.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="onNextLeft">Handler for notifications from the left channel.</param>
      <param name="onNextRight">Handler for notifications from the right channel.</param>
      <param name="onError">Handler for an error notification.</param>
      <returns>An observer capable of observing paired observables.</returns>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onError != null</requires>
      <ensures>Contract.Result&lt;IPairedObserver&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObserver.Create``2(System.Action{``0},System.Action{``1},System.Action)">
      <summary>
            Creates an observer that is capable of observing paired observables using the specified actions.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="onNextLeft">Handler for notifications from the left channel.</param>
      <param name="onNextRight">Handler for notifications from the right channel.</param>
      <param name="onCompleted">Handler for a completed notification.</param>
      <returns>An observer capable of observing paired observables.</returns>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onCompleted != null</requires>
      <ensures>Contract.Result&lt;IPairedObserver&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObserver.Create``2(System.Action{``0},System.Action{``1},System.Action{System.Exception},System.Action)">
      <summary>
            Creates an observer that is capable of observing paired observables using the specified actions.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="onNextLeft">Handler for notifications from the left channel.</param>
      <param name="onNextRight">Handler for notifications from the right channel.</param>
      <param name="onError">Handler for an error notification.</param>
      <param name="onCompleted">Handler for a completed notification.</param>
      <returns>An observer capable of observing paired observables.</returns>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onError != null</requires>
      <requires>onCompleted != null</requires>
      <ensures>Contract.Result&lt;IPairedObserver&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.ComponentModel.MemberDescriptorExtensions">
      <summary>
            Provides extension methods for <see cref="T:System.ComponentModel.PropertyDescriptor" /> and <see cref="T:System.ComponentModel.EventDescriptor" />.
            </summary>
    </member>
    <member name="M:System.ComponentModel.MemberDescriptorExtensions.PropertyChanged(System.ComponentModel.PropertyDescriptor,System.Object)">
      <summary>
            Returns an observable sequence of property changed notifications from the 
            specified <paramref name="property" /> descriptor.
            </summary>
      <param name="property">The descriptor from which to create an observable sequence of changed notifications.</param>
      <param name="source">The object to which the <paramref name="property" /> belongs.</param>
      <returns>An observable sequence of property changed notifications.</returns>
      <exception cref="T:System.ArgumentException">The specified property does not support change events.</exception>
      <requires>property != null</requires>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;PropertyChangedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ComponentModel.MemberDescriptorExtensions.EventRaised(System.ComponentModel.EventDescriptor,System.Object)">
      <summary>
            Returns an observable sequence of events from the specified <paramref name="event" /> descriptor.
            </summary>
      <param name="event">The descriptor from which to create an observable sequence of changed notifications.</param>
      <param name="source">The object to which the <paramref name="event" /> belongs.</param>
      <returns>An observable sequence of events.</returns>
      <requires>@event != null</requires>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;EventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Maybe`1">
      <summary>
            Represents an instance of an object or a missing instance of an object.
            </summary>
      <typeparam name="T">Type of object.</typeparam>
    </member>
    <member name="F:System.Maybe`1.Empty">
      <summary>
            Indicates a missing instance of <typeparamref name="T" />.
            </summary>
    </member>
    <member name="M:System.Maybe`1.#ctor(`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Maybe`1" /> struct with the specified available <paramref name="value" />.
            </summary>
      <remarks>
            Constructing a <see cref="T:System.Maybe`1" /> instance with this constructor always sets <see cref="P:System.Maybe`1.HasValue" /> to <see langword="true" />.
            </remarks>
      <param name="value">The value assigned to the <see cref="P:System.Maybe`1.Value" /> property.</param>
      <ensures>Contract.ValueAtReturn(out hasValue)</ensures>
      <ensures>object.Equals(Contract.ValueAtReturn(out this.value), value)</ensures>
    </member>
    <member name="M:System.Maybe`1.op_Equality(System.Maybe{`0},System.Maybe{`0})">
      <summary>
            Determines the equality of two <see cref="T:System.Maybe`1" /> values.
            </summary>
      <param name="first">The first value.</param>
      <param name="second">The second value.</param>
      <returns>
        <see langword="true" /> if the <paramref name="first" /> value equals the <paramref name="second" /> value; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Maybe`1.op_Inequality(System.Maybe{`0},System.Maybe{`0})">
      <summary>
            Determines the inequality of two <see cref="T:System.Maybe`1" /> values.
            </summary>
      <param name="first">The first value.</param>
      <param name="second">The second value.</param>
      <returns>
        <see langword="true" /> if the <paramref name="first" /> value does not equal the <paramref name="second" /> value; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Maybe`1.Equals(System.Object)">
      <summary>
            Determines the equality of this instance and the specified <paramref name="obj" />.
            </summary>
      <param name="obj">The object that is compared to this instance.</param>
      <returns>
        <see langword="true" /> if this instance equals the specified <paramref name="obj" />; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Maybe`1.Equals(System.Maybe{`0})">
      <summary>
            Determines the equality of this instance and the <paramref name="other" /> instance.
            </summary>
      <param name="other">The instance that is compared to this instance.</param>
      <returns>
        <see langword="true" /> if this instance equals the <paramref name="other" /> instance; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Maybe`1.GetHashCode">
      <summary>
            Gets the hash code of this instance.
            </summary>
      <returns>-1 if <see cref="P:System.Maybe`1.HasValue" /> is <see langword="false" /> and 0 if <see cref="P:System.Maybe`1.Value" /> is <see langword="null" />; otherwise, the hash code of <see cref="P:System.Maybe`1.Value" />.</returns>
    </member>
    <member name="M:System.Maybe`1.ToString">
      <summary>
            Returns the string representation of <see cref="P:System.Maybe`1.Value" />.
            </summary>
      <returns>String that represents this instance.</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:System.Maybe`1.HasValue">
      <summary>
            Gets a value indicating whether <see cref="P:System.Maybe`1.Value" /> is available.
            </summary>
      <value>
        <see langword="true" /> if <see cref="P:System.Maybe`1.Value" /> is available; otherwise, <see langword="false" />.</value>
    </member>
    <member name="P:System.Maybe`1.Value">
      <summary>
            Gets the value when <see cref="P:System.Maybe`1.HasValue" /> is <see langword="true" />.
            </summary>
      <getter>
        <requires>HasValue</requires>
      </getter>
    </member>
    <member name="T:System.Net.ObservableWebClient">
      <summary>
            Provides <see langword="static" /> methods for asynchronously sending data to and observing data from a resource identified by a URI.
            </summary>
    </member>
    <member name="M:System.Net.ObservableWebClient.OpenWrite(System.Uri,System.String)">
      <summary>
            Opens a writeable stream to the specified resource.
            </summary>
      <param name="address">The URI of the resource to receive the stream.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <returns>An observable containing the writeable stream that sends data to the resource.</returns>
      <requires>address != null</requires>
      <requires>method != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.UploadString(System.Uri,System.String,System.String)">
      <summary>
            Uploads a string to the specified resource.
            </summary>
      <param name="address">The URI of the resource to receive the string.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="data">The string to send to the resource.</param>
      <returns>An observable that caches the response from the server and replays it to observers.</returns>
      <requires>address != null</requires>
      <requires>method != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.UploadValues(System.Uri,System.String,System.Collections.Specialized.NameValueCollection)">
      <summary>
            Uploads data to the specified resource.
            </summary>
      <param name="address">The URI of the resource to receive the collection.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="values">The collection of data as name/value pairs to send to the resource.</param>
      <returns>An observable that caches the response from the server and replays it to observers.</returns>
      <requires>address != null</requires>
      <requires>values != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.UploadValuesWithProgress(System.Uri,System.String,System.Collections.Specialized.NameValueCollection)">
      <summary>
            Uploads data to the specified resource and includes a channel for progress notifications.
            </summary>
      <param name="address">The URI of the resource to receive the collection.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="values">The collection of data as name/value pairs to send to the resource.</param>
      <returns>A paired observable that pushes progress notifications through the left channel, caches the response from the 
            server in the right channel and replays the response to observers.</returns>
      <requires>address != null</requires>
      <requires>values != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;UploadProgressChangedEventArgs, byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.UploadFile(System.Uri,System.String,System.String)">
      <summary>
            Uploads a file to the specified resource.
            </summary>
      <param name="address">The URI of the resource to receive the file.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="fileName">The file to upload to the resource.</param>
      <returns>An observable that caches the response from the server and replays it to observers.</returns>
      <requires>address != null</requires>
      <requires>fileName != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.UploadFileWithProgress(System.Uri,System.String,System.String)">
      <summary>
            Uploads a file to the specified resource and includes a channel for progress notifications.
            </summary>
      <param name="address">The URI of the resource to receive the file.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="fileName">The file to upload to the resource.</param>
      <returns>A paired observable that pushes progress notifications through the left channel, caches the response from the 
            server in the right channel and replays the response to observers.</returns>
      <requires>address != null</requires>
      <requires>fileName != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;UploadProgressChangedEventArgs, byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.UploadData(System.Uri,System.String,System.Byte[])">
      <summary>
            Uploads a <see cref="T:System.Byte" /> array to the specified resource.
            </summary>
      <param name="address">The URI of the resource to receive the data.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="data">The bytes to upload to the resource.</param>
      <returns>An observable that caches the response from the server and replays it to observers.</returns>
      <requires>address != null</requires>
      <requires>data != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.UploadDataWithProgress(System.Uri,System.String,System.Byte[])">
      <summary>
            Uploads a <see cref="T:System.Byte" /> array to the specified resource and includes a channel for progress notifications.
            </summary>
      <param name="address">The URI of the resource to receive the data.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="data">The bytes to upload to the resource.</param>
      <returns>A paired observable that pushes progress notifications through the left channel, caches the response from the 
            server in the right channel and replays the response to observers.</returns>
      <requires>address != null</requires>
      <requires>data != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;UploadProgressChangedEventArgs, byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.OpenRead(System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.IO.Stream" />.
            </summary>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>An observable containing the readable stream that reads data from the resource.</returns>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.OpenReadWithProgress(System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.IO.Stream" /> and includes a channel for progress notifications.
            </summary>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>A paired observable that pushes progress notifications through the left channel and 
            contains the readable stream that reads data from the resource in the right channel.</returns>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;DownloadProgressChangedEventArgs, Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.DownloadString(System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.String" />.
            </summary>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>An observable that caches the result of the download and replays it to observers.</returns>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.DownloadFile(System.Uri,System.String)">
      <summary>
            Downloads the specified resource as a file.
            </summary>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <param name="fileName">The file to create or overwrite with the resource.</param>
      <returns>An observable that caches the result of the download and replays it to observers.</returns>
      <requires>address != null</requires>
      <requires>fileName != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.DownloadFileWithProgress(System.Uri,System.String)">
      <summary>
            Downloads the specified resource as a file and includes a channel for progress notifications.
            </summary>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <param name="fileName">The file to create or overwrite with the resource.</param>
      <returns>A paired observable that pushes progress notifications through the left channel, caches the result of the 
            download in the right channel and replays the result to observers.</returns>
      <requires>address != null</requires>
      <requires>fileName != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;DownloadProgressChangedEventArgs, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.DownloadData(System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.Byte" /> array.
            </summary>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>An observable that caches the result of the download and replays it to observers.</returns>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.DownloadDataWithProgress(System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.Byte" /> array and includes a channel for progress notifications.
            </summary>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>A paired observable that pushes progress notifications through the left channel, caches the result of the 
            download in the right channel and replays the result to observers.</returns>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;DownloadProgressChangedEventArgs, byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.CollectionNotificationKind">
      <summary>
            Indicates the type of a collection notification.
            </summary>
    </member>
    <member name="F:System.Reactive.CollectionNotificationKind.Exists">
      <summary>
            Indicates that an item exists in the collection.
            </summary>
    </member>
    <member name="F:System.Reactive.CollectionNotificationKind.OnAdded">
      <summary>
            Indicates that an item was added to the collection.
            </summary>
    </member>
    <member name="F:System.Reactive.CollectionNotificationKind.OnReplaced">
      <summary>
            Indicates that an item was replaced in the collection.
            </summary>
    </member>
    <member name="F:System.Reactive.CollectionNotificationKind.OnRemoved">
      <summary>
            Indicates that an item was removed from the collection.
            </summary>
    </member>
    <member name="F:System.Reactive.CollectionNotificationKind.OnCleared">
      <summary>
            Indicates that all items were removed from the collection.
            </summary>
    </member>
    <member name="T:System.Reactive.CollectionNotification">
      <summary>
            Provides <see langword="static" /> factory methods for creating <see cref="T:System.Reactive.CollectionNotification`1" /> objects.
            </summary>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateExists``1(``0)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.Exists" /> 
            notification for the specified <paramref name="value" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="value">The item that exists.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.Exists" /> 
            notification for the specified <paramref name="value" />.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;().Kind == CollectionNotificationKind.Exists</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateOnAdded``1(``0)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnAdded" /> 
            notification for the specified <paramref name="value" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="value">The item being added.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnAdded" /> 
            notification for the specified <paramref name="value" />.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;().Kind == CollectionNotificationKind.OnAdded</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateOnReplaced``1(``0,``0)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnReplaced" /> 
            notification for the specified values.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="oldValue">The item being replaced.</param>
      <param name="newValue">The item replacing the old item.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnReplaced" /> 
            notification for the specified values.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;().Kind == CollectionNotificationKind.OnReplaced</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateOnRemoved``1(``0)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnRemoved" /> 
            notification for the specified <paramref name="value" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="value">The item being removed.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnRemoved" /> 
            notification for the specified <paramref name="value" />.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;().Kind == CollectionNotificationKind.OnRemoved</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateOnCleared``1">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnCleared" /> 
            notification.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnCleared" /> 
            notification.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;().Kind == CollectionNotificationKind.OnCleared</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateDictionaryExists``2(``0,``1)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.Exists" /> 
            notification for the specified <paramref name="key" /> and <paramref name="value" /> pair.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="key">The key of the existing item.</param>
      <param name="value">The item that exists.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.Exists" /> 
            notification for the specified <paramref name="key" /> and <paramref name="value" />.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;().Kind == CollectionNotificationKind.Exists</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateDictionaryOnAdded``2(``0,``1)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnAdded" /> 
            notification for the specified <paramref name="key" /> and <paramref name="value" /> pair.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="key">The key of the item being added.</param>
      <param name="value">The item being added.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnAdded" /> 
            notification for the specified <paramref name="key" /> and <paramref name="value" />.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;().Kind == CollectionNotificationKind.OnAdded</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateDictionaryOnReplaced``2(``0,``1,``1)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnReplaced" /> 
            notification for the specified <paramref name="key" /> and value pair.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="key">The key of the item being replaced.</param>
      <param name="oldValue">The item being replaced.</param>
      <param name="newValue">The item replacing the old item.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnReplaced" /> 
            notification for the specified <paramref name="key" /> and value.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;().Kind == CollectionNotificationKind.OnReplaced</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateDictionaryOnRemoved``2(``0)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnRemoved" /> 
            notification for the specified <paramref name="key" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="key">The key of the item being removed.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnRemoved" /> 
            notification for the specified <paramref name="key" />.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;().Kind == CollectionNotificationKind.OnRemoved</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateDictionaryOnCleared``2">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnCleared" /> 
            notification.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnCleared" /> 
            notification.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;().Kind == CollectionNotificationKind.OnCleared</ensures>
    </member>
    <member name="T:System.Reactive.Subjects.CommandSubject">
      <summary>
            Represents an object that is an <see cref="T:System.Windows.Input.ICommand" />, an observable sequence of execution parameters and 
            an observer of values indicating whether the command can be executed.
            </summary>
      <threadsafety instance="true" />
      <invariant>subject != null</invariant>
      <invariant>canExecuteAnyParameter.HasValue == (canExecute == null)</invariant>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.CommandSubject" /> class that observes notifications indicating 
            whether the command can be executed.  By default, <see cref="M:System.Reactive.Subjects.CommandSubject.CanExecute(System.Object)" /> returns <see langord="true" /> until 
            a notification is observed that sets it to <see langword="false" />.
            </summary>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.#ctor(System.Boolean)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.CommandSubject" /> class that observes notifications indicating 
            whether the command can be executed.
            </summary>
      <param name="defaultCanExecute">The default value to be returned by the <see cref="M:System.Reactive.Subjects.CommandSubject.CanExecute(System.Object)" /> method.</param>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.#ctor(System.Func{System.Object,System.Boolean})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.CommandSubject" /> class that observes notifications indicating 
            whether the specified function should be invoked to determine whether the command can be executed.
            </summary>
      <remarks>
            The actual values of the notifications are ignored.  Essentially, they are treated like <see cref="T:System.Reactive.Unit" />.
            </remarks>
      <param name="canExecute">A function that receives arbitrary data or <see langword="null" /> and returns whether 
            the command can be executed for that data.</param>
      <requires>canExecute != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.AsCommand">
      <summary>
            Returns an <see cref="T:System.Windows.Input.ICommand" /> wrapper for this subject that prevents callers from using it as a subject.
            </summary>
      <returns>An <see cref="T:System.Windows.Input.ICommand" /> wrapper for this subject.</returns>
      <ensures>Contract.Result&lt;ICommand&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.CanExecute(System.Object)">
      <summary>
            Determines whether the command can execute in its current state.
            </summary>
      <param name="parameter">Data used by the command.  If the command does not require data to be passed, this object 
            can be set to <see langword="null" />.</param>
      <returns>
        <see langword="True" /> if this command can be executed; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.Execute(System.Object)">
      <summary>
            Invokes the command.
            </summary>
      <param name="parameter">Data used by the command.  If the command does not require data to be passed, this object 
            can be set to <see langword="null" />.</param>
      <exception cref="T:System.Exception">Throws the exception that was passed to <see cref="M:System.Reactive.Subjects.CommandSubject.OnError(System.Exception)" />.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.Subscribe(System.IObserver{System.Object})">
      <summary>
            Notifies the subject that an observer is to receive notifications when <see cref="M:System.Reactive.Subjects.CommandSubject.Execute(System.Object)" /> is called.
            </summary>
      <param name="observer">The object that is to receive notifications.</param>
      <returns>The observer's interface that enables resources to be disposed.</returns>
      <requires inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.OnNext(System.Boolean)">
      <summary>
            Notifies the command to reevaluate whether it can execute.
            </summary>
      <remarks>
            The behavior of <see cref="M:System.Reactive.Subjects.CommandSubject.OnNext(System.Boolean)" /> differs based on how the <see cref="T:System.Reactive.Subjects.CommandSubject" /> was constructed.
            The <see cref="M:System.Reactive.Subjects.CommandSubject.#ctor(System.Func{System.Object,System.Boolean})" /> constructor causes <see cref="M:System.Reactive.Subjects.CommandSubject.OnNext(System.Boolean)" /> to do nothing but
            raise the <see cref="E:System.Reactive.Subjects.CommandSubject.CanExecuteChanged" /> event, regardless of the specified <paramref name="value" />.
            All other constructors cause <see cref="M:System.Reactive.Subjects.CommandSubject.OnNext(System.Boolean)" /> to set the return value of <see cref="M:System.Reactive.Subjects.CommandSubject.CanExecute(System.Object)" /> to the
            specified <paramref name="value" /> and then it raises the <see cref="E:System.Reactive.Subjects.CommandSubject.CanExecuteChanged" /> event, but only if the
            value has actually changed.
            </remarks>
      <param name="value">If the <see cref="T:System.Reactive.Subjects.CommandSubject" /> was not created by the <see cref="M:System.Reactive.Subjects.CommandSubject.#ctor(System.Func{System.Object,System.Boolean})" />
            constructor, then <see langword="true" /> if the command can be executed or <see langword="false" /> if it cannot; 
            otherwise, this value is ignored.</param>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.OnError(System.Exception)">
      <summary>
            Notifies the subject that the provider has experienced an error condition.
            </summary>
      <param name="error">An object that provides additional information about the error.</param>
      <requires inheritedFrom="M:System.IObserver`1.OnError(System.Exception)" inheritedFromTypeName="IObserver">error != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.OnCompleted">
      <summary>
            Notifies the observer that the provider has finished sending push-based notifications.
            </summary>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.Dispose">
      <summary>
            Releases all resources used by an instance of the <see cref="T:System.Reactive.Subjects.CommandSubject" /> class.
            </summary>
    </member>
    <member name="E:System.Reactive.Subjects.CommandSubject.CanExecuteChanged">
      <summary>
            Occurs when changes occur that affect whether or not the command should execute.
            </summary>
      <remarks>
        <see cref="E:System.Reactive.Subjects.CommandSubject.CanExecuteChanged" /> is raised when <see cref="M:System.Reactive.Subjects.CommandSubject.OnNext(System.Boolean)" /> is called and the return value 
            of <see cref="M:System.Reactive.Subjects.CommandSubject.CanExecute(System.Object)" /> may have changed.
            </remarks>
    </member>
    <member name="T:System.Reactive.Subjects.DictionarySubject`2">
      <summary>
            Represents an object that is a dictionary as well as an observable sequence of collection notifications and observer of collection modifications.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <remarks>
        <para>
          <see cref="T:System.Reactive.Subjects.DictionarySubject`2" /> implements <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" /> and behaves similar to <see cref="T:System.Collections.ObjectModel.ObservableCollection`1" />, 
            so it can be bound directly to an <strong>ItemsPresenter</strong> or a derived type in WPF, Silverlight and Windows Phone.
            </para>
        <alert type="tip">
            The enumerator that is returned by <see cref="M:System.Reactive.Subjects.DictionarySubject`2.GetEnumerator" /> blocks all methods on the <see cref="T:System.Reactive.Subjects.DictionarySubject`2" />
            until the enumeration has completed.  For a snapshot behavior instead, simply call <see cref="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
            or <see cref="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" /> to collect the items as fast as possible and then enumerate the new collection.
            </alert>
      </remarks>
      <threadsafety instance="true" />
      <invariant>gate != null</invariant>
      <invariant>subject != null</invariant>
      <invariant>dictionary != null</invariant>
    </member>
    <member name="T:System.Reactive.Subjects.IDictionarySubject`2">
      <summary>
            Represents an object that is a dictionary as well as an observable sequence of collection notifications and observer of collection modifications.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
    </member>
    <member name="M:System.Reactive.Subjects.IDictionarySubject`2.View">
      <summary>
            Returns an observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </summary>
      <remarks>
        <alert type="tip">
            To create a synchronized clone or projection of this dictionary, simply call <c>dictionary.View().Collect(...)</c>.
            </alert>
      </remarks>
      <returns>
            An observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </returns>
      <ensures>Contract.Result&lt;IObservable&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.IDictionarySubject`2.View(`0)">
      <summary>
            Returns an observable sequence of collection notifications for the specified <paramref name="key" />, starting with the current value if the dictionary 
            already contains the <paramref name="key" />.
            </summary>
      <param name="key">The key for which changes are to be observed.</param>
      <returns>
            An observable sequence of collection notifications for the specified <paramref name="key" />, starting with the current value if the dictionary 
            already contains the <paramref name="key" />.
            </returns>
      <ensures>Contract.Result&lt;IObservable&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.DictionarySubject`2" /> class.
            </summary>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.DictionarySubject`2" /> class.
            </summary>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, 
            or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the key.</param>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.DictionarySubject`2" /> class.
            </summary>
      <param name="dictionary">The dictionary from which elements are copied to the new dictionary.</param>
      <requires>dictionary != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.DictionarySubject`2" /> class.
            </summary>
      <param name="dictionary">The dictionary from which elements are copied to the new dictionary.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, 
            or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the key.</param>
      <requires>dictionary != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.View">
      <summary>
            Returns an observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </summary>
      <remarks>
        <alert type="tip">
            To create a synchronized clone or projection of this dictionary, simply call <c>dictionary.View().Collect(...)</c>.
            </alert>
      </remarks>
      <returns>
            An observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </returns>
      <ensures>Contract.Result&lt;IObservable&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Reactive.Subjects.IDictionarySubject`2.View" inheritedFromTypeName="IDictionarySubject">Contract.Result&lt;IObservable&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.View(`0)">
      <summary>
            Returns an observable sequence of collection notifications for the specified <paramref name="key" />, starting with the current value if the dictionary 
            already contains the <paramref name="key" />.
            </summary>
      <param name="key">The key for which changes are to be observed.</param>
      <returns>
            An observable sequence of collection notifications for the specified <paramref name="key" />, starting with the current value if the dictionary 
            already contains the <paramref name="key" />.
            </returns>
      <ensures>Contract.Result&lt;IObservable&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Reactive.Subjects.IDictionarySubject`2.View(`0)" inheritedFromTypeName="IDictionarySubject">Contract.Result&lt;IObservable&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.Subscribe(System.IObserver{System.Reactive.CollectionNotification{System.Collections.Generic.KeyValuePair{`0,`1}}})">
      <summary>
            Notifies the subject that an observer is to receive collection notifications.
            </summary>
      <param name="observer">The object that is to receive collection notifications.</param>
      <returns>The observer's interface that enables resources to be disposed.</returns>
      <requires inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.OnNext(System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
            Changes the dictionary according to the specified collection modification.
            </summary>
      <param name="value">A modification that indicates how the dictionary must be changed.</param>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.OnError(System.Exception)">
      <summary>
            Terminates the subject with an error condition.
            </summary>
      <param name="error">An object that provides additional information about the error.</param>
      <requires inheritedFrom="M:System.IObserver`1.OnError(System.Exception)" inheritedFromTypeName="IObserver">error != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.OnCompleted">
      <summary>
            Notifies the subject to stop accepting collection modifications.
            </summary>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.TryGetValue(`0,`1@)">
      <summary>
            Gets the value associated with the specified <paramref name="key" />.
            </summary>
      <param name="key">The key whose value to get.</param>
      <param name="value">When this method returns, the value associated with the specified <paramref name="key" />, 
            if the key is found; otherwise, the default value for the type of the value parameter.</param>
      <returns>
        <see langword="True" /> if the dictionary contains an element with the specified <paramref name="key" />; otherwise, <see langword="false" />.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" inheritedFromTypeName="IDictionary">Contract.Result&lt;bool&gt;() == @this.ContainsKey(key)</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.ContainsKey(`0)">
      <summary>
            Determines whether the dictionary contains an element with the specified <paramref name="key" />.
            </summary>
      <param name="key">The key to locate in the dictionary.</param>
      <returns>
        <see langword="True" /> if the dictionary contains an element with the <paramref name="key" />; otherwise, <see langword="false" />.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" inheritedFromTypeName="IDictionary">!Contract.Result&lt;bool&gt;() || @this.Count &gt; 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.ContainsValue(`1)">
      <summary>
            Determines whether the dictionary contains a specific <paramref name="value" />.
            </summary>
      <param name="value">The value to locate in the dictionary.  The value can be <see langword="null" /> for reference types.</param>
      <returns>
        <see langword="True" /> if the dictionary contains an element with the specified <paramref name="value" />; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.Add(`0,`1)">
      <summary>
            Adds an element with the provided <paramref name="key" /> and <paramref name="value" /> to the dictionary.
            </summary>
      <param name="key">The object to use as the key of the element to add.</param>
      <param name="value">The object to use as the value of the element to add.</param>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.Remove(`0)">
      <summary>
            Removes the element with the specified <paramref name="key" /> from the dictionary.
            </summary>
      <param name="key">The key of the element to remove.</param>
      <returns>
        <see langword="True" /> if the element is successfully removed; otherwise, <see langword="false" />.
            This method also returns <see langword="false" /> if <paramref name="key" /> was not found in the dictionary.</returns>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.Clear">
      <summary>
            Removes all key/value pairs from the dictionary.
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection">this.Count == 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the key/value pairs in the dictionary.
            </summary>
      <remarks>
            The dictionary is locked for the entire duration while enumerating.  Any collection modifications that are received 
            during the enumeration will be blocked.  When the enumeration has completed, all previous modifications will be 
            allowed to acquire the lock and mutate the dictionary.  For this reason it is best to enumerate quickly.  For example, 
            you could call the <see cref="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" /> or <see cref="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" /> 
            extension method to take a snapshot of the dictionary, then perform work by enumerating the snapshot while the subject 
            is free to accept collection modifications.
            </remarks>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the dictionary.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.Dispose">
      <summary>
            Unsubscribes all observers and releases resources. 
            </summary>
    </member>
    <member name="P:System.Reactive.Subjects.DictionarySubject`2.Comparer">
      <summary>
            Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> that is used to determine equality of keys for the dictionary.
            </summary>
      <returns>The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> generic interface implementation that is used to determine 
            equality of keys for the current dictionary and to provide hash values for the keys.</returns>
      <getter>
        <ensures>Contract.Result&lt;IEqualityComparer&lt;TKey&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.DictionarySubject`2.Keys">
      <summary>
            Gets a collection containing a snapshot of the keys in the dictionary.
            </summary>
      <returns>A collection containing a snapshot of the keys in the dictionary.</returns>
      <getter>
        <ensures>Contract.Result&lt;ICollection&lt;TKey&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Keys" inheritedFromTypeName="IDictionary">Contract.Result&lt;ICollection&lt;TKey&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.DictionarySubject`2.Values">
      <summary>
            Gets a collection containing a snapshot of the values in the dictionary.
            </summary>
      <returns>A collection containing a snapshot of the values in the dictionary.</returns>
      <getter>
        <ensures>Contract.Result&lt;ICollection&lt;TValue&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Values" inheritedFromTypeName="IDictionary">Contract.Result&lt;ICollection&lt;TValue&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.DictionarySubject`2.Count">
      <summary>
            Gets the number of key/value pairs currently contained in the dictionary.
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.DictionarySubject`2.Item(`0)">
      <summary>
            Gets or sets the value associated with the specified <paramref name="key" />.
            </summary>
      <param name="key">The key of the value to get or set.</param>
      <returns>The value with the specified <paramref name="key" />.</returns>
    </member>
    <member name="E:System.Reactive.Subjects.DictionarySubject`2.CollectionChanged">
      <summary>
            Occurs when a value is added, removed, changed, moved, or the entire dictionary is refreshed.
            </summary>
    </member>
    <member name="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2">
      <summary>
            Provides a read-only wrapper around an <see cref="T:System.Reactive.Subjects.IDictionarySubject`2" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <threadsafety instance="true" />
      <invariant>subject != null</invariant>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.#ctor(System.Reactive.Subjects.IDictionarySubject{`0,`1})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> class.
            </summary>
      <param name="subject">The subject to be decorated with a read-only wrapper.</param>
      <requires>subject != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.View">
      <summary>
            Returns an observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </summary>
      <remarks>
        <alert type="tip">
            To create a synchronized clone or projection of this dictionary, simply call <c>dictionary.View().Collect(...)</c>.
            </alert>
      </remarks>
      <returns>
            An observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </returns>
      <ensures inheritedFrom="M:System.Reactive.Subjects.IDictionarySubject`2.View" inheritedFromTypeName="IDictionarySubject">Contract.Result&lt;IObservable&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.View(`0)">
      <summary>
            Returns an observable sequence of collection notifications for the specified <paramref name="key" />, starting with the current value if the dictionary 
            already contains the <paramref name="key" />.
            </summary>
      <param name="key">The key for which changes are to be observed.</param>
      <returns>
            An observable sequence of collection notifications for the specified <paramref name="key" />, starting with the current value if the dictionary 
            already contains the <paramref name="key" />.
            </returns>
      <ensures inheritedFrom="M:System.Reactive.Subjects.IDictionarySubject`2.View(`0)" inheritedFromTypeName="IDictionarySubject">Contract.Result&lt;IObservable&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Subscribe(System.IObserver{System.Reactive.CollectionNotification{System.Collections.Generic.KeyValuePair{`0,`1}}})">
      <summary>
            Notifies the subject that an observer is to receive collection notifications.
            </summary>
      <param name="observer">The object that is to receive collection notifications.</param>
      <returns>The observer's interface that enables resources to be disposed.</returns>
      <requires inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.OnNext(System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
            Changes the dictionary according to the specified collection modification.  This method is not supported.
            </summary>
      <param name="value">A modification that indicates how the dictionary must be changed.</param>
      <exception cref="T:System.NotSupportedException">Attempted to set an item in a read-only dictionary.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.OnError(System.Exception)">
      <summary>
            Terminates the subject with an error condition.  This method is not supported.
            </summary>
      <param name="error">An object that provides additional information about the error.</param>
      <exception cref="T:System.NotSupportedException">Attempted to set an item in a read-only dictionary.</exception>
      <requires inheritedFrom="M:System.IObserver`1.OnError(System.Exception)" inheritedFromTypeName="IObserver">error != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.OnCompleted">
      <summary>
            Notifies the subject to stop accepting collection modifications.  This method is not supported.
            </summary>
      <exception cref="T:System.NotSupportedException">Attempted to set an item in a read-only dictionary.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.TryGetValue(`0,`1@)">
      <summary>
            Gets the value associated with the specified <paramref name="key" />.
            </summary>
      <param name="key">The key whose value to get.</param>
      <param name="value">When this method returns, the value associated with the specified <paramref name="key" />, 
            if the key is found; otherwise, the default value for the type of the value parameter.</param>
      <returns>
        <see langword="True" /> if the dictionary contains an element with the specified <paramref name="key" />; otherwise, <see langword="false" />.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" inheritedFromTypeName="IDictionary">Contract.Result&lt;bool&gt;() == @this.ContainsKey(key)</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.ContainsKey(`0)">
      <summary>
            Determines whether the dictionary contains an element with the specified <paramref name="key" />.
            </summary>
      <param name="key">The key to locate in the dictionary.</param>
      <returns>
        <see langword="True" /> if the dictionary contains an element with the <paramref name="key" />; otherwise, <see langword="false" />.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" inheritedFromTypeName="IDictionary">!Contract.Result&lt;bool&gt;() || @this.Count &gt; 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Add(`0,`1)">
      <summary>
            Adds an element with the provided <paramref name="key" /> and <paramref name="value" /> to the dictionary.  This method is not supported.
            </summary>
      <param name="key">The object to use as the key of the element to add.</param>
      <param name="value">The object to use as the value of the element to add.</param>
      <exception cref="T:System.NotSupportedException">Attempted to set an item in a read-only dictionary.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Remove(`0)">
      <summary>
            Removes the element with the specified <paramref name="key" /> from the dictionary.  This method is not supported.
            </summary>
      <param name="key">The key of the element to remove.</param>
      <returns>
        <see langword="True" /> if the element is successfully removed; otherwise, <see langword="false" />.
            This method also returns <see langword="false" /> if <paramref name="key" /> was not found in the dictionary.</returns>
      <exception cref="T:System.NotSupportedException">Attempted to set an item in a read-only dictionary.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Clear">
      <summary>
            Removes all key/value pairs from the dictionary.  This method is not supported.
            </summary>
      <exception cref="T:System.NotSupportedException">Attempted to set an item in a read-only dictionary.</exception>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection">this.Count == 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the key/value pairs in the dictionary.
            </summary>
      <remarks>
            The dictionary is locked for the entire duration while enumerating.  Any collection modifications that are received 
            during the enumeration will be blocked.  When the enumeration has completed, all previous modifications will be 
            allowed to acquire the lock and mutate the dictionary.  For this reason it is best to enumerate quickly.  For example, 
            you could call the <see cref="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" /> or <see cref="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" /> 
            extension method to take a snapshot of the dictionary, then perform work by enumerating the snapshot while the subject 
            is free to accept collection modifications.
            </remarks>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the dictionary.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Dispose">
      <summary>
            Unsubscribes all observers and releases resources. 
            </summary>
    </member>
    <member name="P:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Keys">
      <summary>
            Gets a collection containing a snapshot of the keys in the dictionary.
            </summary>
      <returns>A collection containing a snapshot of the keys in the dictionary.</returns>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Keys" inheritedFromTypeName="IDictionary">Contract.Result&lt;ICollection&lt;TKey&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Values">
      <summary>
            Gets a collection containing a snapshot of the values in the dictionary.
            </summary>
      <returns>A collection containing a snapshot of the values in the dictionary.</returns>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Values" inheritedFromTypeName="IDictionary">Contract.Result&lt;ICollection&lt;TValue&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Count">
      <summary>
            Gets the number of key/value pairs currently contained in the dictionary.
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Item(`0)">
      <summary>
            Gets the value associated with the specified <paramref name="key" />.  Setting this property is not supported.
            </summary>
      <param name="key">The key of the value to get or set.</param>
      <returns>The value with the specified <paramref name="key" />.</returns>
      <exception cref="T:System.NotSupportedException">Attempted to set an item in a read-only dictionary.</exception>
    </member>
    <member name="E:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.CollectionChanged">
      <summary>
            Occurs when a value is added, removed, changed, moved, or the entire dictionary is refreshed.
            </summary>
    </member>
    <member name="T:System.Reactive.Subjects.IListSubject`1">
      <summary>
            Represents an object that is a list as well as an observable sequence of collection notifications and observer of collection modifications.
            </summary>
      <typeparam name="T">The type of the elements in the collection.</typeparam>
    </member>
    <member name="M:System.Reactive.Subjects.IListSubject`1.View">
      <summary>
            Returns an observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </summary>
      <remarks>
        <alert type="tip">
            To create a synchronized clone or projection of this list, simply call <c>list.View().Collect(...)</c>.
            </alert>
      </remarks>
      <returns>
            An observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </returns>
      <ensures>Contract.Result&lt;IObservable&lt;CollectionNotification&lt;T&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.Subjects.ReadOnlyListSubject`1">
      <summary>
            Provides a read-only wrapper around an <see cref="T:System.Reactive.Subjects.IListSubject`1" />.
            </summary>
      <typeparam name="T">The type of the elements in the collection.</typeparam>
      <threadsafety instance="true" />
      <invariant>subject != null</invariant>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.#ctor(System.Reactive.Subjects.IListSubject{`0})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> class.
            </summary>
      <param name="subject">The subject to be decorated with a read-only wrapper.</param>
      <requires>subject != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.View">
      <summary>
            Returns an observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </summary>
      <remarks>
        <alert type="tip">
            To create a synchronized clone or projection of this list, simply call <c>list.View().Collect(...)</c>.
            </alert>
      </remarks>
      <returns>
            An observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </returns>
      <ensures inheritedFrom="M:System.Reactive.Subjects.IListSubject`1.View" inheritedFromTypeName="IListSubject">Contract.Result&lt;IObservable&lt;CollectionNotification&lt;T&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.Subscribe(System.IObserver{System.Reactive.CollectionNotification{`0}})">
      <summary>
            Notifies the subject that an observer is to receive collection notifications.
            </summary>
      <param name="observer">The object that is to receive collection notifications.</param>
      <returns>The observer's interface that enables resources to be disposed.</returns>
      <requires inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.OnNext(System.Reactive.CollectionModification{`0})">
      <summary>
            Changes the list according to the specified collection modification.  This method is not supported.
            </summary>
      <param name="value">A modification that indicates how the list must be changed.</param>
      <exception cref="T:System.NotSupportedException">Attempted to modify a read-only list.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.OnError(System.Exception)">
      <summary>
            Terminates the subject with an error condition.  This method is not supported.
            </summary>
      <param name="error">An object that provides additional information about the error.</param>
      <exception cref="T:System.NotSupportedException">Attempted to modify a read-only list.</exception>
      <requires inheritedFrom="M:System.IObserver`1.OnError(System.Exception)" inheritedFromTypeName="IObserver">error != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.OnCompleted">
      <summary>
            Notifies the subject to stop accepting collection modifications.  This method is not supported.
            </summary>
      <exception cref="T:System.NotSupportedException">Attempted to modify a read-only list.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.Contains(`0)">
      <summary>
            Determines whether the list contains a specific value.
            </summary>
      <param name="item">The object to locate in the list.</param>
      <returns>
        <see langword="True" /> if <paramref name="item" /> is found in the list; otherwise, <see langword="false" /></returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection">!Contract.Result&lt;bool&gt;() || this.Count &gt; 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.IndexOf(`0)">
      <summary>
            Determines the index of a specific item in the list.
            </summary>
      <param name="item">The object to locate in the list.</param>
      <returns>The index of <paramref name="item" /> if found in the list; otherwise, -1.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList">Contract.Result&lt;int&gt;() &lt; @this.Count</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.Add(`0)">
      <summary>
            Adds an item to the list.  This method is not supported.
            </summary>
      <param name="item">The object to add to the list.</param>
      <exception cref="T:System.NotSupportedException">Attempted to modify a read-only list.</exception>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection">this.Count &gt;= Contract.OldValue(this.Count)</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.Insert(System.Int32,`0)">
      <summary>
            Inserts an item to the list at the specified index.  This method is not supported.
            </summary>
      <param name="index">The zero-based index at which item should be inserted.</param>
      <param name="item">The object to insert into the list.</param>
      <exception cref="T:System.NotSupportedException">Attempted to modify a read-only list.</exception>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList">index &lt;= @this.Count</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.Remove(`0)">
      <summary>
            Removes the first occurrence of a specific object from the list.  This method is not supported.
            </summary>
      <param name="item">The object to remove from the list.</param>
      <returns>
        <see langword="True" /> if <paramref name="item" /> was successfully removed from the list; otherwise, <see langword="false" />.
            This method also returns <see langword="false" /> if <paramref name="item" /> is not found in the list.</returns>
      <exception cref="T:System.NotSupportedException">Attempted to modify a read-only list.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.RemoveAt(System.Int32)">
      <summary>
            Removes the list item at the specified index.  This method is not supported.
            </summary>
      <param name="index">The zero-based index of the item to remove.</param>
      <exception cref="T:System.NotSupportedException">Attempted to modify a read-only list.</exception>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList">index &lt; @this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList">@this.Count == Contract.OldValue(@this.Count) - 1</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.Clear">
      <summary>
            Removes all items from the list.  This method is not supported.
            </summary>
      <exception cref="T:System.NotSupportedException">Attempted to modify a read-only list.</exception>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection">this.Count == 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the elements of the list to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from 
            the list. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
      <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex + this.Count  &lt;= array.Length</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the list.
            </summary>
      <remarks>
            The list is locked for the entire duration while enumerating.  Any collection modifications that are received 
            during the enumeration will be blocked.  When the enumeration has completed, all previous modifications will be 
            allowed to acquire the lock and mutate the list.  For this reason it is best to enumerate quickly.  For example, 
            you could call the <see cref="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" /> extension method to take a snapshot of the list, 
            then perform work by enumerating the snapshot while the subject is free to accept collection modifications.
            </remarks>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.Dispose">
      <summary>
            Unsubscribes all observers and releases resources. 
            </summary>
    </member>
    <member name="P:System.Reactive.Subjects.ReadOnlyListSubject`1.Count">
      <summary>
            Gets the number of elements currently contained in the list.
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.ReadOnlyListSubject`1.IsReadOnly">
      <summary>
            Gets a value indicating whether the list is read-only.
            </summary>
      <value>Always returns <see langword="true" />.</value>
    </member>
    <member name="P:System.Reactive.Subjects.ReadOnlyListSubject`1.Item(System.Int32)">
      <summary>
            Gets the element at the specified index.  Setting this property is not supported.
            </summary>
      <param name="index">The zero-based index of the element to get.</param>
      <returns>The element at the specified index.</returns>
      <exception cref="T:System.NotSupportedException">Attempted to set an item in a read-only list.</exception>
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList">index &lt; @this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList">index &lt; @this.Count</requires>
      </setter>
    </member>
    <member name="E:System.Reactive.Subjects.ReadOnlyListSubject`1.CollectionChanged">
      <summary>
            Occurs when an item is added, removed, changed, moved, or the entire list is refreshed.
            </summary>
    </member>
    <member name="T:System.Reactive.Subjects.ListSubject`1">
      <summary>
            Represents an object that is a list as well as an observable sequence of collection notifications and observer of collection modifications.
            </summary>
      <typeparam name="T">The type of the elements in the collection.</typeparam>
      <remarks>
        <para>
          <see cref="T:System.Reactive.Subjects.ListSubject`1" /> implements <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" /> and behaves similar to <see cref="T:System.Collections.ObjectModel.ObservableCollection`1" />, 
            so it can be bound directly to an <strong>ItemsPresenter</strong> or a derived type in WPF, Silverlight and Windows Phone.
            </para>
        <alert type="tip">
            The enumerator that is returned by <see cref="M:System.Reactive.Subjects.ListSubject`1.GetEnumerator" /> blocks all methods on the <see cref="T:System.Reactive.Subjects.ListSubject`1" />
            until the enumeration has completed.  For a snapshot behavior instead, simply call <see cref="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" />
            to collect the items as fast as possible and then enumerate the new list.
            </alert>
      </remarks>
      <threadsafety instance="true" />
      <invariant>gate != null</invariant>
      <invariant>subject != null</invariant>
      <invariant>list != null</invariant>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.ListSubject`1" /> class.
            </summary>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.ListSubject`1" /> class.
            </summary>
      <param name="collection">The sequence from which the elements are copied.</param>
      <requires>collection != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.#ctor(System.Collections.Generic.List{`0})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.ListSubject`1" /> class.
            </summary>
      <param name="list">The list from which the elements are copied.</param>
      <requires>list != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.View">
      <summary>
            Returns an observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </summary>
      <remarks>
        <alert type="tip">
            To create a synchronized clone or projection of this list, simply call <c>list.View().Collect(...)</c>.
            </alert>
      </remarks>
      <returns>
            An observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </returns>
      <ensures inheritedFrom="M:System.Reactive.Subjects.IListSubject`1.View" inheritedFromTypeName="IListSubject">Contract.Result&lt;IObservable&lt;CollectionNotification&lt;T&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.Subscribe(System.IObserver{System.Reactive.CollectionNotification{`0}})">
      <summary>
            Notifies the subject that an observer is to receive collection notifications.
            </summary>
      <param name="observer">The object that is to receive collection notifications.</param>
      <returns>The observer's interface that enables resources to be disposed.</returns>
      <requires inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.OnNext(System.Reactive.CollectionModification{`0})">
      <summary>
            Changes the list according to the specified collection notification.
            </summary>
      <param name="value">A modification that indicates how the list must be changed.</param>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.OnError(System.Exception)">
      <summary>
            Terminates the subject with an error condition.
            </summary>
      <param name="error">An object that provides additional information about the error.</param>
      <requires inheritedFrom="M:System.IObserver`1.OnError(System.Exception)" inheritedFromTypeName="IObserver">error != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.OnCompleted">
      <summary>
            Notifies the subject to stop accepting collection modifications.
            </summary>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.Contains(`0)">
      <summary>
            Determines whether the list contains a specific value.
            </summary>
      <param name="item">The object to locate in the list.</param>
      <returns>
        <see langword="True" /> if <paramref name="item" /> is found in the list; otherwise, <see langword="false" /></returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection">!Contract.Result&lt;bool&gt;() || this.Count &gt; 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.IndexOf(`0)">
      <summary>
            Determines the index of a specific item in the list.
            </summary>
      <param name="item">The object to locate in the list.</param>
      <returns>The index of <paramref name="item" /> if found in the list; otherwise, -1.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList">Contract.Result&lt;int&gt;() &lt; @this.Count</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.Add(`0)">
      <summary>
            Adds an item to the list.
            </summary>
      <param name="item">The object to add to the list.</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection">this.Count &gt;= Contract.OldValue(this.Count)</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.Insert(System.Int32,`0)">
      <summary>
            Inserts an item to the list at the specified index.
            </summary>
      <param name="index">The zero-based index at which item should be inserted.</param>
      <param name="item">The object to insert into the list.</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList">index &lt;= @this.Count</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.Move(System.Int32,System.Int32)">
      <summary>
            Moves the item at the specified index to a new location in the list.
            </summary>
      <param name="oldIndex">The zero-based index specifying the location of the item to be moved.</param>
      <param name="newIndex">The zero-based index specifying the new location of the item.</param>
      <requires>oldIndex &gt;= 0</requires>
      <requires>newIndex &gt;= 0</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.Remove(`0)">
      <summary>
            Removes the first occurrence of a specific object from the list.
            </summary>
      <param name="item">The object to remove from the list.</param>
      <returns>
        <see langword="True" /> if <paramref name="item" /> was successfully removed from the list; otherwise, <see langword="false" />.
            This method also returns <see langword="false" /> if <paramref name="item" /> is not found in the list.</returns>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.RemoveAt(System.Int32)">
      <summary>
            Removes the list item at the specified index.
            </summary>
      <param name="index">The zero-based index of the item to remove.</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList">index &lt; @this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList">@this.Count == Contract.OldValue(@this.Count) - 1</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.Clear">
      <summary>
            Removes all items from the list.
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection">this.Count == 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the elements of the list to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from 
            the list. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
      <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex + this.Count  &lt;= array.Length</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the list.
            </summary>
      <remarks>
            The list is locked for the entire duration while enumerating.  Any collection modifications that are received 
            during the enumeration will be blocked.  When the enumeration has completed, all previous modifications will be 
            allowed to acquire the lock and mutate the list.  For this reason it is best to enumerate quickly.  For example, 
            you could call the <see cref="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" /> extension method to take a snapshot of the list, 
            then perform work by enumerating the snapshot while the subject is free to accept collection modifications.
            </remarks>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.Dispose">
      <summary>
            Unsubscribes all observers and releases resources. 
            </summary>
    </member>
    <member name="P:System.Reactive.Subjects.ListSubject`1.Count">
      <summary>
            Gets the number of elements currently contained in the list.
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.ListSubject`1.IsReadOnly">
      <summary>
            Gets a value indicating whether the list is read-only.
            </summary>
      <value>Always returns <see langword="false" />.</value>
    </member>
    <member name="P:System.Reactive.Subjects.ListSubject`1.Item(System.Int32)">
      <summary>
            Gets or sets the element at the specified index.
            </summary>
      <param name="index">The zero-based index of the element to get or set.</param>
      <returns>The element at the specified index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the list.</exception>
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList">index &lt; @this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList">index &lt; @this.Count</requires>
      </setter>
    </member>
    <member name="E:System.Reactive.Subjects.ListSubject`1.CollectionChanged">
      <summary>
            Occurs when an item is added, removed, changed, moved, or the entire list is refreshed.
            </summary>
    </member>
    <member name="T:System.Reactive.Disposables.SerialDisposableExtensions">
      <summary>
            Provides extension methods for <see cref="T:System.Reactive.Disposables.SerialDisposable" />.
            </summary>
    </member>
    <member name="M:System.Reactive.Disposables.SerialDisposableExtensions.SetDisposableIndirectly(System.Reactive.Disposables.SerialDisposable,System.Func{System.IDisposable})">
      <summary>
            Uses the double-indirection pattern to assign the disposable returned by the specified <paramref name="factory" />
            to the <see cref="P:System.Reactive.Disposables.SerialDisposable.Disposable" /> property of the specified <paramref name="disposable" />.
            </summary>
      <remarks>
            The double-indirection pattern avoids a race condition that can occur when the <paramref name="factory" /> 
            has a side-effect that causes the <see cref="P:System.Reactive.Disposables.SerialDisposable.Disposable" /> property of the specified 
            <paramref name="disposable" /> to be assigned before the <paramref name="factory" /> returns its disposable.
            This pattern ensures that the disposable returned by the <paramref name="factory" /> does not replace the 
            disposable that was assigned by the <paramref name="factory" />.
            </remarks>
      <param name="disposable">The object to which the disposable returned by the specified <paramref name="factory" /> is assigned.</param>
      <param name="factory">Returns an <see cref="T:System.IDisposable" /> that is assigned to the specified <paramref name="disposable" />.</param>
      <seealso href="http://social.msdn.microsoft.com/Forums/en-IE/rx/thread/4e15feae-9c4c-4962-af32-95dde1420dda#4d5fe8c8-e5e8-4ee7-93ca-b48b6a56b8af">
            Double indirection pattern example in Rx
            </seealso>
      <requires>disposable != null</requires>
      <requires>factory != null</requires>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionExtensions">
      <summary>
            Provides extension methods for <see cref="T:System.Linq.Expressions.Expression`1" /> objects.
            </summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionExtensions.GetPropertyInfo``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>
            Gets property information for the specified <paramref name="property" /> expression.
            </summary>
      <typeparam name="TSource">Type of the parameter in the <paramref name="property" /> expression.</typeparam>
      <typeparam name="TValue">Type of the property's value.</typeparam>
      <param name="property">The expression from which to retrieve the property information.</param>
      <returns>Property information for the specified expression.</returns>
      <exception cref="T:System.ArgumentException">The expression is not understood.</exception>
      <requires>property != null</requires>
      <ensures>Contract.Result&lt;PropertyInfo&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionExtensions.GetPropertyInfo``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Object@)">
      <summary>
            Gets property information for the specified <paramref name="property" /> expression.
            </summary>
      <typeparam name="TValue">Type of the property's value.</typeparam>
      <param name="property">The expression from which to retrieve the property information.</param>
      <param name="owner">Instance of the object that defines the specified property.</param>
      <returns>Property information for the specified expression.</returns>
      <exception cref="T:System.ArgumentException">The expression is too complex or is not understood.</exception>
      <exception cref="T:System.ArgumentException">The expression does not represent a chain of one or more fields and properties, ending with a property.</exception>
      <exception cref="T:System.ArgumentException">The expression contains an indexer.</exception>
      <exception cref="T:System.ArgumentException">The owner cannot be determined from the expression.</exception>
      <requires>property != null</requires>
      <ensures>Contract.Result&lt;PropertyInfo&gt;() != null</ensures>
      <ensures>Contract.ValueAtReturn(out owner) != null</ensures>
    </member>
    <member name="T:System.ObservableDynamicObject">
      <summary>
            Wraps an object with a dynamic wrapper that converts normal properties, methods and events into observable sequences.
            </summary>
      <remarks>
        <para>
            Methods are converted to asynchronous invocations much like <see cref="M:System.Reactive.Linq.Observable.Start(System.Action)" /> and <see cref="M:System.Reactive.Linq.Observable.Start``1(System.Func{``0})" />.
            </para>
        <para>
            Properties are converted to observable sequences of property changed notifications.
            </para>
        <para>
            Events are converted to observable sequences of <see cref="T:System.Reactive.EventPattern`1" />, with strong-typed <see cref="T:System.EventArgs" />.
            </para>
      </remarks>
      <invariant>source != null</invariant>
    </member>
    <member name="M:System.ObservableDynamicObject.Create(System.Object)">
      <summary>
            Wraps the specified object with a <see langword="dynamic" /> wrapper implemented by <see cref="T:System.ObservableDynamicObject" />.
            </summary>
      <param name="source">The object to be wrapped.</param>
      <returns>The specified <paramref name="source" /> as a <see langword="dynamic" /> object.</returns>
      <requires>source != null</requires>
    </member>
    <member name="M:System.ObservableDynamicObject.GetDynamicMemberNames">
      <summary>
            Gets the names of the dynamic members.
            </summary>
      <returns>Sequence of dynamic member names.</returns>
      <ensures>Contract.Result&lt;IEnumerable&lt;string&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Dynamic.DynamicObject.GetDynamicMemberNames" inheritedFromTypeName="DynamicObject">Contract.Result&lt;IEnumerable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ObservableDynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
      <summary>
            Tries to invoke the specified member.
            </summary>
      <param name="binder">The binder.</param>
      <param name="args">The member's arguments.</param>
      <param name="result">The result, if any.</param>
      <returns>
        <see langword="true" /> if the member is invoked; otherwise, <see langword="false" />.</returns>
      <ensures>!Contract.Result&lt;bool&gt;() || Contract.ValueAtReturn(out result) != null</ensures>
    </member>
    <member name="M:System.ObservableDynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
      <summary>
            Tries to set the specified member to the specified <paramref name="value" />.
            </summary>
      <param name="binder">The binder.</param>
      <param name="value">The value to be set.</param>
      <returns>
        <see langword="true" /> if the member is set; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.ObservableDynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
      <summary>
            Tries to get a value from the specified member.
            </summary>
      <param name="binder">The binder.</param>
      <param name="result">The value that was retrieved from the member.</param>
      <returns>
        <see langword="true" /> if the <paramref name="result" /> is retrieved; otherwise, <see langword="false" />.</returns>
      <ensures>!Contract.Result&lt;bool&gt;() || Contract.ValueAtReturn(out result) != null</ensures>
    </member>
    <member name="T:System.Linq.OperationalEnumerable">
      <summary>
            Provides extension methods that convert an <see cref="T:System.Collections.Generic.IEnumerable`1" /> into an <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.
            </summary>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.SByte})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.SByte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.Collections.Generic.IEnumerable{System.SByte},System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.SByte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.Collections.Generic.IEnumerable{System.SByte},System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.SByte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Byte})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Collections.Generic.IEnumerable{System.Byte},System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Collections.Generic.IEnumerable{System.Byte},System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Char})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Collections.Generic.IEnumerable{System.Char},System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Collections.Generic.IEnumerable{System.Char},System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int16})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Collections.Generic.IEnumerable{System.Int16},System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Collections.Generic.IEnumerable{System.Int16},System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt16})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.Collections.Generic.IEnumerable{System.UInt16},System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.Collections.Generic.IEnumerable{System.UInt16},System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int32" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int32" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt32})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt32" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt32},System.Func{System.Collections.Generic.IEnumerable{System.UInt32},System.Collections.Generic.IEnumerable{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32},System.Collections.Generic.IEnumerable{System.UInt32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt32" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int64" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int64},System.Func{System.Collections.Generic.IEnumerable{System.Int64},System.Collections.Generic.IEnumerable{System.Int64},System.Func{System.Int64,System.Int64,System.Int64},System.Collections.Generic.IEnumerable{System.Int64}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int64" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt64})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt64" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt64},System.Func{System.Collections.Generic.IEnumerable{System.UInt64},System.Collections.Generic.IEnumerable{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64},System.Collections.Generic.IEnumerable{System.UInt64}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt64" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Single})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Single" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Single},System.Func{System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Single},System.Func{System.Single,System.Single,System.Single},System.Collections.Generic.IEnumerable{System.Single}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Single" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Double" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Double},System.Func{System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Func{System.Double,System.Double,System.Double},System.Collections.Generic.IEnumerable{System.Double}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Double" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Decimal})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Decimal" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Decimal},System.Func{System.Collections.Generic.IEnumerable{System.Decimal},System.Collections.Generic.IEnumerable{System.Decimal},System.Func{System.Decimal,System.Decimal,System.Decimal},System.Collections.Generic.IEnumerable{System.Decimal}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Decimal" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0},System.Collections.Generic.IEnumerable{``0}},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0},System.Func{``0,``0})">
      <summary>
            Creates an <see cref="T:System.Collections.Generic.OperationalEnumerable`1" /> for the specified <paramref name="source" /> from the specified operators.
            </summary>
      <typeparam name="T">The type of objects to enumerate.</typeparam>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="add">The addition operator.</param>
      <param name="subtract">The subtraction operator.</param>
      <param name="multiply">The multiplication operator.</param>
      <param name="divide">The division operator.</param>
      <param name="positive">The plus operator.</param>
      <param name="negative">The negation operator.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`1" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational``2(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.OperationalEnumerable{``1}},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``1},System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``1},System.Func{``0,``1})">
      <summary>
            Creates an <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <paramref name="source" /> from the specified operators.
            </summary>
      <typeparam name="TIn">The type of input to enumerate.</typeparam>
      <typeparam name="TOut">The type of output that each operation generates.</typeparam>
      <param name="source">The enumerable to be converted.</param>
      <param name="resultSelector">Projects the result sequence into an <see cref="T:System.Collections.Generic.OperationalEnumerable`1" />.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="add">The addition operator.</param>
      <param name="subtract">The subtraction operator.</param>
      <param name="multiply">The multiplication operator.</param>
      <param name="divide">The division operator.</param>
      <param name="positive">The plus operator.</param>
      <param name="negative">The negation operator.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TIn, TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Collections.Generic.OperationalEnumerable`1">
      <summary>
            Represents an enumerable that uses its unary and binary operator overloads as query operators.
            </summary>
      <typeparam name="T">Input and output type.</typeparam>
    </member>
    <member name="T:System.Collections.Generic.OperationalEnumerable`2">
      <summary>
            Represents an enumerable that uses its unary and binary operator overloads as query operators.
            </summary>
      <typeparam name="TIn">Input type.</typeparam>
      <typeparam name="TOut">Output type.</typeparam>
      <invariant>source != null</invariant>
      <invariant>resultSelector != null</invariant>
      <invariant>binaryOperation != null</invariant>
      <invariant>add != null</invariant>
      <invariant>subtract != null</invariant>
      <invariant>multiply != null</invariant>
      <invariant>divide != null</invariant>
      <invariant>positive != null</invariant>
      <invariant>negative != null</invariant>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Addition(System.Collections.Generic.OperationalEnumerable{`0,`1},System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that adds the values in the specified enumerables 
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first enumerable.</param>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Add(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that adds the values in this enumerable to the values in the specified enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Addition(System.Collections.Generic.OperationalEnumerable{`0,`1},`0)">
      <summary>
            Creates a new operational enumerable that adds the values in the specified enumerable to the specified value
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The enumerable.</param>
      <param name="second">A value that is added to each value in the <paramref name="first" /> enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Add(`0)">
      <summary>
            Creates a new operational enumerable that adds the values in this enumerable to the specified value.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is added to each value in this enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Subtraction(System.Collections.Generic.OperationalEnumerable{`0,`1},System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that subtracts the values in the specified enumerables 
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first enumerable.</param>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Subtract(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that subtracts the values in the specified enumerable from the values in this enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Subtraction(System.Collections.Generic.OperationalEnumerable{`0,`1},`0)">
      <summary>
            Creates a new operational enumerable that subtracts the specified value from the values in the specified enumerable
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The enumerable.</param>
      <param name="second">A value that is subtracted from each value in the <paramref name="first" /> enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Subtract(`0)">
      <summary>
            Creates a new operational enumerable that subtracts the specified value from the values in this enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is subtracted from each value in this enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Multiply(System.Collections.Generic.OperationalEnumerable{`0,`1},System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that multiplies the values in the specified enumerables 
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first enumerable.</param>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Multiply(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that multiplies the values in this enumerable by the values in the specified enumerable.
            </summary>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Multiply(System.Collections.Generic.OperationalEnumerable{`0,`1},`0)">
      <summary>
            Creates a new operational enumerable that multiplies the values in the specified enumerable by the specified value
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The enumerable.</param>
      <param name="second">A value that is multiplied against each value in the <paramref name="first" /> enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Multiply(`0)">
      <summary>
            Creates a new operational enumerable that multiplies the values in this enumerable by the specified <paramref name="value" />.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is multiplied against each value in this enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Division(System.Collections.Generic.OperationalEnumerable{`0,`1},System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that divides the values in the specified enumerables 
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first enumerable.</param>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Divide(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that divides the values in this enumerable by the values in the specified enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Division(System.Collections.Generic.OperationalEnumerable{`0,`1},`0)">
      <summary>
            Creates a new operational enumerable that divides the values in the specified enumerable by the specified value
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The enumerable.</param>
      <param name="second">A value that divides each value in the <paramref name="first" /> enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Divide(`0)">
      <summary>
            Creates a new operational enumerable that divides the values in this enumerable by the specified <paramref name="value" />.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that divides each value in this enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_UnaryPlus(System.Collections.Generic.OperationalEnumerable{`0,`1})">
      <summary>
            Creates a new operational enumerable that ensures the sign of the specified enumerable's values are positive.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="enumerable">The enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>enumerable != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Plus">
      <summary>
            Creates a new operational enumerable that ensures the sign of this enumerable's values are positive.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_UnaryNegation(System.Collections.Generic.OperationalEnumerable{`0,`1})">
      <summary>
            Creates a new operational enumerable that ensures the sign of the specified enumerable's values are negative.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="enumerable">The enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>enumerable != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Negate">
      <summary>
            Creates a new operational enumerable that ensures the sign of this enumerable's values are negative.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.OperationalObservable`1">
      <summary>
            Represents an observable that uses its unary and binary operator overloads as observable query operators.
            </summary>
      <typeparam name="T">Input and output type.</typeparam>
    </member>
    <member name="T:System.Reactive.OperationalObservable`2">
      <summary>
            Represents an observable that uses its unary and binary operator overloads as observable query operators.
            </summary>
      <typeparam name="TIn">Input type.</typeparam>
      <typeparam name="TOut">Output type.</typeparam>
      <invariant>source != null</invariant>
      <invariant>resultSelector != null</invariant>
      <invariant>binaryOperation != null</invariant>
      <invariant>add != null</invariant>
      <invariant>subtract != null</invariant>
      <invariant>multiply != null</invariant>
      <invariant>divide != null</invariant>
      <invariant>positive != null</invariant>
      <invariant>negative != null</invariant>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Subscribe(System.IObserver{`0})">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <param name="observer">The object that is to receive notifications.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
      <requires inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Addition(System.Reactive.OperationalObservable{`0,`1},System.IObservable{`0})">
      <summary>
            Creates a new operational observable that adds the values in the specified observables 
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first observable.</param>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Add(System.IObservable{`0})">
      <summary>
            Creates a new operational observable that adds the values in this observable to the values in the specified observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Addition(System.Reactive.OperationalObservable{`0,`1},`0)">
      <summary>
            Creates a new operational observable that adds the values in the specified observable to the specified value
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The observable.</param>
      <param name="second">A value that is added to each value in the <paramref name="first" /> observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Add(`0)">
      <summary>
            Creates a new operational observable that adds the values in this observable to the specified <paramref name="value" />.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is added to each value in this observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Subtraction(System.Reactive.OperationalObservable{`0,`1},System.IObservable{`0})">
      <summary>
            Creates a new operational observable that subtracts the values in the specified observables 
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first observable.</param>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Subtract(System.IObservable{`0})">
      <summary>
            Creates a new operational observable that subtracts the values in the specified observable from the values in this observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Subtraction(System.Reactive.OperationalObservable{`0,`1},`0)">
      <summary>
            Creates a new operational observable that subtracts the specified value from the values in the specified observable
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The observable.</param>
      <param name="second">A value that is subtracted from each value in the <paramref name="first" /> observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Subtract(`0)">
      <summary>
            Creates a new operational observable that subtracts the specified value from the values in this observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is subtracted from each value in this observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Multiply(System.Reactive.OperationalObservable{`0,`1},System.IObservable{`0})">
      <summary>
            Creates a new operational observable that multiplies the values in the specified observables 
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first observable.</param>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Multiply(System.IObservable{`0})">
      <summary>
            Creates a new operational observable that multiplies the values in this observable with the values in the specified observable.
            </summary>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Multiply(System.Reactive.OperationalObservable{`0,`1},`0)">
      <summary>
            Creates a new operational observable that multiplies the values in the specified observable by the specified value
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The observable.</param>
      <param name="second">A value that is multiplied against each value in the <paramref name="first" /> observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Multiply(`0)">
      <summary>
            Creates a new operational observable that multiplies the values in the specified observable by the specified <paramref name="value" />.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is multiplied against each value in this observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Division(System.Reactive.OperationalObservable{`0,`1},System.IObservable{`0})">
      <summary>
            Creates a new operational observable that divides the values in the specified observables 
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first observable.</param>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Divide(System.IObservable{`0})">
      <summary>
            Creates a new operational observable that divides the values in this observable with the values in the specified observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Division(System.Reactive.OperationalObservable{`0,`1},`0)">
      <summary>
            Creates a new operational observable that divides the values in the specified observable by the specified value
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The observable.</param>
      <param name="second">A value that divides each value in the <paramref name="first" /> observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Divide(`0)">
      <summary>
            Creates a new operational observable that divides the values in this observable by the specified <paramref name="value" />.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that divides each value in this observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_UnaryPlus(System.Reactive.OperationalObservable{`0,`1})">
      <summary>
            Creates a new operational observable that ensures the sign of the specified observable's values are positive.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="observable">The observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>observable != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Plus">
      <summary>
            Creates a new operational observable that ensures the sign of this observable's values are positive.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_UnaryNegation(System.Reactive.OperationalObservable{`0,`1})">
      <summary>
            Creates a new operational observable that ensures the sign of the specified observable's values are negative.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="observable">The observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>observable != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Negate">
      <summary>
            Creates a new operational observable that ensures the sign of this observable's values are negative.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.Linq.OperationalObservable">
      <summary>
            Provides extension methods that convert an <see cref="T:System.IObservable`1" /> into an <see cref="T:System.Reactive.OperationalObservable`2" />.
            </summary>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.SByte})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.SByte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.SByte},System.Func{System.IObservable{System.SByte},System.IObservable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.SByte},System.Func{System.IObservable{System.SByte},System.IObservable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.SByte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Reactive.OperationalObservable`2" />.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Byte})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Byte},System.Func{System.IObservable{System.Byte},System.IObservable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Byte},System.Func{System.IObservable{System.Byte},System.IObservable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Reactive.OperationalObservable`2" />.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Char})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Char},System.Func{System.IObservable{System.Char},System.IObservable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Char},System.Func{System.IObservable{System.Char},System.IObservable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Reactive.OperationalObservable`2" />.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int16})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int16},System.Func{System.IObservable{System.Int16},System.IObservable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int16},System.Func{System.IObservable{System.Int16},System.IObservable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Reactive.OperationalObservable`2" />.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt16})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt16},System.Func{System.IObservable{System.UInt16},System.IObservable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt16},System.Func{System.IObservable{System.UInt16},System.IObservable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Reactive.OperationalObservable`2" />.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int32" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int32" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt32})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt32" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt32},System.Func{System.IObservable{System.UInt32},System.IObservable{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32},System.IObservable{System.UInt32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt32" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int64})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int64" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int64},System.Func{System.IObservable{System.Int64},System.IObservable{System.Int64},System.Func{System.Int64,System.Int64,System.Int64},System.IObservable{System.Int64}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int64" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt64})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt64" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt64},System.Func{System.IObservable{System.UInt64},System.IObservable{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64},System.IObservable{System.UInt64}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt64" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Single})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Single" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Single},System.Func{System.IObservable{System.Single},System.IObservable{System.Single},System.Func{System.Single,System.Single,System.Single},System.IObservable{System.Single}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Single" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Double})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Double" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Double},System.Func{System.IObservable{System.Double},System.IObservable{System.Double},System.Func{System.Double,System.Double,System.Double},System.IObservable{System.Double}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Double" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Decimal})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Decimal" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Decimal},System.Func{System.IObservable{System.Decimal},System.IObservable{System.Decimal},System.Func{System.Decimal,System.Decimal,System.Decimal},System.IObservable{System.Decimal}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Decimal" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational``1(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``0},System.Func{``0,``0,``0},System.IObservable{``0}},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0},System.Func{``0,``0})">
      <summary>
            Creates an <see cref="T:System.Reactive.OperationalObservable`1" /> for the specified <paramref name="source" /> from the specified operators.
            </summary>
      <typeparam name="T">The type of objects to observe.</typeparam>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="add">The addition operator.</param>
      <param name="subtract">The subtraction operator.</param>
      <param name="multiply">The multiplication operator.</param>
      <param name="divide">The division operator.</param>
      <param name="positive">The plus operator.</param>
      <param name="negative">The negation operator.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`1" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational``2(System.IObservable{``0},System.Func{System.IObservable{``1},System.Reactive.OperationalObservable{``1}},System.Func{System.IObservable{``0},System.IObservable{``0},System.Func{``0,``0,``1},System.IObservable{``1}},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``1},System.Func{``0,``1})">
      <summary>
            Creates an <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <paramref name="source" /> from the specified operators.
            </summary>
      <typeparam name="TIn">The type of input to observe.</typeparam>
      <typeparam name="TOut">The type of output that each operation generates.</typeparam>
      <param name="source">The observable to be converted.</param>
      <param name="resultSelector">Projects the result sequence into an <see cref="T:System.Reactive.OperationalObservable`1" />.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="add">The addition operator.</param>
      <param name="subtract">The subtraction operator.</param>
      <param name="multiply">The multiplication operator.</param>
      <param name="divide">The division operator.</param>
      <param name="positive">The plus operator.</param>
      <param name="negative">The negation operator.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TIn, TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Linq.TraceEnumerableExtensions">
      <summary>
            Provides extension methods that trace enumerables.
            </summary>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentity``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns an enumerable that traces OnNext, OnError and OnCompleted calls from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <returns>An enumerable that traces all notifications.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentity``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Returns an enumerable that traces OnNext, OnError and OnCompleted calls from the specified enumerable
            and includes the specified <paramref name="identity" /> in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <param name="identity">Identifies the observer in the trace output.</param>
      <returns>An enumerable that traces all notifications.</returns>
      <requires>source != null</requires>
      <requires>!string.IsNullOrWhiteSpace(identity)</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnNext``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns an enumerable that traces OnNext calls from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <returns>An enumerable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnNext``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Returns an enumerable that traces OnNext calls from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <param name="format">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <returns>An enumerable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>format != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnNext``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.String,``0,System.String})">
      <summary>
            Returns an enumerable that traces OnNext calls from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <param name="messageSelector">A function that returns the message to be traced for each notification.</param>
      <returns>An enumerable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnError``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns an enumerable that traces a call to OnError from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the error will be traced.</param>
      <returns>An enumerable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnError``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Returns an enumerable that traces a call to OnError from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the error will be traced.</param>
      <param name="format">The format in which the error will be traced.  A single replacement token {0} is supported.</param>
      <returns>An enumerable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>format != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnError``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.String,System.Exception,System.String})">
      <summary>
            Returns an enumerable that traces a call to OnError from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the error will be traced.</param>
      <param name="messageSelector">A function that returns the message to be traced for the error.</param>
      <returns>An enumerable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnCompleted``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns an enumerable that traces a call to OnCompleted from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the completed notification will be traced.</param>
      <returns>An enumerable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnCompleted``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Returns an enumerable that traces a call to OnCompleted from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the completed notification will be traced.</param>
      <param name="message">The message to be traced for the completed notification.</param>
      <returns>An enumerable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>message != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnCompleted``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.String,System.String})">
      <summary>
            Returns an enumerable that traces a call to OnCompleted from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the completed notification will be traced.</param>
      <param name="messageSelector">A function that returns the message to be traced for the completed notification.</param>
      <returns>An enumerable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentity``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource)">
      <summary>
            Returns an enumerable that traces OnNext, OnError and OnCompleted calls from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <returns>An enumerable that traces all notifications.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentity``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource,System.String)">
      <summary>
            Returns an enumerable that traces OnNext, OnError and OnCompleted calls from the specified enumerable
            and includes the specified <paramref name="identity" /> in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="identity">Identifies the observer in the trace output.</param>
      <returns>An enumerable that traces all notifications.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>!string.IsNullOrWhiteSpace(identity)</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnNext``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource)">
      <summary>
            Returns an enumerable that traces OnNext calls from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <returns>An enumerable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnNext``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource,System.String)">
      <summary>
            Returns an enumerable that traces OnNext calls from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="format">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <returns>An enumerable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>format != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnNext``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource,System.Func{System.String,``0,System.String})">
      <summary>
            Returns an enumerable that traces OnNext calls from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="messageSelector">A function that returns the message to be traced for each notification.</param>
      <returns>An enumerable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnError``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource)">
      <summary>
            Returns an enumerable that traces a call to OnError from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the error will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <returns>An enumerable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnError``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource,System.String)">
      <summary>
            Returns an enumerable that traces a call to OnError from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the error will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="format">The format in which the error will be traced.  A single replacement token {0} is supported.</param>
      <returns>An enumerable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>format != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnError``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource,System.Func{System.String,System.Exception,System.String})">
      <summary>
            Returns an enumerable that traces a call to OnError from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the error will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="messageSelector">A function that returns the message to be traced for the error.</param>
      <returns>An enumerable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnCompleted``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource)">
      <summary>
            Returns an enumerable that traces a call to OnCompleted from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the completed notification will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <returns>An enumerable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnCompleted``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource,System.String)">
      <summary>
            Returns an enumerable that traces a call to OnCompleted from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the completed notification will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="message">The message to be traced for the completed notification.</param>
      <returns>An enumerable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>message != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceIdentityOnCompleted``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource,System.Func{System.String,System.String})">
      <summary>
            Returns an enumerable that traces a call to OnCompleted from the specified enumerable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the completed notification will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="messageSelector">A function that returns the message to be traced for the completed notification.</param>
      <returns>An enumerable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.Trace``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns an enumerable that traces OnNext, OnError and OnCompleted calls from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <returns>An enumerable that traces all notifications.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnNext``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns an enumerable that traces OnNext calls from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <returns>An enumerable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnNext``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Returns an enumerable that traces OnNext calls from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <param name="format">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <returns>An enumerable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>format != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnNext``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String})">
      <summary>
            Returns an enumerable that traces OnNext calls from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <param name="messageSelector">A function that returns the message to be traced for each notification.</param>
      <returns>An enumerable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnError``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns an enumerable that traces a call to OnError from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the error will be traced.</param>
      <returns>An enumerable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnError``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Returns an enumerable that traces a call to OnError from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the error will be traced.</param>
      <param name="format">The format in which the error will be traced.  A single replacement token {0} is supported.</param>
      <returns>An enumerable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>format != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnError``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Exception,System.String})">
      <summary>
            Returns an enumerable that traces a call to OnError from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the error will be traced.</param>
      <param name="messageSelector">A function that returns the message to be traced for the error.</param>
      <returns>An enumerable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnCompleted``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns an enumerable that traces a call to OnCompleted from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the completed notification will be traced.</param>
      <returns>An enumerable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnCompleted``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Returns an enumerable that traces a call to OnCompleted from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the completed notification will be traced.</param>
      <param name="message">The message to be traced for the completed notification.</param>
      <returns>An enumerable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>message != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnCompleted``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.String})">
      <summary>
            Returns an enumerable that traces a call to OnCompleted from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the completed notification will be traced.</param>
      <param name="messageSelector">A function that returns the message to be traced for the completed notification.</param>
      <returns>An enumerable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.Trace``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource)">
      <summary>
            Returns an enumerable that traces OnNext, OnError and OnCompleted calls from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <param name="traceSource">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <returns>An enumerable that traces all notifications.</returns>
      <requires>source != null</requires>
      <requires>traceSource != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnNext``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource)">
      <summary>
            Returns an enumerable that traces OnNext calls from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <returns>An enumerable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnNext``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource,System.String)">
      <summary>
            Returns an enumerable that traces OnNext calls from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="format">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <returns>An enumerable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>format != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnNext``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource,System.Func{``0,System.String})">
      <summary>
            Returns an enumerable that traces OnNext calls from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which notifications will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="messageSelector">A function that returns the message to be traced for each notification.</param>
      <returns>An enumerable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnError``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource)">
      <summary>
            Returns an enumerable that traces a call to OnError from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the error will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <returns>An enumerable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnError``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource,System.String)">
      <summary>
            Returns an enumerable that traces a call to OnError from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the error will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="format">The format in which the error will be traced.  A single replacement token {0} is supported.</param>
      <returns>An enumerable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>format != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnError``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource,System.Func{System.Exception,System.String})">
      <summary>
            Returns an enumerable that traces a call to OnError from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the error will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="messageSelector">A function that returns the message to be traced for the error.</param>
      <returns>An enumerable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnCompleted``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource)">
      <summary>
            Returns an enumerable that traces a call to OnCompleted from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the completed notification will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <returns>An enumerable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnCompleted``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource,System.String)">
      <summary>
            Returns an enumerable that traces a call to OnCompleted from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the completed notification will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="message">The message to be traced for the completed notification.</param>
      <returns>An enumerable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>message != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.TraceEnumerableExtensions.TraceOnCompleted``1(System.Collections.Generic.IEnumerable{``0},System.Diagnostics.TraceSource,System.Func{System.String})">
      <summary>
            Returns an enumerable that traces a call to OnCompleted from the specified enumerable.
            </summary>
      <typeparam name="T">Type of object to be enumerated.</typeparam>
      <param name="source">The enumerable from which the completed notification will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="messageSelector">A function that returns the message to be traced for the completed notification.</param>
      <returns>An enumerable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.Linq.TraceObservableExtensions">
      <summary>
            Provides extension methods that trace observables.
            </summary>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceSubscriptions``1(System.IObservable{``0})">
      <summary>
            Returns an observable that traces calls to Subscribe for the specified observable and calls to Dispose of the resulting subscription.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable for which subscriptions and cancelations will be traced.</param>
      <returns>An observable that traces subscriptions and cancelations.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceSubscriptions``1(System.IObservable{``0},System.String)">
      <summary>
            Returns an observable that traces calls to Subscribe for the specified observable and calls to Dispose of the resulting subscription
            and includes the specified <paramref name="identity" /> in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable for which subscriptions and cancelations will be traced.</param>
      <param name="identity">Identifies the observer in the trace output.</param>
      <returns>An observable that traces subscriptions and cancelations.</returns>
      <requires>source != null</requires>
      <requires>identity != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceSubscriptions``1(System.IObservable{``0},System.String,System.String)">
      <summary>
            Returns an observable that traces calls to Subscribe for the specified observable and calls to Dispose of the resulting subscription.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable for which subscriptions and cancelations will be traced.</param>
      <param name="subscribingMessage">The message to trace when Subscribe is called.</param>
      <param name="subscribedMessage">The message to trace when Subscribe has returned.</param>
      <returns>An observable that traces subscriptions and cancelations.</returns>
      <requires>source != null</requires>
      <requires>subscribingMessage != null</requires>
      <requires>subscribedMessage != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceSubscriptions``1(System.IObservable{``0},System.String,System.String,System.String,System.String)">
      <summary>
            Returns an observable that traces calls to Subscribe for the specified observable and calls to Dispose of the resulting subscription.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable for which subscriptions and cancelations will be traced.</param>
      <param name="subscribingMessage">The message to trace when Subscribe is called.</param>
      <param name="subscribedMessage">The message to trace when Subscribe has returned.</param>
      <param name="disposingMessage">The message to trace when Dispose is called.</param>
      <param name="disposedMessage">The message to trace when Dispose has returned.</param>
      <returns>An observable that traces subscriptions and cancelations.</returns>
      <requires>source != null</requires>
      <requires>subscribingMessage != null</requires>
      <requires>subscribedMessage != null</requires>
      <requires>disposingMessage != null</requires>
      <requires>disposedMessage != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceSubscriptions``1(System.IObservable{``0},System.Diagnostics.TraceSource)">
      <summary>
            Returns an observable that traces calls to Subscribe for the specified observable and calls to Dispose of the resulting subscription.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable for which subscriptions and cancelations will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <returns>An observable that traces subscriptions and cancelations.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceSubscriptions``1(System.IObservable{``0},System.Diagnostics.TraceSource,System.String)">
      <summary>
            Returns an observable that traces calls to Subscribe for the specified observable and calls to Dispose of the resulting subscription
            and includes the specified <paramref name="identity" /> in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable for which subscriptions and cancelations will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="identity">Identifies the observer in the trace output.</param>
      <returns>An observable that traces subscriptions and cancelations.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>identity != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceSubscriptions``1(System.IObservable{``0},System.Diagnostics.TraceSource,System.String,System.String)">
      <summary>
            Returns an observable that traces calls to Subscribe for the specified observable and calls to Dispose of the resulting subscription.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable for which subscriptions and cancelations will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="subscribingMessage">The message to trace when Subscribe is called.</param>
      <param name="subscribedMessage">The message to trace when Subscribe has returned.</param>
      <returns>An observable that traces subscriptions and cancelations.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>subscribingMessage != null</requires>
      <requires>subscribedMessage != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceSubscriptions``1(System.IObservable{``0},System.Diagnostics.TraceSource,System.String,System.String,System.String,System.String)">
      <summary>
            Returns an observable that traces calls to Subscribe for the specified observable and calls to Dispose of the resulting subscription.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable for which subscriptions and cancelations will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="subscribingMessage">The message to trace when Subscribe is called.</param>
      <param name="subscribedMessage">The message to trace when Subscribe has returned.</param>
      <param name="disposingMessage">The message to trace when Dispose is called.</param>
      <param name="disposedMessage">The message to trace when Dispose has returned.</param>
      <returns>An observable that traces subscriptions and cancelations.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>subscribingMessage != null</requires>
      <requires>subscribedMessage != null</requires>
      <requires>disposingMessage != null</requires>
      <requires>disposedMessage != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentity``1(System.IObservable{``0})">
      <summary>
            Returns an observable that traces OnNext, OnError and OnCompleted calls from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <returns>An observable that traces all notifications.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentity``1(System.IObservable{``0},System.String)">
      <summary>
            Returns an observable that traces OnNext, OnError and OnCompleted calls from the specified observable
            and includes the specified <paramref name="identity" /> in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <param name="identity">Identifies the observer in the trace output.</param>
      <returns>An observable that traces all notifications.</returns>
      <requires>source != null</requires>
      <requires>!string.IsNullOrWhiteSpace(identity)</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnNext``1(System.IObservable{``0})">
      <summary>
            Returns an observable that traces OnNext calls from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <returns>An observable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnNext``1(System.IObservable{``0},System.String)">
      <summary>
            Returns an observable that traces OnNext calls from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <param name="format">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <returns>An observable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>format != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnNext``1(System.IObservable{``0},System.Func{System.String,``0,System.String})">
      <summary>
            Returns an observable that traces OnNext calls from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <param name="messageSelector">A function that returns the message to be traced for each notification.</param>
      <returns>An observable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnError``1(System.IObservable{``0})">
      <summary>
            Returns an observable that traces a call to OnError from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the error will be traced.</param>
      <returns>An observable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnError``1(System.IObservable{``0},System.String)">
      <summary>
            Returns an observable that traces a call to OnError from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the error will be traced.</param>
      <param name="format">The format in which the error will be traced.  A single replacement token {0} is supported.</param>
      <returns>An observable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>format != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnError``1(System.IObservable{``0},System.Func{System.String,System.Exception,System.String})">
      <summary>
            Returns an observable that traces a call to OnError from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the error will be traced.</param>
      <param name="messageSelector">A function that returns the message to be traced for the error.</param>
      <returns>An observable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnCompleted``1(System.IObservable{``0})">
      <summary>
            Returns an observable that traces a call to OnCompleted from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the completed notification will be traced.</param>
      <returns>An observable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnCompleted``1(System.IObservable{``0},System.String)">
      <summary>
            Returns an observable that traces a call to OnCompleted from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the completed notification will be traced.</param>
      <param name="message">The message to be traced for the completed notification.</param>
      <returns>An observable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>message != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnCompleted``1(System.IObservable{``0},System.Func{System.String,System.String})">
      <summary>
            Returns an observable that traces a call to OnCompleted from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the completed notification will be traced.</param>
      <param name="messageSelector">A function that returns the message to be traced for the completed notification.</param>
      <returns>An observable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentity``1(System.IObservable{``0},System.Diagnostics.TraceSource)">
      <summary>
            Returns an observable that traces OnNext, OnError and OnCompleted calls from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <returns>An observable that traces all notifications.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentity``1(System.IObservable{``0},System.Diagnostics.TraceSource,System.String)">
      <summary>
            Returns an observable that traces OnNext, OnError and OnCompleted calls from the specified observable
            and includes the specified <paramref name="identity" /> in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="identity">Identifies the observer in the trace output.</param>
      <returns>An observable that traces all notifications.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>!string.IsNullOrWhiteSpace(identity)</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnNext``1(System.IObservable{``0},System.Diagnostics.TraceSource)">
      <summary>
            Returns an observable that traces OnNext calls from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <returns>An observable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnNext``1(System.IObservable{``0},System.Diagnostics.TraceSource,System.String)">
      <summary>
            Returns an observable that traces OnNext calls from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="format">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <returns>An observable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>format != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnNext``1(System.IObservable{``0},System.Diagnostics.TraceSource,System.Func{System.String,``0,System.String})">
      <summary>
            Returns an observable that traces OnNext calls from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="messageSelector">A function that returns the message to be traced for each notification.</param>
      <returns>An observable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnError``1(System.IObservable{``0},System.Diagnostics.TraceSource)">
      <summary>
            Returns an observable that traces a call to OnError from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the error will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <returns>An observable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnError``1(System.IObservable{``0},System.Diagnostics.TraceSource,System.String)">
      <summary>
            Returns an observable that traces a call to OnError from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the error will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="format">The format in which the error will be traced.  A single replacement token {0} is supported.</param>
      <returns>An observable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>format != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnError``1(System.IObservable{``0},System.Diagnostics.TraceSource,System.Func{System.String,System.Exception,System.String})">
      <summary>
            Returns an observable that traces a call to OnError from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the error will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="messageSelector">A function that returns the message to be traced for the error.</param>
      <returns>An observable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnCompleted``1(System.IObservable{``0},System.Diagnostics.TraceSource)">
      <summary>
            Returns an observable that traces a call to OnCompleted from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the completed notification will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <returns>An observable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnCompleted``1(System.IObservable{``0},System.Diagnostics.TraceSource,System.String)">
      <summary>
            Returns an observable that traces a call to OnCompleted from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the completed notification will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="message">The message to be traced for the completed notification.</param>
      <returns>An observable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>message != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceIdentityOnCompleted``1(System.IObservable{``0},System.Diagnostics.TraceSource,System.Func{System.String,System.String})">
      <summary>
            Returns an observable that traces a call to OnCompleted from the specified observable
            and includes an auto-generated identifier in the trace output.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the completed notification will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="messageSelector">A function that returns the message to be traced for the completed notification.</param>
      <returns>An observable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.Trace``1(System.IObservable{``0})">
      <summary>
            Returns an observable that traces OnNext, OnError and OnCompleted calls from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <returns>An observable that traces all notifications.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnNext``1(System.IObservable{``0})">
      <summary>
            Returns an observable that traces OnNext calls from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <returns>An observable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnNext``1(System.IObservable{``0},System.String)">
      <summary>
            Returns an observable that traces OnNext calls from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <param name="format">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <returns>An observable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>format != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnNext``1(System.IObservable{``0},System.Func{``0,System.String})">
      <summary>
            Returns an observable that traces OnNext calls from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <param name="messageSelector">A function that returns the message to be traced for each notification.</param>
      <returns>An observable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnError``1(System.IObservable{``0})">
      <summary>
            Returns an observable that traces a call to OnError from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the error will be traced.</param>
      <returns>An observable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnError``1(System.IObservable{``0},System.String)">
      <summary>
            Returns an observable that traces a call to OnError from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the error will be traced.</param>
      <param name="format">The format in which the error will be traced.  A single replacement token {0} is supported.</param>
      <returns>An observable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>format != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnError``1(System.IObservable{``0},System.Func{System.Exception,System.String})">
      <summary>
            Returns an observable that traces a call to OnError from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the error will be traced.</param>
      <param name="messageSelector">A function that returns the message to be traced for the error.</param>
      <returns>An observable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnCompleted``1(System.IObservable{``0})">
      <summary>
            Returns an observable that traces a call to OnCompleted from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the completed notification will be traced.</param>
      <returns>An observable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnCompleted``1(System.IObservable{``0},System.String)">
      <summary>
            Returns an observable that traces a call to OnCompleted from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the completed notification will be traced.</param>
      <param name="message">The message to be traced for the completed notification.</param>
      <returns>An observable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>message != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnCompleted``1(System.IObservable{``0},System.Func{System.String})">
      <summary>
            Returns an observable that traces a call to OnCompleted from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the completed notification will be traced.</param>
      <param name="messageSelector">A function that returns the message to be traced for the completed notification.</param>
      <returns>An observable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.Trace``1(System.IObservable{``0},System.Diagnostics.TraceSource)">
      <summary>
            Returns an observable that traces OnNext, OnError and OnCompleted calls from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <param name="traceSource">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <returns>An observable that traces all notifications.</returns>
      <requires>source != null</requires>
      <requires>traceSource != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnNext``1(System.IObservable{``0},System.Diagnostics.TraceSource)">
      <summary>
            Returns an observable that traces OnNext calls from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <returns>An observable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnNext``1(System.IObservable{``0},System.Diagnostics.TraceSource,System.String)">
      <summary>
            Returns an observable that traces OnNext calls from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="format">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <returns>An observable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>format != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnNext``1(System.IObservable{``0},System.Diagnostics.TraceSource,System.Func{``0,System.String})">
      <summary>
            Returns an observable that traces OnNext calls from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which notifications will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="messageSelector">A function that returns the message to be traced for each notification.</param>
      <returns>An observable that traces OnNext notifications.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnError``1(System.IObservable{``0},System.Diagnostics.TraceSource)">
      <summary>
            Returns an observable that traces a call to OnError from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the error will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <returns>An observable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnError``1(System.IObservable{``0},System.Diagnostics.TraceSource,System.String)">
      <summary>
            Returns an observable that traces a call to OnError from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the error will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="format">The format in which the error will be traced.  A single replacement token {0} is supported.</param>
      <returns>An observable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>format != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnError``1(System.IObservable{``0},System.Diagnostics.TraceSource,System.Func{System.Exception,System.String})">
      <summary>
            Returns an observable that traces a call to OnError from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the error will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="messageSelector">A function that returns the message to be traced for the error.</param>
      <returns>An observable that traces a call to OnError.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnCompleted``1(System.IObservable{``0},System.Diagnostics.TraceSource)">
      <summary>
            Returns an observable that traces a call to OnCompleted from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the completed notification will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <returns>An observable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnCompleted``1(System.IObservable{``0},System.Diagnostics.TraceSource,System.String)">
      <summary>
            Returns an observable that traces a call to OnCompleted from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the completed notification will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="message">The message to be traced for the completed notification.</param>
      <returns>An observable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>message != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.TraceObservableExtensions.TraceOnCompleted``1(System.IObservable{``0},System.Diagnostics.TraceSource,System.Func{System.String})">
      <summary>
            Returns an observable that traces a call to OnCompleted from the specified observable.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The observable from which the completed notification will be traced.</param>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="messageSelector">A function that returns the message to be traced for the completed notification.</param>
      <returns>An observable that traces a call to OnCompleted.</returns>
      <requires>source != null</requires>
      <requires>trace != null</requires>
      <requires>messageSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.IdentifiedTraceObserver`1">
      <summary>
            Provides a mechanism for tracing push-based notifications with a unique identifier for the observer.
            </summary>
      <typeparam name="T">Type of value notifications.</typeparam>
      <invariant>!string.IsNullOrWhiteSpace(id)</invariant>
    </member>
    <member name="T:System.Reactive.TraceObserver`1">
      <summary>
            Provides a mechanism for tracing push-based notifications.
            </summary>
      <typeparam name="T">Type of value notifications.</typeparam>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.TraceObserver`1" /> class with default trace actions for all notification kinds.
            </summary>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.#ctor(System.Func{`0,System.String})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.TraceObserver`1" /> class for tracing OnNext calls.
            </summary>
      <param name="onNext">A function that returns the message to be traced for each notification.</param>
      <requires>onNext != null</requires>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.#ctor(System.Func{`0,System.String},System.Func{System.Exception,System.String})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.TraceObserver`1" /> class for tracing OnNext and OnError calls.
            </summary>
      <param name="onNext">A function that returns the message to be traced for each notification.</param>
      <param name="onError">A function that returns the message to be traced for the error.</param>
      <requires>onNext != null</requires>
      <requires>onError != null</requires>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.#ctor(System.Func{`0,System.String},System.Func{System.String})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.TraceObserver`1" /> class for tracing OnNext and OnCompleted calls.
            </summary>
      <param name="onNext">A function that returns the message to be traced for each notification.</param>
      <param name="onCompleted">A function that returns the message to be traced for the completed notification.</param>
      <requires>onNext != null</requires>
      <requires>onCompleted != null</requires>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.#ctor(System.Func{`0,System.String},System.Func{System.Exception,System.String},System.Func{System.String})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.TraceObserver`1" /> class for tracing OnNext, OnError and OnCompleted calls.
            </summary>
      <param name="onNext">A function that returns the message to be traced for each notification.</param>
      <param name="onError">A function that returns the message to be traced for the error.</param>
      <param name="onCompleted">A function that returns the message to be traced for the completed notification.</param>
      <requires>onNext != null</requires>
      <requires>onError != null</requires>
      <requires>onCompleted != null</requires>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.#ctor(System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.TraceObserver`1" /> class for tracing OnNext calls.
            </summary>
      <param name="nextFormat">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <requires>nextFormat != null</requires>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.#ctor(System.String,System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.TraceObserver`1" /> class for tracing OnNext and OnError calls.
            </summary>
      <param name="nextFormat">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <param name="errorFormat">The format in which the error will be traced.  A single replacement token {0} is supported.</param>
      <requires>nextFormat != null</requires>
      <requires>errorFormat != null</requires>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.#ctor(System.String,System.String,System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.TraceObserver`1" /> class for tracing OnNext, OnError and OnCompleted calls.
            </summary>
      <param name="nextFormat">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <param name="errorFormat">The format in which the error will be traced.  A single replacement token {0} is supported.</param>
      <param name="completedMessage">The message to be traced for the completed notification.</param>
      <requires>nextFormat != null</requires>
      <requires>errorFormat != null</requires>
      <requires>completedMessage != null</requires>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.#ctor(System.Diagnostics.TraceSource)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.TraceObserver`1" /> class with default trace actions for all notification kinds.
            </summary>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <requires>trace != null</requires>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.#ctor(System.Diagnostics.TraceSource,System.Func{`0,System.String})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.TraceObserver`1" /> class for tracing OnNext calls.
            </summary>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="onNext">A function that returns the message to be traced for each notification.</param>
      <requires>trace != null</requires>
      <requires>onNext != null</requires>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.#ctor(System.Diagnostics.TraceSource,System.Func{`0,System.String},System.Func{System.Exception,System.String})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.TraceObserver`1" /> class for tracing OnNext and OnError calls.
            </summary>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="onNext">A function that returns the message to be traced for each notification.</param>
      <param name="onError">A function that returns the message to be traced for the error.</param>
      <requires>trace != null</requires>
      <requires>onNext != null</requires>
      <requires>onError != null</requires>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.#ctor(System.Diagnostics.TraceSource,System.Func{`0,System.String},System.Func{System.String})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.TraceObserver`1" /> class for tracing OnNext and OnCompleted calls.
            </summary>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="onNext">A function that returns the message to be traced for each notification.</param>
      <param name="onCompleted">A function that returns the message to be traced for the completed notification.</param>
      <requires>trace != null</requires>
      <requires>onNext != null</requires>
      <requires>onCompleted != null</requires>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.#ctor(System.Diagnostics.TraceSource,System.Func{`0,System.String},System.Func{System.Exception,System.String},System.Func{System.String})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.TraceObserver`1" /> class for tracing OnNext, OnError and OnCompleted calls.
            </summary>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="onNext">A function that returns the message to be traced for each notification.</param>
      <param name="onError">A function that returns the message to be traced for the error.</param>
      <param name="onCompleted">A function that returns the message to be traced for the completed notification.</param>
      <requires>trace != null</requires>
      <requires>onNext != null</requires>
      <requires>onError != null</requires>
      <requires>onCompleted != null</requires>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.#ctor(System.Diagnostics.TraceSource,System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.TraceObserver`1" /> class for tracing OnNext calls.
            </summary>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="nextFormat">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <requires>trace != null</requires>
      <requires>nextFormat != null</requires>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.#ctor(System.Diagnostics.TraceSource,System.String,System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.TraceObserver`1" /> class for tracing OnNext and OnError calls.
            </summary>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="nextFormat">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <param name="errorFormat">The format in which the error will be traced.  A single replacement token {0} is supported.</param>
      <requires>trace != null</requires>
      <requires>nextFormat != null</requires>
      <requires>errorFormat != null</requires>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.#ctor(System.Diagnostics.TraceSource,System.String,System.String,System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.TraceObserver`1" /> class for tracing OnNext, OnError and OnCompleted calls.
            </summary>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="nextFormat">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <param name="errorFormat">The format in which the error will be traced.  A single replacement token {0} is supported.</param>
      <param name="completedMessage">The message to be traced for the completed notification.</param>
      <requires>trace != null</requires>
      <requires>nextFormat != null</requires>
      <requires>errorFormat != null</requires>
      <requires>completedMessage != null</requires>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.FormatOnNext(`0)">
      <summary>
            Formats the specified <paramref name="value" />.
            </summary>
      <param name="value">The value to be formatted.</param>
      <returns>The formatted value if calls to <see cref="M:System.Reactive.TraceObserver`1.OnNext(`0)" /> are supported by this instance; otherwise, <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.FormatOnError(System.Exception)">
      <summary>
            Formats the specified <paramref name="exception" />.
            </summary>
      <param name="exception">The exception to be formatted.</param>
      <returns>The formatted exception if calls to <see cref="M:System.Reactive.TraceObserver`1.OnError(System.Exception)" /> are supported by this instance and the specified <paramref name="exception" /> is 
            not <see langword="null" />; otherwise, <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.FormatOnCompleted">
      <summary>
            Returns a string for <see cref="M:System.Reactive.TraceObserver`1.OnCompleted" />.
            </summary>
      <returns>The string to be traced if calls to <see cref="M:System.Reactive.TraceObserver`1.OnCompleted" /> are supported by this instance; otherwise, <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.OnNext(`0)">
      <summary>
            Notifies the observer of a new value in the sequence.
            </summary>
      <param name="value">The current notification information.</param>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.OnError(System.Exception)">
      <summary>
            Notifies the observer of an error condition in the sequence.
            </summary>
      <param name="error">An object that provides additional information about the error.</param>
      <requires inheritedFrom="M:System.IObserver`1.OnError(System.Exception)" inheritedFromTypeName="IObserver">error != null</requires>
    </member>
    <member name="M:System.Reactive.TraceObserver`1.OnCompleted">
      <summary>
            Notifies the observer that the provider has finished sending push-based notifications.
            </summary>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.IdentifiedTraceObserver`1" /> class with default trace actions for all notification kinds.
            </summary>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.#ctor(System.Func{System.String,`0,System.String})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.IdentifiedTraceObserver`1" /> class for tracing OnNext calls.
            </summary>
      <param name="onNext">A function that returns the message to be traced for each notification.</param>
      <requires>onNext != null</requires>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.#ctor(System.Func{System.String,`0,System.String},System.Func{System.String,System.Exception,System.String})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.IdentifiedTraceObserver`1" /> class for tracing OnNext and OnError calls.
            </summary>
      <param name="onNext">A function that returns the message to be traced for each notification.</param>
      <param name="onError">A function that returns the message to be traced for the error.</param>
      <requires>onNext != null</requires>
      <requires>onError != null</requires>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.#ctor(System.Func{System.String,`0,System.String},System.Func{System.String,System.String})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.IdentifiedTraceObserver`1" /> class for tracing OnNext and OnCompleted calls.
            </summary>
      <param name="onNext">A function that returns the message to be traced for each notification.</param>
      <param name="onCompleted">A function that returns the message to be traced for the completed notification.</param>
      <requires>onNext != null</requires>
      <requires>onCompleted != null</requires>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.#ctor(System.Func{System.String,`0,System.String},System.Func{System.String,System.Exception,System.String},System.Func{System.String,System.String})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.IdentifiedTraceObserver`1" /> class for tracing OnNext, OnError and OnCompleted calls.
            </summary>
      <param name="onNext">A function that returns the message to be traced for each notification.</param>
      <param name="onError">A function that returns the message to be traced for the error.</param>
      <param name="onCompleted">A function that returns the message to be traced for the completed notification.</param>
      <requires>onNext != null</requires>
      <requires>onError != null</requires>
      <requires>onCompleted != null</requires>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.#ctor(System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.IdentifiedTraceObserver`1" /> class for tracing OnNext calls.
            </summary>
      <param name="nextFormat">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <requires>nextFormat != null</requires>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.#ctor(System.String,System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.IdentifiedTraceObserver`1" /> class for tracing OnNext and OnError calls.
            </summary>
      <param name="nextFormat">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <param name="errorFormat">The format in which the error will be traced.  A single replacement token {0} is supported.</param>
      <requires>nextFormat != null</requires>
      <requires>errorFormat != null</requires>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.#ctor(System.String,System.String,System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.IdentifiedTraceObserver`1" /> class for tracing OnNext, OnError and OnCompleted calls.
            </summary>
      <param name="nextFormat">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <param name="errorFormat">The format in which the error will be traced.  A single replacement token {0} is supported.</param>
      <param name="completedMessage">The message to be traced for the completed notification.</param>
      <requires>nextFormat != null</requires>
      <requires>errorFormat != null</requires>
      <requires>completedMessage != null</requires>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.#ctor(System.Diagnostics.TraceSource)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.IdentifiedTraceObserver`1" /> class with default trace actions for all notification kinds.
            </summary>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <requires>trace != null</requires>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.#ctor(System.Diagnostics.TraceSource,System.Func{System.String,`0,System.String})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.IdentifiedTraceObserver`1" /> class for tracing OnNext calls.
            </summary>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="onNext">A function that returns the message to be traced for each notification.</param>
      <requires>trace != null</requires>
      <requires>onNext != null</requires>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.#ctor(System.Diagnostics.TraceSource,System.Func{System.String,`0,System.String},System.Func{System.String,System.Exception,System.String})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.IdentifiedTraceObserver`1" /> class for tracing OnNext and OnError calls.
            </summary>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="onNext">A function that returns the message to be traced for each notification.</param>
      <param name="onError">A function that returns the message to be traced for the error.</param>
      <requires>trace != null</requires>
      <requires>onNext != null</requires>
      <requires>onError != null</requires>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.#ctor(System.Diagnostics.TraceSource,System.Func{System.String,`0,System.String},System.Func{System.String,System.String})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.IdentifiedTraceObserver`1" /> class for tracing OnNext and OnCompleted calls.
            </summary>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="onNext">A function that returns the message to be traced for each notification.</param>
      <param name="onCompleted">A function that returns the message to be traced for the completed notification.</param>
      <requires>trace != null</requires>
      <requires>onNext != null</requires>
      <requires>onCompleted != null</requires>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.#ctor(System.Diagnostics.TraceSource,System.Func{System.String,`0,System.String},System.Func{System.String,System.Exception,System.String},System.Func{System.String,System.String})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.IdentifiedTraceObserver`1" /> class for tracing OnNext, OnError and OnCompleted calls.
            </summary>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="onNext">A function that returns the message to be traced for each notification.</param>
      <param name="onError">A function that returns the message to be traced for the error.</param>
      <param name="onCompleted">A function that returns the message to be traced for the completed notification.</param>
      <requires>trace != null</requires>
      <requires>onNext != null</requires>
      <requires>onError != null</requires>
      <requires>onCompleted != null</requires>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.#ctor(System.Diagnostics.TraceSource,System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.IdentifiedTraceObserver`1" /> class for tracing OnNext calls.
            </summary>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="nextFormat">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <requires>trace != null</requires>
      <requires>nextFormat != null</requires>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.#ctor(System.Diagnostics.TraceSource,System.String,System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.IdentifiedTraceObserver`1" /> class for tracing OnNext and OnError calls.
            </summary>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="nextFormat">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <param name="errorFormat">The format in which the error will be traced.  A single replacement token {0} is supported.</param>
      <requires>trace != null</requires>
      <requires>nextFormat != null</requires>
      <requires>errorFormat != null</requires>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.#ctor(System.Diagnostics.TraceSource,System.String,System.String,System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.IdentifiedTraceObserver`1" /> class for tracing OnNext, OnError and OnCompleted calls.
            </summary>
      <param name="trace">The <see cref="T:System.Diagnostics.TraceSource" /> to be associated with the trace messages.</param>
      <param name="nextFormat">The format in which values will be traced.  A single replacement token {0} is supported.</param>
      <param name="errorFormat">The format in which the error will be traced.  A single replacement token {0} is supported.</param>
      <param name="completedMessage">The message to be traced for the completed notification.</param>
      <requires>trace != null</requires>
      <requires>nextFormat != null</requires>
      <requires>errorFormat != null</requires>
      <requires>completedMessage != null</requires>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.FormatOnNext(`0)">
      <summary>
            Formats the specified <paramref name="value" />.
            </summary>
      <param name="value">The value to be formatted.</param>
      <returns>The formatted value if calls to <see cref="M:System.IObserver`1.OnNext(`0)" /> are supported by this instance; otherwise, <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.FormatOnError(System.Exception)">
      <summary>
            Formats the specified <paramref name="exception" />.
            </summary>
      <param name="exception">The exception to be formatted.</param>
      <returns>The formatted exception if calls to <see cref="M:System.IObserver`1.OnError(System.Exception)" /> are supported by this instance and the specified <paramref name="exception" /> is 
            not <see langword="null" />; otherwise, <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.FormatOnCompleted">
      <summary>
            Returns a string for <see cref="M:System.IObserver`1.OnCompleted" />.
            </summary>
      <returns>The string to be traced if calls to <see cref="M:System.IObserver`1.OnCompleted" /> are supported by this instance; otherwise, <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.FormatOnNext(System.String,`0)">
      <summary>
            Formats the specified <paramref name="value" /> with the specified <paramref name="observerId" />.
            </summary>
      <param name="observerId">The identity of the observer.</param>
      <param name="value">The value to be formatted.</param>
      <returns>The formatted value if calls to <see cref="M:System.IObserver`1.OnNext(`0)" /> are supported by this instance; otherwise, <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.FormatOnError(System.String,System.Exception)">
      <summary>
            Formats the specified <paramref name="exception" /> with the specified <paramref name="observerId" />.
            </summary>
      <param name="observerId">The identity of the observer.</param>
      <param name="exception">The exception to be formatted.</param>
      <returns>The formatted exception if calls to <see cref="M:System.IObserver`1.OnError(System.Exception)" /> are supported by this instance and the specified <paramref name="exception" /> is 
            not <see langword="null" />; otherwise, <see langword="null" />.</returns>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.FormatOnCompleted(System.String)">
      <summary>
            Returns a string for <see cref="M:System.IObserver`1.OnCompleted" /> with the specified <paramref name="observerId" />.
            </summary>
      <param name="observerId">The identity of the observer.</param>
      <returns>The string to be traced if calls to <see cref="M:System.IObserver`1.OnCompleted" /> are supported by this instance; otherwise, <see langword="null" />.</returns>
    </member>
    <member name="P:System.Reactive.IdentifiedTraceObserver`1.Identity">
      <summary>
            Gets or sets the observer's identity in the trace output.
            </summary>
      <getter>
        <ensures>!string.IsNullOrWhiteSpace(Contract.Result&lt;string&gt;())</ensures>
      </getter>
      <setter>
        <requires>!string.IsNullOrWhiteSpace(value)</requires>
      </setter>
    </member>
    <member name="T:System.ServiceModel.Syndication.SyndicationFeedFormatterExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for <see cref="T:System.ServiceModel.Syndication.SyndicationFeedFormatter" /> objects.
            </summary>
    </member>
    <member name="M:System.ServiceModel.Syndication.SyndicationFeedFormatterExtensions.DownloadObservable(System.ServiceModel.Syndication.SyndicationFeedFormatter,System.Uri[])">
      <summary>
            Downloads the specified syndication <paramref name="feeds" /> and merges them into an observable sequence.
            </summary>
      <param name="formatter">The object that reads each feed.</param>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>formatter != null</requires>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.SyndicationFeedFormatterExtensions.DownloadObservable(System.ServiceModel.Syndication.SyndicationFeedFormatter,System.Collections.Generic.IEnumerable{System.Uri})">
      <summary>
            Downloads the specified syndication <paramref name="feeds" /> and merges them into an observable sequence.
            </summary>
      <param name="formatter">The object that reads each feed.</param>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>formatter != null</requires>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.SyndicationFeedFormatterExtensions.DownloadObservable(System.ServiceModel.Syndication.SyndicationFeedFormatter,System.TimeSpan,System.Uri[])">
      <summary>
            Downloads all of the specified syndication <paramref name="feeds" /> at the specified <paramref name="interval" /> and merges them into an observable sequence.
            </summary>
      <param name="formatter">The object that reads each feed.</param>
      <param name="interval">The duration between downloads.</param>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <para>
          <see cref="M:System.ServiceModel.Syndication.SyndicationFeedFormatterExtensions.DownloadObservable(System.ServiceModel.Syndication.SyndicationFeedFormatter,System.TimeSpan,System.Uri[])" /> downloads all of the feeds upon subscription and then repeats the process at each <paramref name="interval" />.
            All of the <paramref name="feeds" /> are downloaded at each interval and merged into the observable sequence.
            </para>
        <para>
            To avoid duplicate items, consider calling the <strong>Distinct</strong> method on the sequence.  Alternatively, use the 
            <strong>Collect</strong> method to create an <see cref="T:System.Reactive.Subjects.IDictionarySubject`2" />.
            </para>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>formatter != null</requires>
      <requires>feeds != null</requires>
      <requires>interval &gt;= TimeSpan.Zero</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.SyndicationFeedFormatterExtensions.DownloadObservable(System.ServiceModel.Syndication.SyndicationFeedFormatter,System.TimeSpan,System.Collections.Generic.IEnumerable{System.Uri})">
      <summary>
            Downloads all of the specified syndication <paramref name="feeds" /> at the specified <paramref name="interval" /> and merges them into an observable sequence.
            </summary>
      <param name="formatter">The object that reads each feed.</param>
      <param name="interval">The duration between downloads.</param>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <para>
          <see cref="M:System.ServiceModel.Syndication.SyndicationFeedFormatterExtensions.DownloadObservable(System.ServiceModel.Syndication.SyndicationFeedFormatter,System.TimeSpan,System.Collections.Generic.IEnumerable{System.Uri})" /> downloads all of the feeds upon subscription and then repeats the process at each <paramref name="interval" />.
            All of the <paramref name="feeds" /> are downloaded at each interval and merged into the observable sequence.
            </para>
        <para>
            To avoid duplicate items, consider calling the <strong>Distinct</strong> method on the sequence.  Alternatively, use the 
            <strong>Collect</strong> method to create an <see cref="T:System.Reactive.Subjects.IDictionarySubject`2" />.
            </para>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>formatter != null</requires>
      <requires>feeds != null</requires>
      <requires>interval &gt;= TimeSpan.Zero</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.ServiceModel.Syndication.ObservableSyndication">
      <summary>
            Provides <see langword="static" /> methods for downloading syndication feeds.
            </summary>
    </member>
    <member name="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadRss(System.Uri[])">
      <summary>
            Downloads the specified RSS 2.0 syndication <paramref name="feeds" /> and merges them into an observable sequence.
            </summary>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadRss(System.Collections.Generic.IEnumerable{System.Uri})">
      <summary>
            Downloads the specified RSS 2.0 syndication <paramref name="feeds" /> and merges them into an observable sequence.
            </summary>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadRss(System.TimeSpan,System.Uri[])">
      <summary>
            Downloads all of the specified RSS 2.0 syndication <paramref name="feeds" /> at the specified <paramref name="interval" /> and merges them into an observable sequence.
            </summary>
      <param name="interval">The duration between downloads.</param>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <para>
          <see cref="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadRss(System.TimeSpan,System.Uri[])" /> downloads all of the feeds upon subscription and then repeats the process at each <paramref name="interval" />.
            All of the <paramref name="feeds" /> are downloaded at each interval and merged into the observable sequence.
            </para>
        <para>
            To avoid duplicate items, consider calling the <strong>Distinct</strong> method on the sequence.  Alternatively, use the 
            <strong>Collect</strong> method to create an <see cref="T:System.Reactive.Subjects.IDictionarySubject`2" />.
            </para>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>interval &gt;= TimeSpan.Zero</requires>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadRss(System.TimeSpan,System.Collections.Generic.IEnumerable{System.Uri})">
      <summary>
            Downloads all of the specified RSS 2.0 syndication <paramref name="feeds" /> at the specified <paramref name="interval" /> and merges them into an observable sequence.
            </summary>
      <param name="interval">The duration between downloads.</param>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <para>
          <see cref="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadRss(System.TimeSpan,System.Collections.Generic.IEnumerable{System.Uri})" /> downloads all of the feeds upon subscription and then repeats the process at each <paramref name="interval" />.
            All of the <paramref name="feeds" /> are downloaded at each interval and merged into the observable sequence.
            </para>
        <para>
            To avoid duplicate items, consider calling the <strong>Distinct</strong> method on the sequence.  Alternatively, use the 
            <strong>Collect</strong> method to create an <see cref="T:System.Reactive.Subjects.IDictionarySubject`2" />.
            </para>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>interval &gt;= TimeSpan.Zero</requires>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadAtom(System.Uri[])">
      <summary>
            Downloads the specified Atom 1.0 syndication <paramref name="feeds" /> and merges them into an observable sequence.
            </summary>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadAtom(System.Collections.Generic.IEnumerable{System.Uri})">
      <summary>
            Downloads the specified Atom 1.0 syndication <paramref name="feeds" /> and merges them into an observable sequence.
            </summary>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadAtom(System.TimeSpan,System.Uri[])">
      <summary>
            Downloads all of the specified Atom 1.0 syndication <paramref name="feeds" /> at the specified <paramref name="interval" /> and merges them into an observable sequence.
            </summary>
      <param name="interval">The duration between downloads.</param>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <para>
          <see cref="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadAtom(System.TimeSpan,System.Uri[])" /> downloads all of the feeds upon subscription and then repeats the process at each <paramref name="interval" />.
            All of the <paramref name="feeds" /> are downloaded at each interval and merged into the observable sequence.
            </para>
        <para>
            To avoid duplicate items, consider calling the <strong>Distinct</strong> method on the sequence.  Alternatively, use the 
            <strong>Collect</strong> method to create an <see cref="T:System.Reactive.Subjects.IDictionarySubject`2" />.
            </para>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>interval &gt;= TimeSpan.Zero</requires>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadAtom(System.TimeSpan,System.Collections.Generic.IEnumerable{System.Uri})">
      <summary>
            Downloads all of the specified Atom 1.0 syndication <paramref name="feeds" /> at the specified <paramref name="interval" /> and merges them into an observable sequence.
            </summary>
      <param name="interval">The duration between downloads.</param>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <para>
          <see cref="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadAtom(System.TimeSpan,System.Collections.Generic.IEnumerable{System.Uri})" /> downloads all of the feeds upon subscription and then repeats the process at each <paramref name="interval" />.
            All of the <paramref name="feeds" /> are downloaded at each interval and merged into the observable sequence.
            </para>
        <para>
            To avoid duplicate items, consider calling the <strong>Distinct</strong> method on the sequence.  Alternatively, use the 
            <strong>Collect</strong> method to create an <see cref="T:System.Reactive.Subjects.IDictionarySubject`2" />.
            </para>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>interval &gt;= TimeSpan.Zero</requires>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.TraceDefaults">
      <summary>
            Provides <see langword="static" /> methods that format trace strings for sequences.
            </summary>
    </member>
    <member name="M:System.TraceDefaults.DefaultOnNext``1(``0)">
      <summary>
            Returns a textual representation of the specified <paramref name="value" />.
            </summary>
      <typeparam name="T">Type of <paramref name="value" />.</typeparam>
      <param name="value">The object for which a string representation is returned.</param>
      <returns>String that represents the specified <paramref name="value" />.</returns>
      <ensures>Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.TraceDefaults.DefaultOnError(System.Exception)">
      <summary>
            Returns a textual representation of the specified <paramref name="exception" />.
            </summary>
      <param name="exception">The object for which a string representation is returned.</param>
      <returns>String that represents the specified <paramref name="exception" />.</returns>
      <ensures>Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.TraceDefaults.DefaultOnCompleted">
      <summary>
            Returns a textual representation of an OnCompleted notification.
            </summary>
      <returns>String that represents OnCompleted.</returns>
      <ensures>Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.TraceDefaults.DefaultOnNext``1(System.String,``0)">
      <summary>
            Returns a textual representation of the specified <paramref name="value" /> for the specified <paramref name="observerId" />.
            </summary>
      <typeparam name="T">Type of <paramref name="value" />.</typeparam>
      <param name="observerId">The identity of the observer that received this notification.</param>
      <param name="value">The object for which a string representation is returned.</param>
      <returns>String that represents the specified <paramref name="value" /> for the specified  <paramref name="observerId" />.</returns>
      <ensures>Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.TraceDefaults.DefaultOnError(System.String,System.Exception)">
      <summary>
            Returns a textual representation of the specified <paramref name="exception" /> for the specified <paramref name="observerId" />.
            </summary>
      <param name="observerId">The identity of the observer that received this notification.</param>
      <param name="exception">The object for which a string representation is returned.</param>
      <returns>String that represents the specified <paramref name="exception" /> for the specified <paramref name="observerId" />.</returns>
      <ensures>Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.TraceDefaults.DefaultOnCompleted(System.String)">
      <summary>
            Returns a textual representation of an OnCompleted notification for the specified <paramref name="observerId" />.
            </summary>
      <param name="observerId">The identity of the observer that received this notification.</param>
      <returns>String that represents OnCompleted for the specified <paramref name="observerId" />.</returns>
      <ensures>Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.TraceDefaults.FormatMessage(System.String,System.String)">
      <summary>
            Formats the specified <paramref name="message" /> for the specified <paramref name="observerId" />.
            </summary>
      <param name="observerId">The identity of the observer to which the <paramref name="message" /> belongs.</param>
      <param name="message">The message to be formatted.</param>
      <returns>The formatted <paramref name="message" /> for the specified <paramref name="observerId" />.</returns>
      <ensures>Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="T:System.Windows.Reactive.Subscription">
      <summary>
            Provides high-level access to the definition of a binding that supports <see cref="T:System.IObservable`1" /> and <see cref="T:System.IObserver`1" />.
            A binding connects the properties of binding target objects (typically, WPF elements), and any observable or scalar data source.
            <see cref="T:System.Windows.Reactive.Subscription" /> behaves almost identically to <see cref="T:System.Windows.Data.Binding" />, expect that <see cref="T:System.IObservable`1" /> data sources
            update the target with each element in the sequence and <see cref="T:System.IObserver`1" /> data sources are notified when the target changes.
            </summary>
      <remarks>
        <para>
            Binding to objects that do not implement <see cref="T:System.IObservable`1" /> is supported in the direction from the source to the target, 
            just like <see cref="T:System.Windows.Data.Binding" />.  Updates from the target to the source are supported only if the source implements 
            <see cref="T:System.IObserver`1" />.
            </para>
        <para>
            A source that does not implement either <see cref="T:System.IObserver`1" /> or <see cref="T:System.IObservable`1" /> behaves like a normal 
            <see cref="T:System.Windows.Data.Binding" /> with its <see cref="P:System.Windows.Data.Binding.Mode" /> property set to <see cref="F:System.Windows.Data.BindingMode.OneWay" />.
            </para>
        <para>
            The target may require a scalar value.  For example, the <see cref="P:System.Windows.Controls.TextBlock.Text" /> property is usually bound to a property that 
            returns a <see cref="T:System.String" />.  When the data source is an <see cref="T:System.IObservable`1" /> sequence, instead of a scalar value, it is 
            treated like a changing scalar value.  Each element in the <see cref="T:System.IObservable`1" /> is pushed to the target as the latest value.
            Essentially, subscribing to a property that returns <see cref="T:System.IObservable`1" /> is a reactive alternative to binding to a property 
            that returns a scalar value, implementing <see cref="T:System.ComponentModel.INotifyPropertyChanged" /> and raising an event each time the scalar value changes.
            </para>
        <para>
          <see cref="T:System.Windows.Reactive.Subscription" /> also supports <see cref="T:System.Collections.IEnumerable" /> targets.  For example, <see cref="T:System.Windows.Reactive.Subscription" /> 
            can be used to bind an observable data source to the <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> property.  The behavior of this kind of 
            subscription depends upon the capabilities of the source.  If the source implements <see cref="T:System.Collections.IEnumerable" />, then 
            the source is sent to the target unmodified.  If the source also implements <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" />, 
            then the target is updated as per the specifications of that interface.  For example, this behavior is applied when subscribing to 
            <see cref="T:System.Reactive.Subjects.IListSubject`1" /> or <see cref="T:System.Reactive.Subjects.IDictionarySubject`2" /> 
            data sources.
            </para>
        <para>
            If the source does not implement <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" />, although it does implement 
            <see cref="T:System.IObservable`1" />, then the target is reset for every element in the observable sequence.  This causes the target to 
            iterate the entire enumerable sequence each time that an element is observed in the observable sequence.  In other words, the observable 
            is used as a change notification for the enumerable, although the actual data in the observable sequence is ignored.
            </para>
        <para>
            If the source does not implement <see cref="T:System.Collections.IEnumerable" />, but does implement <see cref="T:System.IObservable`1" />, 
            then the target is bound to an empty collection of objects.  Then, each <see cref="T:System.Reactive.CollectionNotification`1" /> 
            that is observed from the source observable sequence is applied to the bound collection.  Any values that aren't a 
            <see cref="T:System.Reactive.CollectionNotification`1" /> are simply added to the bound collection.
            </para>
        <alert type="tip">
            All observed notifications are automatically marshaled to the dispatcher thread, unlike <see cref="T:System.Windows.Data.Binding" />.  For <see cref="T:System.IObservable`1" />
            sources, this means that you don't have to add <strong>ObserveOnDispatcher</strong> to your query.  For 
            <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" /> sources, you can make concurrent updates to the source collection 
            (provided that it's thread-safe already) and the <see cref="T:System.Windows.Reactive.Subscription" /> will automatically marshal changes to the dispatcher thread.
            </alert>
        <para>
            Otherwise, if the source does not implement either <see cref="T:System.Collections.IEnumerable" /> or <see cref="T:System.IObservable`1" />, 
            then the behavior used is the same as <see cref="T:System.Windows.Data.Binding" />.  In this case, you'll probably want to assign a <see cref="P:System.Windows.Reactive.Subscription.Converter" /> 
            that can convert the source into an <see cref="T:System.Collections.IEnumerable" /> for the target.
            </para>
        <alert type="warning">
            WPF may process bindings even before a UI has been completely loaded.  This can cause <see cref="T:System.Windows.Reactive.Subscription" /> to receive a reference 
            to an observable data source before the UI is displayed, or even if it's never displayed.  Since <see cref="T:System.Windows.Reactive.Subscription" /> does not know
            about the context in which its target element is being used, it will subscribe to the observable query right away.  In cases when you 
            need to instantiate an element that may contain <see cref="T:System.Windows.Reactive.Subscription" /> bindings in XAML, but it's not added to a visual tree right 
            away or it's never going to be added, then it's recommended that you use <see cref="T:System.Reactive.Subjects.Subject`1" /> as your 
            data source so that you can control when the source is connected to an observable that may cause side-effects.  When the element 
            finally raises its <see cref="E:System.Windows.FrameworkElement.Loaded" /> event, create the real observable sequence and subscribe the subject to it
            so that the binding starts receiving values.
            </alert>
        <para>
            The lifetime of the subscription to an observable data source is only partially controlled by the <see cref="T:System.Windows.Reactive.Subscription" /> object.
            When the source property returns a different object, then the <see cref="T:System.Windows.Reactive.Subscription" /> object will automatically dispose of 
            the previous observable's subscription, if any.  However, the latest subscription is never disposed by <see cref="T:System.Windows.Reactive.Subscription" />.
            For this reason, it remains the responsibility of data source objects to ensure that bound observables are cleaned up when they are 
            no longer needed.  This can be accomplished in a few different ways as follows.
            </para>
        <para>
            The most direct way is to call <see cref="M:System.Windows.Reactive.Subscription.Dispose" /> on the <see cref="T:System.Windows.Reactive.Subscription" /> object, which dipsoses of any active subscription.
            </para>
        <para>
            In other cases you can ensure that the observable calls <strong>OnCompleted</strong>.  Or you can explicitly dispose of the 
            observable source, for example if you're using <see cref="T:System.Reactive.Subjects.Subject`1" /> then you can call its 
            <see cref="M:System.IDisposable.Dispose" /> method when the bound element or its root container raises the <see cref="E:System.Windows.FrameworkElement.Unloaded" /> 
            event.
            </para>
      </remarks>
      <invariant>converter != null</invariant>
      <invariant>binding != null</invariant>
      <invariant>proxyBinding != null</invariant>
      <invariant>multiBinding != null</invariant>
    </member>
    <member name="M:System.Windows.Reactive.Subscription.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Windows.Reactive.Subscription" /> class.
            </summary>
    </member>
    <member name="M:System.Windows.Reactive.Subscription.#ctor(System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Windows.Reactive.Subscription" /> class with an initial path.
            </summary>
      <param name="path">The initial <see cref="P:System.Windows.Reactive.Subscription.Path" /> for the binding.</param>
    </member>
    <member name="M:System.Windows.Reactive.Subscription.ProvideValue(System.IServiceProvider)">
      <summary>
            Returns an object that should be set on the property where this binding and extension are applied.
            </summary>
      <param name="serviceProvider">The object that can provide services for the markup extension.  May be <see langword="null" />.</param>
      <returns>The value to set on the binding target property.</returns>
    </member>
    <member name="M:System.Windows.Reactive.Subscription.Dispose">
      <summary>
            Disposes of the active subscription, if any, to an observable data source.
            </summary>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.AsyncState">
      <summary>
            Gets or sets opaque data passed to the asynchronous data dispatcher.
            </summary>
      <value>Data passed to the asynchronous data dispatcher.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.BindsDirectlyToSource">
      <summary>
            Gets or sets a value indicating whether to evaluate the <see cref="P:System.Windows.Reactive.Subscription.Path" /> relative to the data item or 
            the <see cref="T:System.Windows.Data.DataSourceProvider" /> object.
            </summary>
      <value>
        <see langword="False" /> to evaluate the path relative to the data item itself; otherwise, <see langword="true" />.
            The default is <see langword="false" />.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.ElementName">
      <summary>
            Gets or sets the name of the element to use as the binding source object.
            </summary>
      <value>The value of the <strong>Name</strong> property or <strong>x:Name</strong> Attribute of the element of interest.
            You can refer to elements in code only if they are registered to the appropriate <see cref="T:System.Windows.NameScope" /> through <strong>RegisterName</strong>.
            The default is <see langword="null" />.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.IsAsync">
      <summary>
            Gets or sets a value indicating whether <see cref="T:System.Windows.Reactive.Subscription" /> should get values asynchronously.
            </summary>
      <remarks>
            Do not confuse <see cref="P:System.Windows.Reactive.Subscription.IsAsync" /> with the asynchronous nature of observables.  <see cref="P:System.Windows.Reactive.Subscription.IsAsync" />
            applies only to reading the source property that returns the data source object, which may or may not 
            be an observable sequence.  If reading the source property takes a long time to execute, then it will 
            block the UI thread for a long time.  In this case, setting <see cref="P:System.Windows.Reactive.Subscription.IsAsync" /> to true ensures that 
            the UI thread is not blocked while the source property is being read.  If the property just-so-happens 
            to return an object that is an observable sequence, then the subscription to that observable will be 
            unaffected by the value of <see cref="P:System.Windows.Reactive.Subscription.IsAsync" />.
            </remarks>
      <value>The default is <see langword="false" />.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.Path">
      <summary>
            Gets or sets the path to the binding source property.
            </summary>
      <value>The path to the binding source.  The default is <see langword="null" />.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.RelativeSource">
      <summary>
            Gets or sets the binding source by specifying its location relative to the position of the binding target.
            </summary>
      <value>A <see cref="P:System.Windows.Reactive.Subscription.RelativeSource" /> object specifying the relative location of the binding source to use.
            The default is <see langword="null" />.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.Source">
      <summary>
            Gets or sets the object to use as the binding source.
            </summary>
      <value>The object to use as the binding source.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.XPath">
      <summary>
            Gets or sets an XPath query that returns the value on the XML binding source to use.
            </summary>
      <value>The XPath query.  The default is <see langword="null" />.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.BindingGroupName">
      <summary>
            Gets or sets the name of the <see cref="T:System.Windows.Data.BindingGroup" /> to which this binding belongs.
            </summary>
      <value>The name of the <see cref="T:System.Windows.Data.BindingGroup" /> to which this binding belongs.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.FallbackValue">
      <summary>
            Gets or sets the value to use when the binding is unable to return a value.
            </summary>
      <value>The default value is <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.StringFormat">
      <summary>
            Gets or sets a string that specifies how to format the binding if it displays the bound value as a string.
            </summary>
      <value>A string that specifies how to format the binding if it displays the bound value as a string.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.TargetNullValue">
      <summary>
            Gets or sets the value that is used in the target when the value of the source is <see langword="null" />.
            </summary>
      <value>The value that is used in the target when the value of the source is <see langword="null" />.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.Converter">
      <summary>
            Gets or sets the converter to use to convert the source values to or from the target value.
            </summary>
      <value>A value of type <see cref="T:System.Windows.Data.IValueConverter" /> that indicates the converter to use.
            The default value is <see langword="null" />.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.ConverterCulture">
      <summary>
            Gets or sets the culture in which to evaluate the converter.
            </summary>
      <value>The default is <see langword="null" />.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.ConverterParameter">
      <summary>
            Gets or sets an optional parameter to pass to the <see cref="P:System.Windows.Reactive.Subscription.Converter" /> as additional information.
            </summary>
      <value>The parameter to pass to the <see cref="P:System.Windows.Reactive.Subscription.Converter" />.  The default is <see langword="null" />.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.NotifyOnSourceUpdated">
      <summary>
            Gets or sets a value indicating whether to raise the <see cref="E:System.Windows.FrameworkElement.SourceUpdated" />
            event when a value is transferred from the binding target to the binding source.
            </summary>
      <value>
        <see langword="True" /> if the <see cref="E:System.Windows.FrameworkElement.SourceUpdated" /> event will be raised
            when the binding source value is updated; otherwise, <see langword="false" />.
            The default value is <see langword="false" />.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.NotifyOnTargetUpdated">
      <summary>
            Gets or sets a value indicating whether to raise the <see cref="E:System.Windows.FrameworkElement.TargetUpdated" />
            event when a value is transferred from the binding source to the binding target.
            </summary>
      <value>
        <see langword="True" /> if the <see cref="E:System.Windows.FrameworkElement.TargetUpdated" /> event will be raised
            when the binding target value is updated; otherwise, <see langword="false" />.
            The default value is <see langword="false" />.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.NotifyOnValidationError">
      <summary>
            Gets or sets a value indicating whether to raise the <see cref="F:System.Windows.Controls.Validation.ErrorEvent" />
            attached event on the bound element.
            </summary>
      <value>
        <see langword="True" /> if the <see cref="F:System.Windows.Controls.Validation.ErrorEvent" /> attached event will
            be raised on the bound element when there is a validation error during source updates; otherwise, 
            <see langword="false" />.  The default value is <see langword="false" />.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.UpdateSourceExceptionFilter">
      <summary>
            Gets or sets a handler you can use to provide custom logic for handling exceptions
            that the binding engine encounters during the update of the binding source
            value.  This is only applicable if you have associated the <see cref="T:System.Windows.Controls.ExceptionValidationRule" />
            with your <see cref="T:System.Windows.Reactive.Subscription" /> object.
            </summary>
      <value>A method that provides custom logic for handling exceptions that the binding
            engine encounters during the update of the binding source value.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.UpdateSourceTrigger">
      <summary>
            Gets or sets a value that determines the timing of binding source updates.
            </summary>
      <value>One of the <see cref="P:System.Windows.Reactive.Subscription.UpdateSourceTrigger" /> values.  The default value
            is <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />, which returns the default 
            <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> value of the target dependency property.
            However, the default value for most dependency properties is <see cref="F:System.Windows.Data.UpdateSourceTrigger.PropertyChanged" />,
            while the <see cref="P:System.Windows.Controls.TextBox.Text" /> property has a default value 
            of <see cref="F:System.Windows.Data.UpdateSourceTrigger.LostFocus" />.  A programmatic way to determine the default 
            <see cref="P:System.Windows.Data.Binding.UpdateSourceTrigger" /> value of a dependency property is to get the property 
            metadata of the property using <see cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" /> and then
            check the value of the <see cref="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" /> property.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.ValidatesOnDataErrors">
      <summary>
            Gets or sets a value indicating whether to include the <see cref="T:System.Windows.Controls.DataErrorValidationRule" />.
            </summary>
      <value>
        <see langword="True" /> to include the <see cref="T:System.Windows.Controls.DataErrorValidationRule" />; 
            otherwise, <see langword="false" />.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.ValidatesOnExceptions">
      <summary>
            Gets or sets a value indicating whether to include the <see cref="T:System.Windows.Controls.ExceptionValidationRule" />.
            </summary>
      <value>
        <see langword="True" /> to include the <see cref="T:System.Windows.Controls.ExceptionValidationRule" />; 
            otherwise, <see langword="false" />.</value>
    </member>
    <member name="P:System.Windows.Reactive.Subscription.ValidationRules">
      <summary>
            Gets a collection of rules that check the validity of the user input.
            </summary>
      <value>A collection of <see cref="T:System.Windows.Controls.ValidationRule" /> objects.</value>
    </member>
    <member name="T:System.Windows.DependencyObjectExtensions">
      <summary>
            Provides <see langword="static" /> methods for creating observables from <see cref="T:System.Windows.DependencyObject" /> instances.
            </summary>
    </member>
    <member name="M:System.Windows.DependencyObjectExtensions.DependencyPropertyChanged``1(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
      <summary>
            Gets an observable sequence of property change notifications for the specified <see cref="T:System.Windows.DependencyProperty" />, 
            raised by the specified <see cref="T:System.Windows.DependencyObject" />.
            </summary>
      <typeparam name="TValue">Type of the value represented by the <see cref="T:System.Windows.DependencyProperty" />.</typeparam>
      <param name="obj">The <see cref="T:System.Windows.DependencyObject" /> that defines the specified <paramref name="property" />.</param>
      <param name="property">The <see cref="T:System.Windows.DependencyProperty" /> that raises change notifications for the specified object.</param>
      <returns>An observable sequence of property change notifications for the specified <see cref="T:System.Windows.DependencyProperty" />, 
            raised by the specified <see cref="T:System.Windows.DependencyObject" />.</returns>
      <requires>obj != null</requires>
      <requires>property != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Windows.Reactive.EventSubscription">
      <summary>
            Represents a trigger that, in response to a routed event, invokes a handler that is either a <see cref="T:System.Windows.RoutedEventHandler" /> delegate, 
            an object that implements <see cref="T:System.Windows.Input.ICommand" /> or an object that implements <see cref="T:System.IObserver`1" /> where <strong>T</strong> 
            is a compatible <see cref="T:System.Reactive.EventPattern`1" />.
            </summary>
      <remarks>
        <alert type="warning">
          <see cref="T:System.Windows.Reactive.EventSubscription" /> may only be used in a <see cref="P:System.Windows.FrameworkElement.Triggers" /> collection; otherwise, the specified 
            <see cref="P:System.Windows.Reactive.EventSubscription.Handler" /> will never be called.
            </alert>
      </remarks>
      <invariant>handlerProxy == null || target != null</invariant>
    </member>
    <member name="F:System.Windows.Reactive.EventSubscription.HandlerProperty">
      <summary>
            Identifies the <see cref="P:System.Windows.Reactive.EventSubscription.Handler" /> dependency property.
            </summary>
      <value>The identifier for the <see cref="P:System.Windows.Reactive.EventSubscription.Handler" /> dependency property.</value>
    </member>
    <member name="M:System.Windows.Reactive.EventSubscription.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Windows.Reactive.EventSubscription" /> class.
            </summary>
    </member>
    <member name="M:System.Windows.Reactive.EventSubscription.#ctor(System.Windows.RoutedEvent)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Windows.Reactive.EventSubscription" /> class with the specified <paramref name="routedEvent" />.
            </summary>
      <param name="routedEvent">The <see cref="T:System.Windows.RoutedEvent" /> to be handled.</param>
      <requires>routedEvent != null</requires>
    </member>
    <member name="P:System.Windows.Reactive.EventSubscription.Handler">
      <summary>
            Gets or sets the reference to a handler for the specified <see cref="T:System.Windows.RoutedEvent" />.
            </summary>
      <remarks>
        <para>
            The supported handler types are as follows:
            </para>
        <list type="bullet">
          <item>
            <see cref="T:System.IObserver`1" /> where <strong>T</strong> is <see cref="T:System.Reactive.EventPattern`1" /> and <strong>TEventArgs</strong> 
            is convertible contravariantly to the argument type of the specified <see cref="T:System.Windows.RoutedEvent" />.  See below for more information.
            </item>
          <item>
            <see cref="T:System.Delegate" /> with a matching contravariant signature.  See below for more information.
            </item>
          <item>
            Any implementation of <see cref="T:System.Windows.Input.ICommand" />.  The command parameter will be an instance of 
            <see cref="T:System.Reactive.EventPattern`1" /> where <strong>TEventArgs</strong> is the argument type 
            of the <see cref="T:System.Windows.RoutedEvent" />.
            </item>
        </list>
        <para>
            Contravariance is supported for the parameters of a <see cref="T:System.Windows.RoutedEventHandler" /> delegate.  This means that the 
            delegate's <em>sender</em> parameter can be the exact type or any base class of the <see cref="T:System.Windows.FrameworkElement" /> that raises 
            the specified <see cref="T:System.Windows.RoutedEvent" />.  Furthermore, the <em>EventArgs</em> parameter can be the actual argument type of the 
            specified <see cref="T:System.Windows.RoutedEvent" /> or any base class.
            </para>
        <para>
            Likewise, contravariance is supported for the generic type argument of an object that implements <see cref="T:System.IObserver`1" /> where 
            <strong>T</strong> is <see cref="T:System.Reactive.EventPattern`1" /> and <strong>TEventArgs</strong> can be the actual argument type of the 
            specified <see cref="T:System.Windows.RoutedEvent" /> or any base class to <see cref="T:System.EventArgs" />.
            </para>
      </remarks>
      <value>Reference to the handler that is attached by this trigger.</value>
    </member>
    <member name="P:System.Windows.Reactive.EventSubscription.HandledEventsToo">
      <summary>
            Gets or sets a value indicating whether the <see cref="P:System.Windows.Reactive.EventSubscription.Handler" /> should still be invoked, even if the <see cref="T:System.Windows.RoutedEvent" /> 
            is marked handled in its event data.
            </summary>
      <value>
        <see langword="True" /> if the <see cref="P:System.Windows.Reactive.EventSubscription.Handler" /> should still be invoked; otherwise, <see langword="false" />.
            The default value is <see langword="false" />.</value>
      <getter>
        <requires>handlerProxy == null || target != null</requires>
      </getter>
      <setter>
        <requires>handlerProxy == null || target != null</requires>
      </setter>
    </member>
    <member name="T:System.Windows.FrameworkElementExtensions">
      <summary>
            Provides <see langword="static" /> methods for attaching view models to <see cref="T:System.Windows.FrameworkElement" /> objects.
            </summary>
    </member>
    <member name="M:System.Windows.FrameworkElementExtensions.GetViewModel(System.Windows.FrameworkElement)">
      <summary>
            Gets the object that is currently attached to the specified <paramref name="element" />.
            </summary>
      <remarks>
        <see cref="M:System.Windows.FrameworkElementExtensions.GetViewModel(System.Windows.FrameworkElement)" /> actually returns the value of the <see cref="P:System.Windows.FrameworkElement.DataContext" /> property of the 
            specified <paramref name="element" />, whether or not it represents a view model object.  This may change in a future version.
            </remarks>
      <param name="element">The <see cref="T:System.Windows.FrameworkElement" /> from which the attachment will be returned.</param>
      <returns>The object that is currently attached to the specified <paramref name="element" />.</returns>
      <requires>element != null</requires>
    </member>
    <member name="M:System.Windows.FrameworkElementExtensions.SetViewModel(System.Windows.FrameworkElement,System.Func{System.Object})">
      <summary>
            Attaches a view model returned by the specified function to the <see cref="P:System.Windows.FrameworkElement.DataContext" /> of the 
            specified <paramref name="element" /> each time that the <paramref name="element" /> is loaded, and detaches the current 
            view model each time that the <paramref name="element" /> is unloaded.
            </summary>
      <remarks>
        <para>
          <see cref="M:System.Windows.FrameworkElementExtensions.SetViewModel(System.Windows.FrameworkElement,System.Func{System.Object})" /> allows the element's <see cref="P:System.Windows.FrameworkElement.DataContext" /> 
            to be assigned to different objects or view models after a view model is attached.  When a different object or view 
            model is assigned, the current view model is permanently detached and the element's events are no longer tracked for 
            the specified <paramref name="viewModelFactory" />.  To reassign the factory to the <paramref name="element" />, call 
            <see cref="M:System.Windows.FrameworkElementExtensions.SetViewModel(System.Windows.FrameworkElement,System.Func{System.Object})" /> again.
            </para>
        <para>
            The factory can return the same view model instance every time that it's called or it can create new view models.
            The factory can also return <see langword="null" />.
            </para>
        <alert type="warning">
            Do not return the same view model instance more than once if it implements <see cref="T:System.IDisposable" />; otherwise, the
            view model will be disposed the first time that it's detached, which may cause problems if it's reattached.
            </alert>
        <para>
            The objects returned by the factory do not have to derive from any particular base class or implement any particular 
            interfaces; however, a couple of special interfaces are supported to provide additional functionality.  If an object
            implements <see cref="T:System.IDisposable" />, then its <see cref="M:System.IDisposable.Dispose" /> method is called when the object is 
            detached from the <paramref name="element" />.  If an object implements <see cref="T:System.Windows.Reactive.IViewModel" />, then its 
            <see cref="M:System.Windows.Reactive.IViewModel.Attach(System.Windows.FrameworkElement)" /> and <see cref="M:System.Windows.Reactive.IViewModel.Detach" /> methods are called when appropriate.  Implementations
            for both of these interfaces is provided by the base <see cref="T:Rxx.ViewModel" /> class.
            </para>
      </remarks>
      <param name="element">The <see cref="T:System.Windows.FrameworkElement" /> to which a view model will be attached.</param>
      <param name="viewModelFactory">A function that returns view model objects or <see langword="null" />.</param>
      <requires>element != null</requires>
      <requires>viewModelFactory != null</requires>
    </member>
    <member name="T:System.Windows.Input.AnonymousCommand">
      <summary>
            Represents a functional implementation of <see cref="T:System.Windows.Input.ICommand" />.
            </summary>
      <invariant>canExecute != null</invariant>
      <invariant>execute != null</invariant>
      <invariant>addCanExecuteChanged != null</invariant>
      <invariant>removeCanExecuteChanged != null</invariant>
    </member>
    <member name="M:System.Windows.Input.AnonymousCommand.#ctor(System.Action{System.Object})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Windows.Input.AnonymousCommand" /> class that always returns <see langword="true" />
            from its <see cref="M:System.Windows.Input.AnonymousCommand.CanExecute(System.Object)" /> method.
            </summary>
      <param name="execute">An action that is invoked when <see cref="M:System.Windows.Input.AnonymousCommand.Execute(System.Object)" /> is called.</param>
      <requires>execute != null</requires>
    </member>
    <member name="M:System.Windows.Input.AnonymousCommand.#ctor(System.Func{System.Object,System.Boolean},System.Action{System.Object},System.Action{System.EventHandler},System.Action{System.EventHandler})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Windows.Input.AnonymousCommand" /> class.
            </summary>
      <param name="canExecute">A function that is invoked when <see cref="M:System.Windows.Input.AnonymousCommand.CanExecute(System.Object)" /> is called.</param>
      <param name="execute">An action that is invoked when <see cref="M:System.Windows.Input.AnonymousCommand.Execute(System.Object)" /> is called.</param>
      <param name="addCanExecuteChanged">An action that is called when an event handler is added to <see cref="E:System.Windows.Input.AnonymousCommand.CanExecuteChanged" />.</param>
      <param name="removeCanExecuteChanged">An action that is called when an event handler is removed from <see cref="E:System.Windows.Input.AnonymousCommand.CanExecuteChanged" />.</param>
      <requires>canExecute != null</requires>
      <requires>execute != null</requires>
      <requires>addCanExecuteChanged != null</requires>
      <requires>removeCanExecuteChanged != null</requires>
    </member>
    <member name="M:System.Windows.Input.AnonymousCommand.CanExecute(System.Object)">
      <summary>
            Determines whether the command can execute in its current state.
            </summary>
      <param name="parameter">Data used by the command.  If the command does not require data to be passed, 
            this object can be set to <see langword="null" />.</param>
      <returns>
        <see langword="True" /> if this command can be executed; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Windows.Input.AnonymousCommand.Execute(System.Object)">
      <summary>
            Invokes the command.
            </summary>
      <param name="parameter">Data used by the command.  If the command does not require data to be passed, 
            this object can be set to <see langword="null" />.</param>
    </member>
    <member name="E:System.Windows.Input.AnonymousCommand.CanExecuteChanged">
      <summary>
            Occurs when changes occur that affect whether or not the command should execute.
            </summary>
    </member>
    <member name="T:System.Windows.Input.CommandExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for <see cref="T:System.Windows.Input.ICommand" /> objects.
            </summary>
    </member>
    <member name="M:System.Windows.Input.CommandExtensions.Subscribe(System.Windows.Input.ICommand,System.Type,System.Action{System.Reactive.EventPattern{System.Windows.Input.ExecutedRoutedEventArgs}})">
      <summary>
            Notifies the specified action when any instance of the specified <paramref name="type" /> in a visual UI tree executes the <paramref name="command" />.
            </summary>
      <param name="command">The <see cref="T:System.Windows.Input.ICommand" /> from which notifications are received.</param>
      <param name="type">The <see cref="T:System.Type" /> whos instances execute the specified <paramref name="command" /> from a visual UI tree.</param>
      <param name="onExecuted">The action that is executed when the <paramref name="command" /> is executed.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>command != null</requires>
      <requires>type != null</requires>
      <requires>onExecuted != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.Input.CommandExtensions.Subscribe(System.Windows.Input.ICommand,System.Type,System.Action{System.Reactive.EventPattern{System.Windows.Input.ExecutedRoutedEventArgs}},System.Action{System.Reactive.EventPattern{System.Windows.Input.CanExecuteRoutedEventArgs}})">
      <summary>
            Notifies the specified actions when any instance of the specified <paramref name="type" /> in a visual UI tree queries or executes the <paramref name="command" />.
            </summary>
      <param name="command">The <see cref="T:System.Windows.Input.ICommand" /> from which notifications are received.</param>
      <param name="type">The <see cref="T:System.Type" /> whos instances query or execute the specified <paramref name="command" /> from a visual UI tree.</param>
      <param name="onExecuted">The action that is executed when the <paramref name="command" /> is executed.</param>
      <param name="onCanExecute">The action that is executed when the <paramref name="command" /> is queried as to whether it can be executed.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>command != null</requires>
      <requires>type != null</requires>
      <requires>onExecuted != null</requires>
      <requires>onCanExecute != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.Input.CommandExtensions.Subscribe(System.Windows.Input.ICommand,System.Type,System.Reactive.IPairedObserver{System.Reactive.EventPattern{System.Windows.Input.CanExecuteRoutedEventArgs},System.Reactive.EventPattern{System.Windows.Input.ExecutedRoutedEventArgs}})">
      <summary>
            Notifies the specified <paramref name="observer" /> when any instance of the specified <paramref name="type" /> in a visual UI tree 
            queries or executes the <paramref name="command" />.
            </summary>
      <param name="command">The <see cref="T:System.Windows.Input.ICommand" /> from which notifications are received.</param>
      <param name="type">The <see cref="T:System.Type" /> whos instances query or execute the specified <paramref name="command" /> from a visual UI tree.</param>
      <param name="observer">The object that is to receive notifications.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>command != null</requires>
      <requires>type != null</requires>
      <requires>observer != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.Input.CommandExtensions.Subscribe(System.Windows.Input.ICommand,System.Windows.UIElement,System.Action{System.Reactive.EventPattern{System.Windows.Input.ExecutedRoutedEventArgs}})">
      <summary>
            Notifies the specified action when the specified <paramref name="element" /> executes the <paramref name="command" />.
            </summary>
      <param name="command">The <see cref="T:System.Windows.Input.ICommand" /> from which notifications are received.</param>
      <param name="element">The <see cref="T:System.Windows.UIElement" /> that executes the specified <paramref name="command" />.</param>
      <param name="onExecuted">The action that is executed when the <paramref name="command" /> is executed.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>command != null</requires>
      <requires>element != null</requires>
      <requires>onExecuted != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.Input.CommandExtensions.Subscribe(System.Windows.Input.ICommand,System.Windows.UIElement,System.Action{System.Reactive.EventPattern{System.Windows.Input.ExecutedRoutedEventArgs}},System.Action{System.Reactive.EventPattern{System.Windows.Input.CanExecuteRoutedEventArgs}})">
      <summary>
            Notifies the specified actions when the specified <paramref name="element" /> queries or executes the <paramref name="command" />.
            </summary>
      <param name="command">The <see cref="T:System.Windows.Input.ICommand" /> from which notifications are received.</param>
      <param name="element">The <see cref="T:System.Windows.UIElement" /> that queries or executes the specified <paramref name="command" />.</param>
      <param name="onExecuted">The action that is executed when the <paramref name="command" /> is executed.</param>
      <param name="onCanExecute">The action that is executed when the <paramref name="element" /> queries whether the <paramref name="command" /> can be executed.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>command != null</requires>
      <requires>element != null</requires>
      <requires>onExecuted != null</requires>
      <requires>onCanExecute != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.Input.CommandExtensions.Subscribe(System.Windows.Input.ICommand,System.Windows.UIElement,System.Reactive.IPairedObserver{System.Reactive.EventPattern{System.Windows.Input.CanExecuteRoutedEventArgs},System.Reactive.EventPattern{System.Windows.Input.ExecutedRoutedEventArgs}})">
      <summary>
            Notifies the specified <paramref name="observer" /> when the specified <paramref name="element" /> queries or executes the <paramref name="command" />.
            </summary>
      <param name="command">The <see cref="T:System.Windows.Input.ICommand" /> from which notifications are received.</param>
      <param name="element">The <see cref="T:System.Windows.UIElement" /> that queries or executes the specified <paramref name="command" />.</param>
      <param name="observer">The object that is to receive notifications.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>command != null</requires>
      <requires>element != null</requires>
      <requires>observer != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.Input.CommandExtensions.AsObservable(System.Windows.Input.ICommand,System.Type)">
      <summary>
            Registers a class command binding for the specified <paramref name="type" /> and returns a paired observable sequence, 
            with the right channel receiving notifications when the <paramref name="command" /> is executed and the left channel 
            receiving notifications when the <paramref name="command" /> is queried as to whether it can be executed.
            </summary>
      <param name="command">The <see cref="T:System.Windows.Input.ICommand" /> from which notifications are received.</param>
      <param name="type">The <see cref="T:System.Type" /> whos instances query or execute the specified <paramref name="command" /> from a visual UI tree.</param>
      <returns>A paired observable sequence with the right channel receiving notifications when the <paramref name="command" /> is executed and 
            the left channel receiving notifications when the <paramref name="command" /> is queried as to whether it can be executed.</returns>
      <requires>command != null</requires>
      <requires>type != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;EventPattern&lt;CanExecuteRoutedEventArgs&gt;, EventPattern&lt;ExecutedRoutedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.Input.CommandExtensions.AsObservable(System.Windows.Input.ICommand,System.Windows.UIElement)">
      <summary>
            Adds a command binding to the specified <paramref name="element" /> and returns a paired observable sequence, 
            with the right channel receiving notifications when the <paramref name="command" /> is executed and the left channel 
            receiving notifications when the <paramref name="command" /> is queried as to whether it can be executed.
            </summary>
      <param name="command">The <see cref="T:System.Windows.Input.ICommand" /> from which notifications are received.</param>
      <param name="element">The <see cref="T:System.Windows.UIElement" /> that queries or executes the specified <paramref name="command" />.</param>
      <returns>A paired observable sequence with the right channel receiving notifications when the <paramref name="command" /> is executed and 
            the left channel receiving notifications when the <paramref name="command" /> is queried as to whether it can be executed.</returns>
      <requires>command != null</requires>
      <requires>element != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;EventPattern&lt;CanExecuteRoutedEventArgs&gt;, EventPattern&lt;ExecutedRoutedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.Input.CommandExtensions.CanExecuteObservable(System.Windows.Input.ICommand)">
      <summary>
            Returns an observable sequence that indicates when the <paramref name="command" /> can be executed, 
            starting with the current state of the <paramref name="command" />.
            </summary>
      <remarks>
            The observable is a sequence of values returned by <see cref="M:System.Windows.Input.ICommand.CanExecute(System.Object)" /> 
            whenever the <paramref name="command" /> raises its <see cref="E:System.Windows.Input.ICommand.CanExecuteChanged" /> event.
            </remarks>
      <param name="command">The <see cref="T:System.Windows.Input.ICommand" /> to be observed.</param>
      <returns>An observable sequence that indicates when the <paramref name="command" /> can be executed, 
            starting with the current state of the <paramref name="command" />.</returns>
      <requires>command != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;bool&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.Input.CommandExtensions.CanExecuteObservable(System.Windows.Input.ICommand,System.Object)">
      <summary>
            Returns an observable sequence that indicates when the <paramref name="command" /> can be executed, 
            starting with the current state of the <paramref name="command" />.
            </summary>
      <remarks>
            The observable is a sequence of values returned by <see cref="M:System.Windows.Input.ICommand.CanExecute(System.Object)" /> 
            whenever the <paramref name="command" /> raises its <see cref="E:System.Windows.Input.ICommand.CanExecuteChanged" /> event.
            </remarks>
      <param name="command">The <see cref="T:System.Windows.Input.ICommand" /> to be observed.</param>
      <param name="parameter">The object that is passed to the <see cref="M:System.Windows.Input.ICommand.CanExecute(System.Object)" /> method.
            This value can be <see langword="null" /> if the <paramref name="command" /> supports it.</param>
      <returns>An observable sequence that indicates when the <paramref name="command" /> can be executed, 
            starting with the current state of the <paramref name="command" />.</returns>
      <requires>command != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;bool&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Windows.UIElementExtensions">
      <summary>
            Provides <see langword="static" /> methods for creating observables from <see cref="T:System.Windows.UIElement" /> objects.
            </summary>
    </member>
    <member name="M:System.Windows.UIElementExtensions.RoutedEventRaised(System.Windows.UIElement,System.Windows.RoutedEvent)">
      <summary>
            Gets an observable sequence of event notifications for the specified <see cref="T:System.Windows.RoutedEvent" />, 
            raised by the specified <see cref="T:System.Windows.UIElement" />.
            </summary>
      <param name="element">The <see cref="T:System.Windows.UIElement" /> on which to listen for the specified <paramref name="event" />.</param>
      <param name="event">The <see cref="T:System.Windows.RoutedEvent" /> that is raised.</param>
      <returns>An observable sequence of event notifications for the specified <see cref="T:System.Windows.RoutedEvent" />, 
            raised by the specified <see cref="T:System.Windows.UIElement" />.</returns>
      <requires>element != null</requires>
      <requires>@event != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;RoutedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.UIElementExtensions.RoutedEventRaised(System.Windows.UIElement,System.Windows.RoutedEvent,System.Boolean)">
      <summary>
            Gets an observable sequence of event notifications for the specified <see cref="T:System.Windows.RoutedEvent" />, 
            raised by the specified <see cref="T:System.Windows.UIElement" />.
            </summary>
      <param name="element">The <see cref="T:System.Windows.UIElement" /> on which to listen for the specified <paramref name="event" />.</param>
      <param name="event">The <see cref="T:System.Windows.RoutedEvent" /> that is raised.</param>
      <param name="handledEventsToo">
        <see langword="true" /> to include events marked handled in their event data; 
            <see langword="false" /> to exclude routed events that are already marked handled.</param>
      <returns>An observable sequence of event notifications for the specified <see cref="T:System.Windows.RoutedEvent" />, 
            raised by the specified <see cref="T:System.Windows.UIElement" />.</returns>
      <requires>element != null</requires>
      <requires>@event != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;RoutedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.UIElementExtensions.RoutedEventRaised``1(System.Windows.UIElement,System.Windows.RoutedEvent)">
      <summary>
            Gets an observable sequence of event notifications for the specified <see cref="T:System.Windows.RoutedEvent" />, 
            raised by the specified <see cref="T:System.Windows.UIElement" />.
            </summary>
      <typeparam name="TEventArgs">Type of the object containing the routed event's arguments.</typeparam>
      <param name="element">The <see cref="T:System.Windows.UIElement" /> on which to listen for the specified <paramref name="event" />.</param>
      <param name="event">The <see cref="T:System.Windows.RoutedEvent" /> that is raised.</param>
      <returns>An observable sequence of event notifications for the specified <see cref="T:System.Windows.RoutedEvent" />, 
            raised by the specified <see cref="T:System.Windows.UIElement" />.</returns>
      <requires>element != null</requires>
      <requires>@event != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;TEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.UIElementExtensions.RoutedEventRaised``1(System.Windows.UIElement,System.Windows.RoutedEvent,System.Boolean)">
      <summary>
            Gets an observable sequence of event notifications for the specified <see cref="T:System.Windows.RoutedEvent" />, 
            raised by the specified <see cref="T:System.Windows.UIElement" />.
            </summary>
      <typeparam name="TEventArgs">Type of the object containing the routed event's arguments.</typeparam>
      <param name="element">The <see cref="T:System.Windows.UIElement" /> on which to listen for the specified <paramref name="event" />.</param>
      <param name="event">The <see cref="T:System.Windows.RoutedEvent" /> that is raised.</param>
      <param name="handledEventsToo">
        <see langword="true" /> to include events marked handled in their event data; 
            <see langword="false" /> to exclude routed events that are already marked handled.</param>
      <returns>An observable sequence of event notifications for the specified <see cref="T:System.Windows.RoutedEvent" />, 
            raised by the specified <see cref="T:System.Windows.UIElement" />.</returns>
      <requires>element != null</requires>
      <requires>@event != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;TEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.ViewModel">
      <summary>
            Represents a <see cref="T:System.Windows.FrameworkElement" /> attachment that may provide binding targets for properties and events, and controls the 
            lifetime of its composited resources by permanently disposing of them when the <see cref="T:System.Windows.FrameworkElement" /> is unloaded.
            </summary>
      <remarks name="Full">
        <para>
			A view model provides a decoupled container for the state and behaviors on which a user interface (UI) depends.  State and
			behaviors are typically represented in view models as targets for property and event bindings in the UI, without specific knowledge
			of the type or layout of the UI to which they're bound.
		</para>
        <para>
			Classic view model base classes aren't designed specifically for reactive programming with <see cref="T:System.IObservable`1" />, making them
			somewhat awkward to use in conjunction with observables.  Property bindings with <see cref="T:System.Windows.DependencyProperty" />,
			<see cref="T:System.ComponentModel.INotifyPropertyChanged" /> and event bindings with <see cref="T:System.Windows.Input.ICommand" /> are quite
			useful for decoupling a UI from its reusable state and behaviors, but they make reactive programming difficult because we must first convert
			them into observable sequences to take advantage of the capabilities of the <strong>Rx</strong> declarative programming model and LINQ.
		</para>
        <para>
          <see cref="T:Rxx.ViewModel" /> does not implement <see cref="T:System.ComponentModel.INotifyPropertyChanged" /> because it targets a reactive
			programming model instead.  To bind to a reactive property, simply return any object that implements <see cref="T:System.IObservable`1" />,
			including <see cref="T:System.Reactive.Subjects.IListSubject`1" /> and <see cref="T:System.Reactive.Subjects.IDictionarySubject`2" />
			when collections are needed, then create a binding in XAML using <see cref="T:System.Windows.Reactive.Subscription" />.  To create a reactive
			command, simply return an instance of <see cref="T:System.Reactive.Subjects.CommandSubject" />, then use a UI binding as you normally
			would to an <see cref="T:System.Windows.Input.ICommand" />.  To bind to a UI event, create a property that returns an object that implements
			<see cref="T:System.IObserver`1" />, such as <see cref="T:System.Reactive.Subjects.Subject`1" />, then create a binding in XAML using
			<see cref="T:System.Windows.Reactive.EventSubscription" />.
		</para>
        <para>
			All of the aforementioned solutions use types that implement <see cref="T:System.IObservable`1" />, which makes it possible to define
			complex reactive queries among the different states and behaviors that are encapsulated by the view model.
		</para>
        <para>
			Furthermore, subscribing to an observable sequence yields an <see cref="T:System.IDisposable" /> artifact that represents the subscription.  It
			has a logical lifetime that is the lifetime of the UI to which the view model is attached.  Since the cancelation and disposal model of
			<strong>Rx</strong> is explicit to support fire-and-forget scenarios, often it's required to composite a view model's subscriptions
			and dispose of them when the UI is no longer needed, such as when it's unloaded.  Take a dialog window for example, which may create
			subscriptions to observable sequences that must be canceled and released when the dialog is closed.
		</para>
        <para>
          <see cref="T:Rxx.ViewModel" /> supports this by offering a composited collection of disposables that have the same lifetime as the
			<see cref="T:System.Windows.FrameworkElement" /> to which the view model is attached.  When the <see cref="E:System.Windows.FrameworkElement.Unloaded" /> event is raised,
			all of the view model's disposables are disposed, so if subscriptions to observable sequences are added to the disposables collection
			they are cancelled and freed in a determinstic manner that corresponds directly to the lifetime of the UI.
		</para>
        <para>
			Another common occurence when authoring view models is to subscribe to new observable sequences when the UI element first loads.
			<see cref="T:Rxx.ViewModel" /> facilitates this by providing an <see cref="M:Rxx.ViewModel.Attaching" /> method that derived classes can override.
			<see cref="M:Rxx.ViewModel.Attaching" /> returns a sequence of <see cref="T:System.IDisposable" /> objects that are automatically added to the composited
			disposables collection of the view model.  This makes it possible to subscribe to one or more observable sequences in an iterator
			block by simply yielding each subscription as a result.  The subscriptions yielded are automatically disposed when the UI is unloaded.
		</para>
        <alert type="tip">
			To attach a <see cref="T:Rxx.ViewModel" /> to a <see cref="T:System.Windows.FrameworkElement" /> object, first define a class that derives from
			<see cref="T:Rxx.ViewModel" />.  Then use the <see cref="M:System.Windows.FrameworkElementExtensions.SetViewModel(System.Windows.FrameworkElement,System.Func{System.Object})" /> method and
			return a new instance of your class within the factory argument, or use the <see cref="F:System.Windows.Reactive.View.ModelProperty" />
			attached property in XAML and set it to the <see cref="T:System.Type" /> of your class.
		</alert>
      </remarks>
      <threadsafety instance="false" static="true" />
      <invariant>disposables != null</invariant>
      <invariant>!IsAttached || element != null</invariant>
    </member>
    <member name="M:Rxx.ViewModel.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.ViewModel" /> class for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.ViewModel.Attaching">
      <summary>
            Called after the <see cref="T:Rxx.ViewModel" /> is attached to the <see cref="P:Rxx.ViewModel.Element" />, providing an opportunity to create a set 
            of disposable resources that must be associated with the lifetime of the <see cref="P:Rxx.ViewModel.Element" />.
            </summary>
      <returns>A sequence of <see cref="T:System.IDisposable" /> objects to be associated with the lifetime of the <see cref="P:Rxx.ViewModel.Element" /> 
            to which this <see cref="T:Rxx.ViewModel" /> is attached.  This method can return <see langword="null" />.</returns>
      <requires>IsAttached</requires>
      <ensures>IsAttached</ensures>
    </member>
    <member name="M:Rxx.ViewModel.Detaching">
      <summary>
            Called immediately before the <see cref="T:Rxx.ViewModel" /> is detached from the <see cref="P:Rxx.ViewModel.Element" />.
            </summary>
      <requires>IsAttached</requires>
    </member>
    <member name="M:Rxx.ViewModel.AddDisposables(System.IDisposable[])">
      <summary>
            Adds the specified <paramref name="disposables" /> to the <see cref="T:Rxx.ViewModel" />, associating their lifetime with the lifetime 
            of the view model.
            </summary>
      <param name="disposables">An array of <see cref="T:System.IDisposable" /> objects to be added.</param>
      <requires>disposables != null</requires>
    </member>
    <member name="M:Rxx.ViewModel.RemoveDisposables(System.IDisposable[])">
      <summary>
            Removes and immediately disposes of the specified <paramref name="disposables" />.
            </summary>
      <param name="disposables">An array of <see cref="T:System.IDisposable" /> objects to be removed.</param>
      <requires>disposables != null</requires>
    </member>
    <member name="M:Rxx.ViewModel.ContainsDisposable(System.IDisposable)">
      <summary>
            Returns whether the <see cref="T:Rxx.ViewModel" /> contains the specified <paramref name="disposable" />.
            </summary>
      <param name="disposable">The disposable to search for.</param>
      <returns>
        <see langword="True" /> if the specified <paramref name="disposable" /> is contained by the <see cref="T:Rxx.ViewModel" />; otherwise, 
            <see langword="false" />.</returns>
    </member>
    <member name="M:Rxx.ViewModel.ClearDisposables">
      <summary>
            Removes and immediately disposes of all disposable resources that are currently contained in the view model.
            </summary>
    </member>
    <member name="M:Rxx.ViewModel.Dispose">
      <summary>
            Releases all resources used by an instance of the <see cref="T:Rxx.ViewModel" /> class, including all composited disposables that 
            were added by the <see cref="M:Rxx.ViewModel.AddDisposables(System.IDisposable[])" /> method or returned by the <see cref="M:Rxx.ViewModel.Attaching" /> method.
            </summary>
      <remarks>
            This method calls the virtual <see cref="M:Rxx.ViewModel.Dispose(System.Boolean)" /> method, passing in <see langword="true" />, and then suppresses 
            finalization of the instance.
            </remarks>
    </member>
    <member name="M:Rxx.ViewModel.Dispose(System.Boolean)">
      <summary>
            Releases the unmanaged resources used by an instance of the <see cref="T:Rxx.ViewModel" /> class and optionally releases the managed resources.
            </summary>
      <param name="disposing">
        <see langword="True" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
    </member>
    <member name="P:Rxx.ViewModel.IsAttached">
      <summary>
            Gets a value indicating whether the view model is currently attached to a <see cref="T:System.Windows.FrameworkElement" />.
            </summary>
      <value>
        <see langword="True" /> if the view model is attached; otherwise, <see langword="false" />.</value>
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == (Element != null)</ensures>
      </getter>
    </member>
    <member name="P:Rxx.ViewModel.IsInDesignMode">
      <summary>
            Gets a value indicating whether this view model instance is currently being used in a designer.
            </summary>
    </member>
    <member name="P:Rxx.ViewModel.Element">
      <summary>
            Gets the <see cref="T:System.Windows.FrameworkElement" /> to which this view model is attached.
            </summary>
      <value>The <see cref="T:System.Windows.FrameworkElement" /> to which this view model is attached when <see cref="P:Rxx.ViewModel.IsAttached" />
            is <see langword="true" />; otherwise, <see langword="null" />.</value>
      <getter>
        <ensures>(Contract.Result&lt;FrameworkElement&gt;() == null) == !IsAttached</ensures>
        <ensures>Contract.Result&lt;FrameworkElement&gt;() == element</ensures>
      </getter>
    </member>
    <member name="T:System.Windows.Input.CommandExtensions.TypeCommandPair">
      <invariant>command != null</invariant>
      <invariant>type != null</invariant>
    </member>
    <member name="M:System.Windows.Input.CommandExtensions.TypeCommandPair.#ctor(System.Windows.Input.ICommand,System.Type)">
      <requires>command != null</requires>
      <requires>type != null</requires>
    </member>
    <member name="M:System.Windows.Reactive.EventSubscription.Convert(System.Windows.RoutedEvent,System.Object)">
      <requires>routedEvent != null</requires>
      <requires>value != null</requires>
      <requires>eventPatternType != null</requires>
      <ensures>Contract.Result&lt;Delegate&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.Reactive.EventSubscription.Unsubscribe(System.Windows.RoutedEvent)">
      <requires>routedEvent != null</requires>
    </member>
    <member name="M:System.Windows.Reactive.EventSubscription.CreateDelegateProxy(System.Type,System.Delegate)">
      <requires>eventType != null</requires>
      <requires>actualHandler != null</requires>
      <ensures>Contract.Result&lt;Delegate&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.Reactive.EventSubscription.ExecuteCommand(System.Object,System.Windows.RoutedEventArgs)">
      <requires>command != null</requires>
      <requires>eventPatternType != null</requires>
    </member>
    <member name="M:System.Windows.Reactive.EventSubscription.HandlerChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
      <requires>obj != null</requires>
    </member>
    <member name="M:System.Windows.Reactive.EventSubscription.NotifyObserver(System.Object,System.Windows.RoutedEventArgs)">
      <requires>observer != null</requires>
      <requires>observerPatternType != null</requires>
      <requires>onNext != null</requires>
    </member>
    <member name="M:System.Windows.Reactive.EventSubscription.RaiseEvent(System.Object,System.Windows.RoutedEventArgs)">
      <requires>handler != null</requires>
    </member>
    <member name="M:System.Windows.Reactive.EventSubscription.GetEventArgsType(System.Windows.RoutedEvent)">
      <requires>routedEvent != null</requires>
      <ensures>Contract.Result&lt;Type&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.Reactive.EventSubscription.EnsureDelegateIsCompatible(System.Type,System.Type,System.Delegate)">
      <requires>senderType != null</requires>
      <requires>eventArgsType != null</requires>
      <requires>handler != null</requires>
    </member>
    <member name="M:System.Windows.Reactive.EventSubscription.TryCreateObserverProxy(System.Windows.RoutedEvent,System.Object)">
      <requires>routedEvent != null</requires>
      <requires>eventPatternType != null</requires>
      <requires>value != null</requires>
    </member>
    <member name="M:System.Windows.Reactive.View.ModelChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
      <requires>sender is FrameworkElement</requires>
    </member>
    <member name="T:System.Windows.Reactive.ObservableValueConverter">
      <invariant>subscription != null</invariant>
    </member>
    <member name="P:System.Windows.Reactive.ObservableValueConverter.ValueExpression">
      <getter>
        <ensures>Contract.Result&lt;BindingExpressionBase&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:System.Windows.Reactive.ObservableValueConverter.ValueConverterCulture">
      <getter>
        <requires>subscription != null</requires>
      </getter>
      <setter>
        <requires>subscription != null</requires>
      </setter>
    </member>
    <member name="P:System.Windows.Reactive.ObservableValueConverter.Expression">
      <getter>
        <requires>subscription != null</requires>
      </getter>
      <setter>
        <requires>subscription != null</requires>
      </setter>
    </member>
    <member name="M:System.Windows.Reactive.ObservableValueConverter.SubscribeNotify(System.Windows.Data.DispatchChangesEnumerable)">
      <requires>notifier != null</requires>
      <requires>source != null</requires>
    </member>
    <member name="M:System.Windows.Reactive.ObservableValueConverter.Subscribe">
      <requires>source != null</requires>
    </member>
    <member name="P:System.Windows.Reactive.ObservableValueConverter.ValueConverterParameter">
      <getter>
        <requires>subscription != null</requires>
      </getter>
      <setter>
        <requires>subscription != null</requires>
      </setter>
    </member>
    <member name="P:System.Windows.Reactive.ObservableValueConverter.ValueConverter">
      <getter>
        <requires>subscription != null</requires>
      </getter>
      <setter>
        <requires>subscription != null</requires>
      </setter>
    </member>
    <member name="M:System.Windows.Reactive.ObservableValueConverter.Bind(System.Object,System.Type)">
      <requires>targetType != null</requires>
    </member>
    <member name="M:System.Windows.Reactive.ObservableValueConverter.SubscribeCollection">
      <requires>source != null</requires>
      <requires>listSource != null</requires>
    </member>
    <member name="M:System.Windows.FrameworkElementExtensions.SetViewModel(System.Windows.FrameworkElement,System.Type)">
      <requires>element != null</requires>
      <requires>type != null</requires>
    </member>
    <member name="M:System.Windows.FrameworkElementExtensions.Detach(System.Windows.FrameworkElement,System.Object@,System.Windows.Reactive.IViewModel@,System.Boolean@)">
      <requires>element != null</requires>
    </member>
    <member name="M:System.Windows.FrameworkElementExtensions.Attach(System.Windows.FrameworkElement,System.Func{System.Object},System.Boolean@,System.Boolean@,System.Windows.Reactive.IViewModel@)">
      <requires>element != null</requires>
      <requires>viewModelFactory != null</requires>
      <requires>!attached</requires>
      <ensures>Contract.ValueAtReturn(out attached)</ensures>
    </member>
    <member name="T:System.Windows.Data.DispatchChangesEnumerable">
      <invariant>dispatcher != null</invariant>
      <invariant>enumerable != null</invariant>
    </member>
    <member name="M:System.Windows.Data.DispatchChangesEnumerable.#ctor(System.Windows.Threading.Dispatcher,System.Windows.Threading.DispatcherPriority,System.Collections.IEnumerable)">
      <requires>dispatcher != null</requires>
      <requires>enumerable != null</requires>
    </member>
    <member name="M:System.Windows.Data.DispatchChangesEnumerable.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:System.ObservableDynamicObject.#ctor(System.Object)">
      <requires>source != null</requires>
    </member>
    <member name="M:System.ObservableDynamicObject.TryGetPropertyObservable(System.String,System.StringComparison,System.Object@)">
      <requires>propertyName != null</requires>
      <ensures>!Contract.Result&lt;bool&gt;() || Contract.ValueAtReturn(out result) != null</ensures>
    </member>
    <member name="M:System.ObservableDynamicObject.TryGetEventObservable(System.String,System.StringComparison,System.Object@)">
      <requires>eventName != null</requires>
      <ensures>!Contract.Result&lt;bool&gt;() || Contract.ValueAtReturn(out result) != null</ensures>
    </member>
    <member name="T:System.Reactive.EventProxyObservable">
      <invariant>observable != null</invariant>
    </member>
    <member name="M:System.Reactive.EventProxyObservable.#ctor(System.Object,System.ComponentModel.EventDescriptor)">
      <requires>source != null</requires>
      <requires>@event != null</requires>
    </member>
    <member name="M:System.Reactive.EventProxyObservable.Subscribe(System.IObserver{System.Reactive.EventPattern{System.EventArgs}})">
      <requires inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.Exists.Value">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_Value" inheritedFromTypeName="CollectionNotification">HasValue</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.Exists.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.Exists.Kind">
      <getter>
        <ensures>Contract.Result&lt;CollectionNotificationKind&gt;() == CollectionNotificationKind.Exists</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.Exists.HasValue">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.CollectionNotification`1.get_HasValue" inheritedFromTypeName="CollectionNotification">Contract.Result&lt;bool&gt;() == (Kind != CollectionNotificationKind.OnCleared)</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.Exists.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.Exists.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.Exists.ReplacedValue">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_ReplacedValue" inheritedFromTypeName="CollectionNotification">Kind == CollectionNotificationKind.OnReplaced</requires>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnRemoved.Value">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_Value" inheritedFromTypeName="CollectionNotification">HasValue</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnRemoved.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnRemoved.Kind">
      <getter>
        <ensures>Contract.Result&lt;CollectionNotificationKind&gt;() == CollectionNotificationKind.OnRemoved</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnRemoved.HasValue">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.CollectionNotification`1.get_HasValue" inheritedFromTypeName="CollectionNotification">Contract.Result&lt;bool&gt;() == (Kind != CollectionNotificationKind.OnCleared)</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnRemoved.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnRemoved.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnRemoved.ReplacedValue">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_ReplacedValue" inheritedFromTypeName="CollectionNotification">Kind == CollectionNotificationKind.OnReplaced</requires>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnAdded.Value">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_Value" inheritedFromTypeName="CollectionNotification">HasValue</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnAdded.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnAdded.Kind">
      <getter>
        <ensures>Contract.Result&lt;CollectionNotificationKind&gt;() == CollectionNotificationKind.OnAdded</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnAdded.HasValue">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.CollectionNotification`1.get_HasValue" inheritedFromTypeName="CollectionNotification">Contract.Result&lt;bool&gt;() == (Kind != CollectionNotificationKind.OnCleared)</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnAdded.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnAdded.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnAdded.ReplacedValue">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_ReplacedValue" inheritedFromTypeName="CollectionNotification">Kind == CollectionNotificationKind.OnReplaced</requires>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnCleared.Value">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_Value" inheritedFromTypeName="CollectionNotification">HasValue</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnCleared.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnCleared.Kind">
      <getter>
        <ensures>Contract.Result&lt;CollectionNotificationKind&gt;() == CollectionNotificationKind.OnCleared</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnCleared.HasValue">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.CollectionNotification`1.get_HasValue" inheritedFromTypeName="CollectionNotification">Contract.Result&lt;bool&gt;() == (Kind != CollectionNotificationKind.OnCleared)</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnCleared.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnCleared.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnCleared.ReplacedValue">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_ReplacedValue" inheritedFromTypeName="CollectionNotification">Kind == CollectionNotificationKind.OnReplaced</requires>
      </getter>
    </member>
    <member name="T:System.Reactive.CollectionNotification`1.OnReplaced">
      <invariant>Kind == CollectionNotificationKind.OnReplaced</invariant>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnReplaced.Value">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_Value" inheritedFromTypeName="CollectionNotification">HasValue</requires>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnReplaced.Kind">
      <getter>
        <ensures>Contract.Result&lt;CollectionNotificationKind&gt;() == CollectionNotificationKind.OnReplaced</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnReplaced.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnReplaced.HasValue">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.CollectionNotification`1.get_HasValue" inheritedFromTypeName="CollectionNotification">Contract.Result&lt;bool&gt;() == (Kind != CollectionNotificationKind.OnCleared)</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnReplaced.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnReplaced.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnReplaced.ReplacedValue">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_ReplacedValue" inheritedFromTypeName="CollectionNotification">Kind == CollectionNotificationKind.OnReplaced</requires>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Clear.Value">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionModification`1.get_Value" inheritedFromTypeName="CollectionModification">HasValue</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Clear.Accept(System.Action{`0},System.Action{`0},System.Action)">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">add != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">remove != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">clear != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Clear.Kind">
      <getter>
        <ensures>Contract.Result&lt;CollectionModificationKind&gt;() == CollectionModificationKind.Clear</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Clear.HasValue">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.CollectionModification`1.get_HasValue" inheritedFromTypeName="CollectionModification">Contract.Result&lt;bool&gt;() == (Kind != CollectionModificationKind.Clear)</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Clear.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Clear.Accept(System.Collections.Generic.ICollection{`0})">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Collections.Generic.ICollection{`0})" inheritedFromTypeName="CollectionModification">collection != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Clear.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">add != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">remove != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">clear != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Remove.Value">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionModification`1.get_Value" inheritedFromTypeName="CollectionModification">HasValue</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Remove.Accept(System.Action{`0},System.Action{`0},System.Action)">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">add != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">remove != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">clear != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Remove.Kind">
      <getter>
        <ensures>Contract.Result&lt;CollectionModificationKind&gt;() == CollectionModificationKind.Remove</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Remove.HasValue">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.CollectionModification`1.get_HasValue" inheritedFromTypeName="CollectionModification">Contract.Result&lt;bool&gt;() == (Kind != CollectionModificationKind.Clear)</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Remove.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Remove.Accept(System.Collections.Generic.ICollection{`0})">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Collections.Generic.ICollection{`0})" inheritedFromTypeName="CollectionModification">collection != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Remove.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">add != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">remove != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">clear != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Add.Value">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionModification`1.get_Value" inheritedFromTypeName="CollectionModification">HasValue</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Add.Accept(System.Action{`0},System.Action{`0},System.Action)">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">add != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">remove != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">clear != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Add.Kind">
      <getter>
        <ensures>Contract.Result&lt;CollectionModificationKind&gt;() == CollectionModificationKind.Add</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Add.HasValue">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.CollectionModification`1.get_HasValue" inheritedFromTypeName="CollectionModification">Contract.Result&lt;bool&gt;() == (Kind != CollectionModificationKind.Clear)</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Add.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Add.Accept(System.Collections.Generic.ICollection{`0})">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Collections.Generic.ICollection{`0})" inheritedFromTypeName="CollectionModification">collection != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Add.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">add != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">remove != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">clear != null</requires>
    </member>
    <member name="M:System.Reactive.OperationalObservable`1.#ctor(System.IObservable{`0},System.Func{System.IObservable{`0},System.IObservable{`0},System.Func{`0,`0,`0},System.IObservable{`0}},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0},System.Func{`0,`0})">
      <requires>source != null</requires>
    </member>
    <member name="M:System.Reactive.IdentifiedTraceObserver`1.AutoIdentify">
      <ensures>!string.IsNullOrWhiteSpace(Contract.Result&lt;string&gt;())</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromPropertyChangedPattern(System.Object,System.Reflection.PropertyInfo)">
      <requires>source != null</requires>
      <requires>propertyInfo != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;PropertyChangedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Coerce(System.IObservable{System.Reactive.EventPattern{System.EventArgs}},System.Type)">
      <requires>source != null</requires>
      <requires>targetEventArgsType != null</requires>
      <ensures>Contract.Result&lt;object&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Coerce(System.IObservable{System.Object},System.Type)">
      <requires>source != null</requires>
      <requires>targetElementType != null</requires>
      <ensures>Contract.Result&lt;object&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``5(System.Func{System.IDisposable,``0},System.IObservable{``1},System.IObservable{System.Reactive.CollectionModification{``3}},System.Func{``1,``2},System.Func{``3,``2},System.Func{``2,``1,System.Reactive.CollectionNotification{``3}},System.Func{System.IObservable{System.Reactive.CollectionNotification{``3}},System.IObservable{System.Reactive.CollectionModification{``4}}},System.Collections.Generic.IEqualityComparer{``2})">
      <requires>subjectFactory != null</requires>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <requires>existingKeySelector != null</requires>
      <requires>changeKeySelector != null</requires>
      <requires>existsNotificationFactory != null</requires>
      <requires>selector != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;TSubject&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.While``1(System.Func{System.Boolean},System.IObservable{``0})">
      <requires>condition != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.GetDefaultMaxConcurrent">
      <ensures>Contract.Result&lt;int&gt;() &gt; 0</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromEventBasedAsyncPattern``2(System.Func{System.EventHandler{``1},``0},System.Action{``0},System.Action{``0},System.Action{System.Object},System.Action,System.Action)">
      <requires>conversion != null</requires>
      <requires>addHandler != null</requires>
      <requires>removeHandler != null</requires>
      <requires>start != null</requires>
      <requires>cancel != null</requires>
      <requires>canceledOrCompleted != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;TEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.ZipNext``1(System.Collections.Generic.IList{System.Collections.Generic.Queue{System.Reactive.Notification{``0}}},System.Boolean@,System.Reactive.Notification{``0},System.Int32)">
      <requires>queues != null</requires>
      <requires>(current != null) == (currentQueueIndex &gt; -1)</requires>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.UsingHot``2(``1,System.Func{``1,System.IObservable{``0}})">
      <requires>resource != null</requires>
      <requires>hotObservableFactory != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.UInt32},System.Func{System.IObservable{System.UInt32},System.IObservable{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32},System.IObservable{System.UInt32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Byte},System.Func{System.IObservable{System.Byte},System.IObservable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.UInt16},System.Func{System.IObservable{System.UInt16},System.IObservable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Decimal},System.Func{System.IObservable{System.Decimal},System.IObservable{System.Decimal},System.Func{System.Decimal,System.Decimal,System.Decimal},System.IObservable{System.Decimal}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Double},System.Func{System.IObservable{System.Double},System.IObservable{System.Double},System.Func{System.Double,System.Double,System.Double},System.IObservable{System.Double}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Int16},System.Func{System.IObservable{System.Int16},System.IObservable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.SByte},System.Func{System.IObservable{System.SByte},System.IObservable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Int64},System.Func{System.IObservable{System.Int64},System.IObservable{System.Int64},System.Func{System.Int64,System.Int64,System.Int64},System.IObservable{System.Int64}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Single},System.Func{System.IObservable{System.Single},System.IObservable{System.Single},System.Func{System.Single,System.Single,System.Single},System.IObservable{System.Single}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Int32},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.UInt64},System.Func{System.IObservable{System.UInt64},System.IObservable{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64},System.IObservable{System.UInt64}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Char},System.Func{System.IObservable{System.Char},System.IObservable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.AnonymousPairedObservable`2">
      <invariant>observable != null</invariant>
    </member>
    <member name="M:System.Reactive.AnonymousPairedObservable`2.Subscribe(System.IObserver{System.Either{`0,`1}})">
      <requires inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.AnonymousPairedObservable`2.Subscribe(System.Reactive.IPairedObserver{`0,`1})">
      <requires inheritedFrom="M:System.Reactive.IPairedObservable`2.Subscribe(System.Reactive.IPairedObserver{`0,`1})" inheritedFromTypeName="IPairedObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.Reactive.IPairedObservable`2.Subscribe(System.Reactive.IPairedObserver{`0,`1})" inheritedFromTypeName="IPairedObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.CoercingObserver`2">
      <invariant>target != null</invariant>
    </member>
    <member name="M:System.Reactive.CoercingObserver`2.#ctor(System.IObserver{`1})">
      <requires>target != null</requires>
    </member>
    <member name="M:System.Reactive.CoercingObserver`2.OnError(System.Exception)">
      <requires inheritedFrom="M:System.IObserver`1.OnError(System.Exception)" inheritedFromTypeName="IObserver">error != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection">!Contract.Result&lt;bool&gt;() || this.Count &gt; 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
      <requires>e != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.IndexedDictionary.IndexOf(`0)">
      <ensures>Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      <ensures>Contract.Result&lt;int&gt;() &lt; Count</ensures>
    </member>
    <member name="P:System.Reactive.Subjects.DictionarySubject`2.IndexedDictionary.Keys">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;TKey&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.DictionarySubject`2.IndexedDictionary.Values">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;TValue&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection">this.Count &gt;= Contract.OldValue(this.Count)</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.#ctor(System.IDisposable,System.Collections.Generic.IEqualityComparer{`0})">
      <requires>compositedDisposable != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex + this.Count  &lt;= array.Length</requires>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
      <requires>e != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.#ctor(System.IDisposable)">
      <requires>compositedDisposable != null</requires>
    </member>
    <member name="T:System.Reactive.Subjects.ReconnectableObservable`2">
      <invariant>gate != null</invariant>
      <invariant>source != null</invariant>
      <invariant>factory != null</invariant>
    </member>
    <member name="M:System.Reactive.Subjects.ReconnectableObservable`2.#ctor(System.IObservable{`0},System.Func{System.Reactive.Subjects.ISubject{`0,`1}})">
      <requires>source != null</requires>
      <requires>factory != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ReconnectableObservable`2.Subscribe(System.IObserver{`1})">
      <requires inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="P:System.Reactive.Subjects.ReconnectableObservable`2.Subject">
      <getter>
        <ensures>Contract.Result&lt;ISubject&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection">!Contract.Result&lt;bool&gt;() || this.Count &gt; 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex + this.Count  &lt;= array.Length</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection">this.Count &gt;= Contract.OldValue(this.Count)</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.#ctor(System.IDisposable)">
      <requires>compositedDisposable != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="T:System.Reactive.AnonymousPairedObserver`2">
      <invariant>observer != null</invariant>
    </member>
    <member name="M:System.Reactive.AnonymousPairedObserver`2.OnError(System.Exception)">
      <requires inheritedFrom="M:System.IObserver`1.OnError(System.Exception)" inheritedFromTypeName="IObserver">error != null</requires>
    </member>
    <member name="T:System.Reactive.CoercingObservable`2">
      <invariant>source != null</invariant>
    </member>
    <member name="M:System.Reactive.CoercingObservable`2.#ctor(System.IObservable{`0})">
      <requires>source != null</requires>
    </member>
    <member name="M:System.Reactive.CoercingObservable`2.Subscribe(System.IObserver{`1})">
      <requires inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.CoercingObservable`2.CreateObserver(System.IObserver{`1})">
      <requires>observer != null</requires>
      <ensures>Contract.Result&lt;CoercingObserver&lt;TSource, TTarget&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.EventCoercingObservable`2.#ctor(System.IObservable{System.Reactive.EventPattern{`0}})">
      <requires>source != null</requires>
    </member>
    <member name="M:System.Reactive.EventCoercingObservable`2.CreateObserver(System.IObserver{System.Reactive.EventPattern{`1}})">
      <requires inheritedFrom="M:System.Reactive.CoercingObservable`2.CreateObserver(System.IObserver{`1})" inheritedFromTypeName="CoercingObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.Reactive.CoercingObservable`2.CreateObserver(System.IObserver{`1})" inheritedFromTypeName="CoercingObservable">Contract.Result&lt;CoercingObserver&lt;TSource, TTarget&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.SynchronizedObservableCursor`1">
      <invariant>gate != null</invariant>
      <invariant>cursor != null</invariant>
    </member>
    <member name="P:System.Reactive.SynchronizedObservableCursor`1.AtEndOfSequence">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">!Contract.Result&lt;bool&gt;() || IsSequenceTerminated</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.SynchronizedObservableCursor`1.LatestIndex">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_LatestIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.SynchronizedObservableCursor`1.Branch">
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSynchronized == IsSynchronized</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="M:System.Reactive.SynchronizedObservableCursor`1.#ctor(System.Reactive.IObservableCursor{`0},System.Object)">
      <requires>cursor != null</requires>
      <ensures>IsSynchronized</ensures>
      <ensures>IsForwardOnly == cursor.IsForwardOnly</ensures>
    </member>
    <member name="M:System.Reactive.SynchronizedObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">observer != null</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">count &gt;= 0</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="P:System.Reactive.SynchronizedObservableCursor`1.CurrentIndex">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.SynchronizedObservableCursor`1.IsSynchronized">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;()</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.SynchronizedObservableCursor`1.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.SynchronizedObservableCursor`1.Subscribe(System.IObserver{`0})">
      <requires inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.SynchronizedObservableCursor`1.Move(System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="T:System.Reactive.ObservableCursor`1">
      <invariant>disposables != null</invariant>
      <invariant>!IsSynchronized</invariant>
      <invariant>subscriptions != null</invariant>
      <invariant>elements != null</invariant>
      <invariant>branches != null</invariant>
      <invariant>!connected || sourceSubscription != null</invariant>
      <invariant>currentIndex &gt;= 0</invariant>
      <invariant>currentIndex &gt;= firstElementIndex</invariant>
      <invariant>latestIndex &gt;= -1</invariant>
      <invariant>firstElementIndex &gt;= 0</invariant>
      <invariant>isForwardOnly || firstElementIndex == 0</invariant>
      <invariant>latestIndex == -1 || firstElementIndex &gt; 0 || elements.Count &gt; 0</invariant>
      <invariant>currentIndex &gt; latestIndex || elements.Count &gt;= latestIndex - currentIndex</invariant>
      <invariant>stopped || latestIndex &lt; firstElementIndex + elements.Count</invariant>
      <invariant>!stopped || latestIndex &lt; firstElementIndex + (elements.Count - oneForTerminationNotification)</invariant>
      <invariant>!stopped || firstElementIndex &lt;= latestIndex + oneForTerminationNotification</invariant>
      <invariant>!stopped || currentIndex &lt;= latestIndex + oneForTerminationNotification</invariant>
      <invariant description="Completion must enqueue an OnError or OnCompleted notification in addition to any memoized OnNext notifications.">!stopped || elements.Count &gt; 0</invariant>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.Connect">
      <ensures>latestIndex &gt;= -1</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.Move(System.Int32)">
      <ensures>elements.Count &lt;= Contract.OldValue(elements.Count)</ensures>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.Branch">
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSynchronized == IsSynchronized</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.IsForwardOnly">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == isForwardOnly</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.#ctor(System.IObservable{`0},System.Boolean)">
      <requires>source != null</requires>
      <ensures>IsForwardOnly == isForwardOnly</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">observer != null</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">count &gt;= 0</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.RemovePassedElements">
      <requires>isForwardOnly</requires>
      <ensures>CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures>LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>firstElementIndex &gt;= Contract.OldValue(firstElementIndex)</ensures>
      <ensures>elements.Count &lt;= Contract.OldValue(elements.Count)</ensures>
      <ensures>(Contract.OldValue(elements.Count) - elements.Count) &lt;= (firstElementIndex - Contract.OldValue(firstElementIndex))</ensures>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.CurrentIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == currentIndex</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.Terminated">
      <requires>!stopped</requires>
      <ensures>stopped</ensures>
      <ensures>latestIndex == Contract.OldValue(latestIndex)</ensures>
      <ensures>currentIndex &lt;= latestIndex + oneForTerminationNotification</ensures>
      <ensures>firstElementIndex &lt;= latestIndex + oneForTerminationNotification</ensures>
      <ensures>elements.Count == Contract.OldValue(elements.Count)</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.EnsureNotDisposed">
      <ensures>!disposed</ensures>
      <ensures>CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures>LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures>firstElementIndex == Contract.OldValue(firstElementIndex)</ensures>
      <ensures>elements.Count == Contract.OldValue(elements.Count)</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.Subscribe(System.IObserver{`0})">
      <requires inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.IsDisposed">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == disposed</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.Reset">
      <ensures>!stopped</ensures>
      <ensures>currentIndex == 0</ensures>
      <ensures>latestIndex == -1</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.CopyExistingElementsTo(System.Reactive.Notification{`0}[],System.Int32,System.Int32)">
      <ensures>currentIndex == Contract.OldValue(currentIndex)</ensures>
      <ensures>latestIndex == Contract.OldValue(latestIndex)</ensures>
      <ensures>firstElementIndex == Contract.OldValue(firstElementIndex)</ensures>
      <ensures>elements.Count == Contract.OldValue(elements.Count)</ensures>
      <ensures>stopped == Contract.OldValue(stopped)</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.GetLowestIndex">
      <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      <ensures>Contract.Result&lt;int&gt;() &lt;= currentIndex</ensures>
      <ensures>IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures>CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures>LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>firstElementIndex == Contract.OldValue(firstElementIndex)</ensures>
      <ensures>elements.Count == Contract.OldValue(elements.Count)</ensures>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.AtEndOfSequence">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == (stopped &amp;&amp; currentIndex == latestIndex + oneForTerminationNotification)</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">!Contract.Result&lt;bool&gt;() || IsSequenceTerminated</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.Dispose">
      <ensures>disposed</ensures>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.LatestIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == latestIndex</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_LatestIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.#ctor(System.Boolean)">
      <ensures>IsForwardOnly == isForwardOnly</ensures>
    </member>
    <member name="T:System.Reactive.ObservableCursor`1.ObservableCursorBranch">
      <invariant>!IsSynchronized</invariant>
      <invariant>disposables != null</invariant>
      <invariant>cursor != null</invariant>
      <invariant>cursor.branches != null</invariant>
      <invariant>cursor.elements != null</invariant>
      <invariant>cursor.latestIndex &gt;= -1</invariant>
      <invariant>IsForwardOnly == cursor.IsForwardOnly</invariant>
      <invariant>disposed || LatestIndex == cursor.LatestIndex</invariant>
      <invariant>disposed || IsSequenceTerminated == cursor.IsSequenceTerminated</invariant>
      <invariant>currentIndex &gt;= 0</invariant>
      <invariant>disposed || currentIndex &gt;= cursor.firstElementIndex</invariant>
      <invariant>disposed || currentIndex &gt; cursor.latestIndex || cursor.elements.Count &gt;= cursor.latestIndex - currentIndex</invariant>
      <invariant>disposed || !cursor.stopped || currentIndex &lt;= cursor.latestIndex + oneForTerminationNotification</invariant>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorBranch.AtEndOfSequence">
      <getter>
        <ensures>!disposed</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">!Contract.Result&lt;bool&gt;() || IsSequenceTerminated</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorBranch.CurrentIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == currentIndex</ensures>
        <ensures>!disposed</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
      <setter>
        <requires>value &gt;= 0</requires>
        <requires>value &lt;= LatestIndex + 1</requires>
      </setter>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorBranch.LatestIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == cursor.latestIndex</ensures>
        <ensures>!disposed</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_LatestIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorBranch.IsSequenceTerminated">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.stopped</ensures>
        <ensures>!disposed</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorBranch.IsForwardOnly">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.isForwardOnly</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorBranch.Subscribe(System.IObserver{`0},System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">observer != null</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">count &gt;= 0</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorBranch.#ctor(System.Reactive.ObservableCursor{`0},System.Int32,System.Reactive.Disposables.CompositeDisposable)">
      <requires>cursor != null</requires>
      <requires>cursor.branches != null</requires>
      <requires>cursor.elements != null</requires>
      <requires>cursor.latestIndex &gt;= -1</requires>
      <requires>currentIndex &gt;= 0</requires>
      <requires>currentIndex &gt;= cursor.firstElementIndex</requires>
      <requires>currentIndex &gt; cursor.latestIndex || cursor.elements.Count &gt;= cursor.latestIndex - currentIndex</requires>
      <requires>!cursor.stopped || currentIndex &lt;= cursor.latestIndex + 1</requires>
      <requires>parentDisposables != null</requires>
      <ensures>this.cursor == cursor</ensures>
      <ensures>this.currentIndex == currentIndex</ensures>
      <ensures>!IsSynchronized</ensures>
      <ensures>IsForwardOnly == cursor.IsForwardOnly</ensures>
      <ensures>IsSequenceTerminated == cursor.IsSequenceTerminated</ensures>
      <ensures>LatestIndex == cursor.latestIndex</ensures>
      <ensures>CurrentIndex == currentIndex</ensures>
      <ensures>AtEndOfSequence == (cursor.IsSequenceTerminated &amp;&amp; currentIndex == cursor.latestIndex + 1)</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorBranch.SubscribeInternal(System.IObserver{`0},System.Int32)">
      <requires>observer != null</requires>
      <requires>count &gt;= subscribeUnlimited</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorBranch.Subscribe(System.IObserver{`0})">
      <requires inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorBranch.Branch">
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSynchronized == IsSynchronized</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorBranch.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorBranch.EnsureNotDisposed">
      <ensures>!disposed</ensures>
      <ensures>currentIndex == Contract.OldValue(currentIndex)</ensures>
      <ensures>cursor.latestIndex == Contract.OldValue(cursor.latestIndex)</ensures>
      <ensures>cursor.elements.Count == Contract.OldValue(cursor.elements.Count)</ensures>
      <ensures>cursor.stopped == Contract.OldValue(cursor.stopped)</ensures>
      <ensures>cursor.firstElementIndex == Contract.OldValue(cursor.firstElementIndex)</ensures>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorBranch.IsSynchronized">
      <getter>
        <ensures>!Contract.Result&lt;bool&gt;()</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorBranch.Dispose">
      <ensures>disposed</ensures>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorBranch.IsDisposed">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == disposed</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorBranch.Move(System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32,System.Int32)">
      <requires>observer != null</requires>
      <requires>index &gt;= -1</requires>
      <requires>index == -1 || index &gt;= firstElementIndex</requires>
      <requires>index &gt; latestIndex || elements.Count &gt;= latestIndex - index</requires>
      <requires>!stopped || index &lt;= latestIndex + oneForTerminationNotification</requires>
      <requires>count &gt;= subscribeUnlimited</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
      <ensures>latestIndex &gt;= -1</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.OnError(System.Exception)">
      <requires>error != null</requires>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.IsSynchronized">
      <getter>
        <ensures>!Contract.Result&lt;bool&gt;()</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ToString(System.Int32,System.String)">
      <requires>index &gt;= 0</requires>
      <ensures>Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.IsSequenceTerminated">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == stopped</ensures>
      </getter>
    </member>
    <member name="T:System.Reactive.ObservableCursor`1.ObservableCursorSubscription">
      <invariant>cursor != null</invariant>
      <invariant>observer != null</invariant>
      <invariant>index &gt;= 0</invariant>
      <invariant>take &gt;= subscribeUnlimited</invariant>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorSubscription.#ctor(System.Reactive.ObservableCursor{`0},System.Int32,System.Int32,System.IObserver{`0})">
      <requires>cursor != null</requires>
      <requires>index &gt;= 0</requires>
      <requires>take == subscribeUnlimited || take &gt; 0</requires>
      <requires>observer != null</requires>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorSubscription.Index">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorSubscription.Observer">
      <getter>
        <ensures>Contract.Result&lt;IObserver&lt;T&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorSubscription.Take">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= subscribeUnlimited</ensures>
      </getter>
      <setter>
        <requires>value &gt;= 0</requires>
      </setter>
    </member>
    <member name="M:System.Reactive.EventCoercingObserver`2.#ctor(System.IObserver{System.Reactive.EventPattern{`1}})">
      <requires>target != null</requires>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.BinaryOperation(System.IObservable{`0},System.Func{`0,`0,`1})">
      <requires>second != null</requires>
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.DefaultBinaryOperation(System.IObservable{`0},System.IObservable{`0},System.Func{`0,`0,`1})">
      <requires>first != null</requires>
      <requires>second != null</requires>
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.UnaryOperation(System.Func{`0,`1})">
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.#ctor(System.IObservable{`0},System.Func{System.IObservable{`0},System.IObservable{`0},System.Func{`0,`0,`1},System.IObservable{`1}},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`1},System.Func{`0,`1},System.Func{System.IObservable{`1},System.Reactive.OperationalObservable{`1}})">
      <requires>source != null</requires>
      <requires>resultSelector != null</requires>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.BinaryOperation(`0,System.Func{`0,`0,`1})">
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.FileSystemWatcherExtensions.CollectInternal``1(System.IO.FileSystemWatcher,System.Boolean,System.Func{System.IObservable{System.Reactive.CollectionNotification{System.String}},System.IObservable{System.Reactive.CollectionModification{``0}}},System.Reactive.Concurrency.IScheduler)">
      <requires>watcher != null</requires>
      <requires>selector != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.FileSystemWatcherExtensions.CreateObservableEvents(System.IO.FileSystemWatcher,System.IO.WatcherChangeTypes)">
      <requires>watcher != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;FileSystemNotification&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.FileSystemWatcherExtensions.CreateObservableEventsWithoutRenamed(System.IO.FileSystemWatcher,System.IO.WatcherChangeTypes)">
      <requires>watcher != null</requires>
    </member>
    <member name="M:System.IO.StreamExtensions.ReadToEndObservable(System.IO.Stream,System.Byte[])">
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>buffer != null</requires>
      <requires>buffer.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ReadObservable(System.IO.Stream,System.Byte[])">
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>buffer != null</requires>
      <requires>buffer.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionExtensions.GetOwner(System.Linq.Expressions.MemberExpression)">
      <requires>property != null</requires>
      <ensures>Contract.Result&lt;object&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.Enumerable2.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <requires>source != null</requires>
      <requires>onNext != null</requires>
    </member>
    <member name="T:System.Linq.Cursor`1">
      <invariant>disposables != null</invariant>
      <invariant>source != null</invariant>
      <invariant>sourceEnumerator != null</invariant>
      <invariant>elements != null</invariant>
      <invariant>branches != null</invariant>
      <invariant>currentIndex &gt;= 0</invariant>
      <invariant>currentIndex &gt;= firstElementIndex</invariant>
      <invariant>latestIndex &gt;= -1</invariant>
      <invariant>firstElementIndex &gt;= 0</invariant>
      <invariant>isForwardOnly || firstElementIndex == 0</invariant>
      <invariant>latestIndex == -1 || firstElementIndex &gt; 0 || elements.Count &gt; 0</invariant>
      <invariant>currentIndex &gt; latestIndex || elements.Count &gt;= latestIndex - currentIndex</invariant>
      <invariant>stopped || latestIndex &lt; firstElementIndex + elements.Count</invariant>
      <invariant>!stopped || latestIndex &lt; firstElementIndex + (elements.Count - oneForTerminationNotification)</invariant>
      <invariant>!stopped || firstElementIndex &lt;= latestIndex + oneForTerminationNotification</invariant>
      <invariant>!stopped || currentIndex &lt;= latestIndex + oneForTerminationNotification</invariant>
      <invariant description="Completion must enqueue an OnError or OnCompleted notification in addition to any memoized OnNext notifications.">!stopped || elements.Count &gt; 0</invariant>
    </member>
    <member name="M:System.Linq.Cursor`1.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.Move(System.Int32)">
      <ensures>elements.Count &lt;= Contract.OldValue(elements.Count)</ensures>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.Branch">
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="P:System.Linq.Cursor`1.IsSequenceTerminated">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == stopped</ensures>
      </getter>
    </member>
    <member name="P:System.Linq.Cursor`1.IsForwardOnly">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == isForwardOnly</ensures>
      </getter>
    </member>
    <member name="M:System.Linq.Cursor`1.Terminated">
      <requires>!stopped</requires>
      <ensures>stopped</ensures>
      <ensures>latestIndex == Contract.OldValue(latestIndex)</ensures>
      <ensures>currentIndex &lt;= latestIndex + oneForTerminationNotification</ensures>
      <ensures>firstElementIndex &lt;= latestIndex + oneForTerminationNotification</ensures>
      <ensures>elements.Count == Contract.OldValue(elements.Count)</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.RemovePassedElements">
      <requires>isForwardOnly</requires>
      <ensures>CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures>LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>firstElementIndex &gt;= Contract.OldValue(firstElementIndex)</ensures>
      <ensures>elements.Count &lt;= Contract.OldValue(elements.Count)</ensures>
      <ensures>(Contract.OldValue(elements.Count) - elements.Count) &lt;= (firstElementIndex - Contract.OldValue(firstElementIndex))</ensures>
    </member>
    <member name="P:System.Linq.Cursor`1.CurrentIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == currentIndex</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_CurrentIndex" inheritedFromTypeName="ICursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_CurrentIndex" inheritedFromTypeName="ICursor">!IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
    </member>
    <member name="T:System.Linq.Cursor`1.CursorBranch">
      <invariant>disposables != null</invariant>
      <invariant>cursor != null</invariant>
      <invariant>cursor.branches != null</invariant>
      <invariant>cursor.elements != null</invariant>
      <invariant>cursor.latestIndex &gt;= -1</invariant>
      <invariant>IsForwardOnly == cursor.IsForwardOnly</invariant>
      <invariant>LatestIndex == cursor.LatestIndex</invariant>
      <invariant>IsSequenceTerminated == cursor.IsSequenceTerminated</invariant>
      <invariant>currentIndex &gt;= 0</invariant>
      <invariant>currentIndex &gt;= cursor.firstElementIndex</invariant>
      <invariant>currentIndex &gt; cursor.latestIndex || cursor.elements.Count &gt;= cursor.latestIndex - currentIndex</invariant>
      <invariant>!cursor.stopped || currentIndex &lt;= cursor.latestIndex + oneForTerminationNotification</invariant>
    </member>
    <member name="P:System.Linq.Cursor`1.CursorBranch.AtEndOfSequence">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == (cursor.stopped &amp;&amp; currentIndex == cursor.latestIndex + 1)</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_AtEndOfSequence" inheritedFromTypeName="ICursor">Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="P:System.Linq.Cursor`1.CursorBranch.LatestIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == cursor.latestIndex</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_LatestIndex" inheritedFromTypeName="ICursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.Branch">
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="P:System.Linq.Cursor`1.CursorBranch.IsSequenceTerminated">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.stopped</ensures>
      </getter>
    </member>
    <member name="P:System.Linq.Cursor`1.CursorBranch.IsForwardOnly">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.isForwardOnly</ensures>
      </getter>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.#ctor(System.Linq.Cursor{`0},System.Int32,System.Reactive.Disposables.CompositeDisposable)">
      <requires>cursor != null</requires>
      <requires>cursor.branches != null</requires>
      <requires>cursor.elements != null</requires>
      <requires>cursor.latestIndex &gt;= -1</requires>
      <requires>currentIndex &gt;= 0</requires>
      <requires>currentIndex &gt;= cursor.firstElementIndex</requires>
      <requires>currentIndex &gt; cursor.latestIndex || cursor.elements.Count &gt;= cursor.latestIndex - currentIndex</requires>
      <requires>!cursor.stopped || currentIndex &lt;= cursor.latestIndex + 1</requires>
      <requires>parentDisposables != null</requires>
      <ensures>this.cursor == cursor</ensures>
      <ensures>this.currentIndex == currentIndex</ensures>
      <ensures>IsForwardOnly == cursor.IsForwardOnly</ensures>
      <ensures>IsSequenceTerminated == cursor.IsSequenceTerminated</ensures>
      <ensures>LatestIndex == cursor.latestIndex</ensures>
      <ensures>CurrentIndex == currentIndex</ensures>
      <ensures>AtEndOfSequence == (cursor.IsSequenceTerminated &amp;&amp; currentIndex == cursor.latestIndex + 1)</ensures>
      <ensures>cursor.AtEndOfSequence == Contract.OldValue(cursor.AtEndOfSequence)</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.Reset">
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">CurrentIndex == 0</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">LatestIndex == -1</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">!IsSequenceTerminated</ensures>
    </member>
    <member name="P:System.Linq.Cursor`1.CursorBranch.CurrentIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == currentIndex</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_CurrentIndex" inheritedFromTypeName="ICursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_CurrentIndex" inheritedFromTypeName="ICursor">!IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
      <setter>
        <requires>value &gt;= 0</requires>
        <requires>value &lt;= LatestIndex + 1</requires>
      </setter>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.Dispose">
      <ensures>disposed</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.EnsureNotDisposed">
      <ensures>!disposed</ensures>
      <ensures>currentIndex == Contract.OldValue(currentIndex)</ensures>
      <ensures>cursor.latestIndex == Contract.OldValue(cursor.latestIndex)</ensures>
      <ensures>cursor.elements.Count == Contract.OldValue(cursor.elements.Count)</ensures>
      <ensures>cursor.stopped == Contract.OldValue(cursor.stopped)</ensures>
      <ensures>cursor.firstElementIndex == Contract.OldValue(cursor.firstElementIndex)</ensures>
      <ensures>AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.Move(System.Int32)">
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.EnsureNotDisposed">
      <ensures>!disposed</ensures>
      <ensures>CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures>LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures>firstElementIndex == Contract.OldValue(firstElementIndex)</ensures>
      <ensures>elements.Count == Contract.OldValue(elements.Count)</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.GetExistingElements(System.Int32,System.Int32)">
      <requires>startIndex &gt;= -1</requires>
      <requires>!stopped || startIndex &lt;= latestIndex + oneForTerminationNotification</requires>
      <requires>stopped || startIndex &lt;= latestIndex</requires>
      <requires>count &gt; 0</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;Notification&lt;T&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.GetLowestIndex">
      <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      <ensures>Contract.Result&lt;int&gt;() &lt;= currentIndex</ensures>
      <ensures>IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures>CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures>LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>firstElementIndex == Contract.OldValue(firstElementIndex)</ensures>
      <ensures>elements.Count == Contract.OldValue(elements.Count)</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="P:System.Linq.Cursor`1.AtEndOfSequence">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == (stopped &amp;&amp; currentIndex == latestIndex + oneForTerminationNotification)</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_AtEndOfSequence" inheritedFromTypeName="ICursor">Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="M:System.Linq.Cursor`1.Dispose">
      <ensures>disposed</ensures>
    </member>
    <member name="P:System.Linq.Cursor`1.LatestIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == latestIndex</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_LatestIndex" inheritedFromTypeName="ICursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:System.Linq.Cursor`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
      <requires>source != null</requires>
      <ensures>IsForwardOnly == isForwardOnly</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.Reset(System.Boolean)">
      <ensures>!stopped</ensures>
      <ensures>currentIndex == 0</ensures>
      <ensures>latestIndex == -1</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.OnError(System.Exception)">
      <requires>error != null</requires>
    </member>
    <member name="M:System.Linq.Cursor`1.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.ToString(System.Int32,System.String)">
      <requires>index &gt;= 0</requires>
      <ensures>Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.UInt32},System.Func{System.Collections.Generic.IEnumerable{System.UInt32},System.Collections.Generic.IEnumerable{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32},System.Collections.Generic.IEnumerable{System.UInt32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Collections.Generic.IEnumerable{System.Byte},System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.Collections.Generic.IEnumerable{System.UInt16},System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Decimal},System.Func{System.Collections.Generic.IEnumerable{System.Decimal},System.Collections.Generic.IEnumerable{System.Decimal},System.Func{System.Decimal,System.Decimal,System.Decimal},System.Collections.Generic.IEnumerable{System.Decimal}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Double},System.Func{System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Func{System.Double,System.Double,System.Double},System.Collections.Generic.IEnumerable{System.Double}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Collections.Generic.IEnumerable{System.Int16},System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.Collections.Generic.IEnumerable{System.SByte},System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Int64},System.Func{System.Collections.Generic.IEnumerable{System.Int64},System.Collections.Generic.IEnumerable{System.Int64},System.Func{System.Int64,System.Int64,System.Int64},System.Collections.Generic.IEnumerable{System.Int64}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Single},System.Func{System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Single},System.Func{System.Single,System.Single,System.Single},System.Collections.Generic.IEnumerable{System.Single}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.UInt64},System.Func{System.Collections.Generic.IEnumerable{System.UInt64},System.Collections.Generic.IEnumerable{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64},System.Collections.Generic.IEnumerable{System.UInt64}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Collections.Generic.IEnumerable{System.Char},System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.SyndicationFeedFormatterExtensions.GetFeed(System.IO.Stream,System.ServiceModel.Syndication.SyndicationFeedFormatter)">
      <requires>stream != null</requires>
      <requires>formatter != null</requires>
      <ensures>Contract.Result&lt;SyndicationFeed&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,`0},System.Collections.Generic.IEnumerable{`0}},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0},System.Func{`0,`0})">
      <requires>source != null</requires>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.DefaultBinaryOperation(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,`1})">
      <requires>first != null</requires>
      <requires>second != null</requires>
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.BinaryOperation(System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,`1})">
      <requires>second != null</requires>
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.UnaryOperation(System.Func{`0,`1})">
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,`1},System.Collections.Generic.IEnumerable{`1}},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`1},System.Func{`0,`1},System.Func{System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.OperationalEnumerable{`1}})">
      <requires>source != null</requires>
      <requires>resultSelector != null</requires>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.BinaryOperation(`0,System.Func{`0,`0,`1})">
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.TraceDefaults.GetIdentityMessageOnCompleted(System.String)">
      <requires>completedMessage != null</requires>
      <ensures>Contract.Result&lt;Func&lt;int, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.TraceDefaults.GetMessageOnCompleted(System.String)">
      <requires>completedMessage != null</requires>
      <ensures>Contract.Result&lt;Func&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.TraceDefaults.GetFormatOnError(System.String)">
      <requires>errorFormat != null</requires>
      <ensures>Contract.Result&lt;Func&lt;Exception, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.TraceDefaults.GetIdentityFormatOnNext``1(System.String)">
      <requires>nextFormat != null</requires>
      <ensures>Contract.Result&lt;Func&lt;int, T, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.TraceDefaults.GetFormatOnNext``1(System.String)">
      <requires>nextFormat != null</requires>
      <ensures>Contract.Result&lt;Func&lt;T, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.TraceDefaults.GetIdentityFormatOnError(System.String)">
      <requires>errorFormat != null</requires>
      <ensures>Contract.Result&lt;Func&lt;int, Exception, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.NetworkInformation.PingExtensions.CreatePingObservable(System.Net.NetworkInformation.Ping,System.Action{System.Object})">
      <requires>ping != null</requires>
      <requires>start != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;PingReply&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.ComponentReflection.GetEvents(System.Object)">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;EventDescriptor&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.ComponentReflection.GetProperties(System.Object)">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;PropertyDescriptor&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.ComponentReflection.GetEvent(System.Object,System.String,System.StringComparison)">
      <requires>source != null</requires>
      <requires>eventName != null</requires>
    </member>
    <member name="M:Rxx.ComponentReflection.GetMembers(System.Object)">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;MemberDescriptor&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.ComponentReflection.GetProperty(System.Object,System.String,System.StringComparison)">
      <requires>source != null</requires>
      <requires>propertyName != null</requires>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#Character(System.Char)">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Char)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#AnyCharacterUntil(System.String[])">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#get_AnyCharacter">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_AnyCharacter" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#Character(System.Func{System.Char,System.Boolean})">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#Word(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpaceCached">
      <getter>
        <ensures>Contract.Result&lt;ICollection&lt;char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#InsignificantWhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#Character(System.Globalization.UnicodeCategory)">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#get_WhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_WhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#AnyCharacter">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_AnyCharacter" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#AnyCharacterUntil(System.Char[])">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#WhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_WhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#get_InsignificantWhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.InlineXmlParser`1">
      <invariant>schema != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_CData">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_CData" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_Comment">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Comment" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Comment">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Comment" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#AnyContent">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyContent" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Parse(System.Linq.ICursor{System.Char},Rxx.Parsers.IParser{System.Char,`0})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_AnyElement">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyElement" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_AnyContent">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyContent" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Attribute(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">!string.IsNullOrWhiteSpace(name)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Schema">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.XmlParser`1.get_Schema" inheritedFromTypeName="XmlParser">Contract.Result&lt;IParser&lt;char, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#AnyElement">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyElement" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_Text">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Text" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#Parse(System.Linq.ICursor{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Text">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Text" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#AnyAttribute">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#CData">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_CData" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_AnyAttribute">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.AnonymousParser`2">
      <invariant>name == null || name.Length &gt; 0</invariant>
      <invariant>parse != null || parserFactory != null</invariant>
      <invariant>getNext != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.AnonymousParser`2.#ctor(System.String,System.Func{Rxx.Parsers.IParser{`0,`0}},System.Func{System.Linq.ICursor{`0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{`1}}})">
      <requires>name == null || name.Length &gt; 0</requires>
      <requires>getNext != null</requires>
      <requires>parse != null</requires>
    </member>
    <member name="M:Rxx.Parsers.AnonymousParser`2.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.AnonymousParser`2.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.AnonymousParser`2.#ctor(System.String,System.Func{Rxx.Parsers.IParser{`0,`1}})">
      <requires>name == null || name.Length &gt; 0</requires>
      <requires>parserFactory != null</requires>
    </member>
    <member name="P:Rxx.Parsers.AnonymousParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.ParseResult`1">
      <invariant>length &gt;= 0</invariant>
    </member>
    <member name="M:Rxx.Parsers.ParseResult`1.#ctor(`0,System.Int32)">
      <requires>length &gt;= 0</requires>
    </member>
    <member name="P:Rxx.Parsers.ParseResult`1.Length">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParseResult`1.get_Length" inheritedFromTypeName="IParseResult">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParseResult`1.#ctor(System.Int32)">
      <requires>length &gt;= 0</requires>
    </member>
    <member name="T:Rxx.Parsers.ParserCursor`1">
      <invariant>cursor != null</invariant>
      <invariant>cursor.IsForwardOnly</invariant>
      <invariant>branches != null</invariant>
      <invariant>IsForwardOnly == cursor.IsForwardOnly</invariant>
      <invariant>CurrentIndex == cursor.CurrentIndex</invariant>
      <invariant>LatestIndex == cursor.LatestIndex</invariant>
      <invariant>AtEndOfSequence == cursor.AtEndOfSequence</invariant>
      <invariant>IsSequenceTerminated == cursor.IsSequenceTerminated</invariant>
    </member>
    <member name="T:Rxx.Parsers.ParserCursor`1.ParserCursorBranch">
      <invariant>branch != null</invariant>
      <invariant>branch.IsForwardOnly</invariant>
      <invariant>branches != null</invariant>
      <invariant>dispose != null</invariant>
      <invariant>IsForwardOnly == branch.IsForwardOnly</invariant>
      <invariant>CurrentIndex == branch.CurrentIndex</invariant>
      <invariant>LatestIndex == branch.LatestIndex</invariant>
      <invariant>AtEndOfSequence == branch.AtEndOfSequence</invariant>
      <invariant>IsSequenceTerminated == branch.IsSequenceTerminated</invariant>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.AtEndOfSequence">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == branch.AtEndOfSequence</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_AtEndOfSequence" inheritedFromTypeName="ICursor">Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.LatestIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == branch.LatestIndex</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_LatestIndex" inheritedFromTypeName="ICursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.Branch">
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.IsSequenceTerminated">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == branch.IsSequenceTerminated</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.IsForwardOnly">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == branch.IsForwardOnly</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.#ctor(System.Linq.ICursor{`0},System.Action)">
      <requires>branch != null</requires>
      <requires>branch.IsForwardOnly</requires>
      <requires>dispose != null</requires>
      <ensures>IsForwardOnly == branch.IsForwardOnly</ensures>
      <ensures>CurrentIndex == branch.CurrentIndex</ensures>
      <ensures>LatestIndex == branch.LatestIndex</ensures>
      <ensures>AtEndOfSequence == branch.AtEndOfSequence</ensures>
      <ensures>IsSequenceTerminated == branch.IsSequenceTerminated</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.Reset">
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">CurrentIndex == 0</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">LatestIndex == -1</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">!IsSequenceTerminated</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.CurrentIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == branch.CurrentIndex</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_CurrentIndex" inheritedFromTypeName="ICursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_CurrentIndex" inheritedFromTypeName="ICursor">!IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.Move(System.Int32)">
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.LatestIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == cursor.LatestIndex</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_LatestIndex" inheritedFromTypeName="ICursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.IsForwardOnly">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.IsForwardOnly</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.Branch">
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.AtEndOfSequence">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.AtEndOfSequence</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_AtEndOfSequence" inheritedFromTypeName="ICursor">Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.#ctor(System.Linq.ICursor{`0})">
      <requires>cursor != null</requires>
      <requires>cursor.IsForwardOnly</requires>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.CurrentIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == cursor.CurrentIndex</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_CurrentIndex" inheritedFromTypeName="ICursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_CurrentIndex" inheritedFromTypeName="ICursor">!IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
        <ensures inheritedFrom="M:Rxx.Parsers.IParserCursor`1.get_CurrentIndex" inheritedFromTypeName="IParserCursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.Reset">
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">CurrentIndex == 0</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">LatestIndex == -1</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">!IsSequenceTerminated</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.IsSequenceTerminated">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.IsSequenceTerminated</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.Move(System.Int32)">
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AmbiguousGroupRun``1(System.Int32@,System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``0},Rxx.Parsers.IParser{``0,``0},System.Collections.Generic.List{System.Action{Rxx.Parsers.IParseResult{``0}}},System.Collections.Generic.List{System.Action{Rxx.Parsers.IParseResult{``0}}},System.Collections.Generic.List{System.Action{Rxx.Parsers.IParseResult{``0}}})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <requires>openSinks != null</requires>
      <requires>closeSinks != null</requires>
      <requires>contentSinks != null</requires>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AtLeast``3(Rxx.Parsers.IParser{``0,``2},System.String,System.Int32,System.Int32,Rxx.Parsers.IParser{``0,``1},System.Boolean)">
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>count &gt;= 0</requires>
      <requires>maximum == -1 || maximum &gt;= count</requires>
      <requires>maximum != 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.AllParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.AllParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{`0,`1}})">
      <requires>parsers != null</requires>
    </member>
    <member name="P:Rxx.Parsers.AllParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IParser&lt;TSource, TResult&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.AllParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AllParser`2.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.AmbiguousParser`2.#ctor(Rxx.Parsers.IParser{`0,`1})">
      <requires>parser != null</requires>
    </member>
    <member name="M:Rxx.Parsers.AmbiguousParser`2.#ctor(Rxx.Parsers.IParser{`0,`1},System.Func{System.Linq.ICursor{`0},System.Boolean})">
      <requires>parser != null</requires>
      <requires>untilPredicate != null</requires>
    </member>
    <member name="P:Rxx.Parsers.AmbiguousParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AmbiguousParser`2.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.AmbiguousParser`2.#ctor(Rxx.Parsers.IParser{`0,`1},System.Int32)">
      <requires>parser != null</requires>
      <requires>untilCount &gt;= 0</requires>
    </member>
    <member name="T:Rxx.Parsers.InlineParser`2">
      <invariant>start != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.InlineParser`2.Rxx#Parsers#IParser{TSource@TSource}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineParser`2.Rxx#Parsers#IParser{TSource@TSource}#Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineParser`2.Start">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Parser`2.get_Start" inheritedFromTypeName="Parser">Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineParser`2.Parse(System.Linq.ICursor{`0},Rxx.Parsers.IParser{`0,`1})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineParser`2.Rxx#Parsers#IParser{TSource@TSource}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.LookAheadParseResult`1">
      <invariant>subject != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.LookAheadParseResult`1.#ctor(`0,System.Int32)">
      <requires>length &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.LookAheadParseResult`1.Subscribe(System.IObserver{System.Boolean})">
      <requires inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.LookAheadParseResult`1.#ctor(System.Int32)">
      <requires>length &gt;= 0</requires>
    </member>
    <member name="P:Rxx.Parsers.IParserCursor`1.CurrentIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserQueryContext`3.#ctor(Rxx.Parsers.IParser{`0,`1},`2)">
      <requires>parser != null</requires>
    </member>
    <member name="M:Rxx.Parsers.ParserQueryContext`3.Rxx#Parsers#IParser{TSource@TResult}#Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserQueryContext`3.Parser">
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.ParserQueryContext`3.Rxx#Parsers#IParser{TSource@TResult}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserQueryContext`3.Rxx#Parsers#IParser{TSource@TResult}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.ParserTraceExecutionContext`1">
      <invariant>name == null || name.Length &gt; 0</invariant>
      <invariant>iteration &gt;= 0</invariant>
      <invariant>stopwatch == null || cursor != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.ParserTraceExecutionContext`1.TraceResult``1(Rxx.Parsers.IParseResult{``0})">
      <requires>result != null</requires>
    </member>
    <member name="T:Rxx.Parsers.AllManyUnorderedParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.AllManyUnorderedParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{`0,System.Collections.Generic.IEnumerable{`1}}})">
      <requires>parsers != null</requires>
    </member>
    <member name="P:Rxx.Parsers.AllManyUnorderedParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.AllManyUnorderedParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AllManyUnorderedParser`2.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.AllManyParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.AllManyParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{`0,System.Collections.Generic.IEnumerable{`1}}})">
      <requires>parsers != null</requires>
    </member>
    <member name="P:Rxx.Parsers.AllManyParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.AllManyParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AllManyParser`2.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Parser`2.Rxx#Parsers#IParser{TSource@TResult}#Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.AnyParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.AnyParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{`0,`1}})">
      <requires>parsers != null</requires>
    </member>
    <member name="P:Rxx.Parsers.AnyParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IParser&lt;TSource, TResult&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.AnyParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AnyParser`2.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AnyObservableParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnyObservableParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{`0,`1}})">
      <requires>parsers != null</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnyObservableParser`2.Parse(System.Collections.Generic.ICollection{Rxx.Parsers.Reactive.IObservableParser{`0,`1}},System.Reactive.IObservableCursor{`0})">
      <requires>except != null</requires>
      <requires>!except.IsReadOnly</requires>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AnyObservableParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IObservableParser&lt;TSource, TResult&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AnyObservableParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnyObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.ObservableParserCursor`1">
      <invariant>cursor != null</invariant>
      <invariant>cursor.IsForwardOnly</invariant>
      <invariant>branches != null</invariant>
      <invariant>IsSynchronized == cursor.IsSynchronized</invariant>
      <invariant>IsForwardOnly == cursor.IsForwardOnly</invariant>
      <invariant>IsSynchronized || CurrentIndex == cursor.CurrentIndex</invariant>
      <invariant>IsSynchronized || LatestIndex == cursor.LatestIndex</invariant>
      <invariant>IsSynchronized || AtEndOfSequence == cursor.AtEndOfSequence</invariant>
      <invariant>IsSynchronized || IsSequenceTerminated == cursor.IsSequenceTerminated</invariant>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.AtEndOfSequence">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;bool&gt;() == cursor.AtEndOfSequence</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">!Contract.Result&lt;bool&gt;() || IsSequenceTerminated</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch">
      <invariant>branch != null</invariant>
      <invariant>branch.IsForwardOnly</invariant>
      <invariant>branches != null</invariant>
      <invariant>dispose != null</invariant>
      <invariant>IsSynchronized == branch.IsSynchronized</invariant>
      <invariant>IsForwardOnly == branch.IsForwardOnly</invariant>
      <invariant>IsSynchronized || branch.IsDisposed || CurrentIndex == branch.CurrentIndex</invariant>
      <invariant>IsSynchronized || branch.IsDisposed || LatestIndex == branch.LatestIndex</invariant>
      <invariant>IsSynchronized || branch.IsDisposed || AtEndOfSequence == branch.AtEndOfSequence</invariant>
      <invariant>IsSynchronized || branch.IsDisposed || IsSequenceTerminated == branch.IsSequenceTerminated</invariant>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.AtEndOfSequence">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;bool&gt;() == branch.AtEndOfSequence</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">!Contract.Result&lt;bool&gt;() || IsSequenceTerminated</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.LatestIndex">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;int&gt;() == branch.LatestIndex</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_LatestIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.Branch">
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSynchronized == IsSynchronized</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.IsSequenceTerminated">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;bool&gt;() == branch.IsSequenceTerminated</ensures>
        <ensures>!branch.IsSequenceTerminated || Contract.Result&lt;bool&gt;() == true</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.IsForwardOnly">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == branch.IsForwardOnly</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.#ctor(System.Reactive.IObservableCursor{`0},System.Action)">
      <requires>branch != null</requires>
      <requires>branch.IsForwardOnly</requires>
      <requires>dispose != null</requires>
      <ensures>IsSynchronized == branch.IsSynchronized</ensures>
      <ensures>IsForwardOnly == branch.IsForwardOnly</ensures>
      <ensures>IsSynchronized || CurrentIndex == branch.CurrentIndex</ensures>
      <ensures>IsSynchronized || LatestIndex == branch.LatestIndex</ensures>
      <ensures>IsSynchronized || AtEndOfSequence == branch.AtEndOfSequence</ensures>
      <ensures>IsSynchronized || IsSequenceTerminated == branch.IsSequenceTerminated</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.Subscribe(System.IObserver{`0},System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">observer != null</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">count &gt;= 0</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.CurrentIndex">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;int&gt;() == branch.CurrentIndex</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.IsSynchronized">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == branch.IsSynchronized</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.IsDisposed">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;bool&gt;() == branch.IsDisposed</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.Subscribe(System.IObserver{`0})">
      <requires inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.Move(System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.IsForwardOnly">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.IsForwardOnly</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.Branch">
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSynchronized == IsSynchronized</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.LatestIndex">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;int&gt;() == cursor.LatestIndex</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_LatestIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.#ctor(System.Reactive.IObservableCursor{`0})">
      <requires>cursor != null</requires>
      <requires>cursor.IsForwardOnly</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.Subscribe(System.IObserver{`0},System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">observer != null</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">count &gt;= 0</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.CurrentIndex">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;int&gt;() == cursor.CurrentIndex</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
        <ensures inheritedFrom="M:Rxx.Parsers.IParserCursor`1.get_CurrentIndex" inheritedFromTypeName="IParserCursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.IsSynchronized">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.IsSynchronized</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.IsDisposed">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;bool&gt;() == cursor.IsDisposed</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.Subscribe(System.IObserver{`0})">
      <requires inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.IObservable`1.Subscribe(System.IObserver{`0})" inheritedFromTypeName="IObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.IsSequenceTerminated">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;bool&gt;() == cursor.IsSequenceTerminated</ensures>
        <ensures>!cursor.IsSequenceTerminated || Contract.Result&lt;bool&gt;() == true</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.Move(System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AllManyUnorderedObservableParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllManyUnorderedObservableParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{`0,System.IObservable{`1}}})">
      <requires>parsers != null</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllManyUnorderedObservableParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllManyUnorderedObservableParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllManyUnorderedObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserQueryContext`3.#ctor(Rxx.Parsers.Reactive.IObservableParser{`0,`1},`2)">
      <requires>parser != null</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserQueryContext`3.Parser">
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserQueryContext`3.Rxx#Parsers#Reactive#IObservableParser{TSource@TResult}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserQueryContext`3.Rxx#Parsers#Reactive#IObservableParser{TSource@TResult}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserQueryContext`3.Rxx#Parsers#Reactive#IObservableParser{TSource@TResult}#Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AnonymousObservableParser`2">
      <invariant>name == null || name.Length &gt; 0</invariant>
      <invariant>parse != null || parserFactory != null</invariant>
      <invariant>getNext != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnonymousObservableParser`2.#ctor(System.String,System.Func{Rxx.Parsers.Reactive.IObservableParser{`0,`0}},System.Func{System.Reactive.IObservableCursor{`0},System.IObservable{Rxx.Parsers.IParseResult{`1}}})">
      <requires>name == null || name.Length &gt; 0</requires>
      <requires>getNext != null</requires>
      <requires>parse != null</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnonymousObservableParser`2.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnonymousObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnonymousObservableParser`2.#ctor(System.String,System.Func{Rxx.Parsers.Reactive.IObservableParser{`0,`1}})">
      <requires>name == null || name.Length &gt; 0</requires>
      <requires>parserFactory != null</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AnonymousObservableParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Parser">
      <getter>
        <ensures>Contract.Result&lt;IXmlObservableParser&lt;TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Rxx#Parsers#Reactive#IObservableParser{System#Char@TResult}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Rxx#Parsers#Reactive#IObservableParser{System#Char@TResult}#Parse(System.Reactive.IObservableCursor{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Rxx#Parsers#Reactive#IObservableParser{System#Char@TResult}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.#ctor(Rxx.Parsers.Reactive.IXmlObservableParser{`0},`1)">
      <requires>parser != null</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AmbiguousGroupInternal``1(System.Reactive.IObservableCursor{``0},Rxx.Parsers.Reactive.IObservableParser{``0,``0},Rxx.Parsers.Reactive.IObservableParser{``0,``0})">
      <requires>source != null</requires>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;IObservable&lt;TSource&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AtLeast``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},System.String,System.Int32,System.Int32,Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Boolean)">
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>count &gt;= 0</requires>
      <requires>maximum == -1 || maximum &gt;= count</requires>
      <requires>maximum != 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectManyInternal``4(System.Reactive.IObservableCursor{``0},Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,System.IObservable{``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},``2,System.Int32})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>parser != null</requires>
      <requires>collectionSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectManyInternal``4(System.Reactive.IObservableCursor{``0},Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,Rxx.Parsers.Reactive.IObservableParser{``0,``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},Rxx.Parsers.IParseResult{``2},System.Int32})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>firstParser != null</requires>
      <requires>secondSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Cursor">
      <getter>
        <ensures>Contract.Result&lt;ObservableParserCursor&lt;TSource&gt;&gt;() == cursor</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.CreateCursor(System.Reactive.IObservableCursor{`0})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <ensures>Contract.Result&lt;ObservableParserCursor&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Parse(Rxx.Parsers.ParserTraceExecutionContext{`0})">
      <requires>Cursor != null</requires>
      <requires>traceContext != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.InlineStringObservableParser`1">
      <invariant>start != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#Character(System.Globalization.UnicodeCategory)">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IObservableParser{System#Char@System#Char}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#get_WhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_WhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IObservableParser{System#Char@System#Char}#Parse(System.Reactive.IObservableCursor{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#AnyCharacterUntil(System.String[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#InsignificantWhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Parse(System.Reactive.IObservableCursor{System.Char},Rxx.Parsers.Reactive.IObservableParser{System.Char,`0})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#get_AnyCharacter">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_AnyCharacter" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#AnyCharacter">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_AnyCharacter" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#AnyCharacterUntil(System.Char[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#Character(System.Char)">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Char)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#WhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_WhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IObservableParser{System#Char@System#Char}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Start">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParser`2.get_Start" inheritedFromTypeName="ObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#get_InsignificantWhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#Word(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#Character(System.Func{System.Char,System.Boolean})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.InlineXmlObservableParser`1">
      <invariant>schema != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IObservableParser{System#Char@System#Char}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#get_CData">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_CData" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XCData&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#AnyElement">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyElement" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IObservableParser{System#Char@System#Char}#Parse(System.Reactive.IObservableCursor{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#get_AnyElement">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyElement" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Parse(System.Reactive.IObservableCursor{System.Char},Rxx.Parsers.Reactive.IObservableParser{System.Char,`0})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Attribute(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrWhiteSpace(name)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#get_AnyContent">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyContent" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XObject&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#CData">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_CData" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#get_Text">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Text" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XText&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Schema">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.XmlObservableParser`1.get_Schema" inheritedFromTypeName="XmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IObservableParser{System#Char@System#Char}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#AnyAttribute">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#AnyContent">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyContent" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#get_Comment">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Comment" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XComment&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Comment">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Comment" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Text">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Text" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#get_AnyAttribute">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AllUnorderedObservableParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllUnorderedObservableParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{`0,`1}})">
      <requires>parsers != null</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllUnorderedObservableParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IObservableParser&lt;TSource, TResult&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllUnorderedObservableParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllUnorderedObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserStart`2.#ctor(System.Func{Rxx.Parsers.Reactive.IObservableParser{`0,`0},Rxx.Parsers.Reactive.IObservableParser{`0,`1}})">
      <requires>grammar != null</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserStart`2.Parse(Rxx.Parsers.ParserTraceExecutionContext{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Parse(Rxx.Parsers.ParserTraceExecutionContext{`0})" inheritedFromTypeName="ObservableParserStartBase">Cursor != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Parse(Rxx.Parsers.ParserTraceExecutionContext{`0})" inheritedFromTypeName="ObservableParserStartBase">traceContext != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Parse(Rxx.Parsers.ParserTraceExecutionContext{`0})" inheritedFromTypeName="ObservableParserStartBase">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AllObservableParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllObservableParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{`0,`1}})">
      <requires>parsers != null</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllObservableParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IObservableParser&lt;TSource, TResult&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllObservableParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParser`2.Rxx#Parsers#Reactive#IObservableParser{TSource@TResult}#Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AmbiguousObservableParser`3.#ctor(Rxx.Parsers.Reactive.IObservableParser{`0,`2})">
      <requires>parser != null</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AmbiguousObservableParser`3.#ctor(Rxx.Parsers.Reactive.IObservableParser{`0,`2},Rxx.Parsers.Reactive.IObservableParser{`0,`1})">
      <requires>parser != null</requires>
      <requires>untilParser != null</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AmbiguousObservableParser`3.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AmbiguousObservableParser`3.#ctor(Rxx.Parsers.Reactive.IObservableParser{`0,`2},System.Int32)">
      <requires>parser != null</requires>
      <requires>untilCount &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AmbiguousObservableParser`3.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#Character(System.Char)">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Char)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#get_WhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_WhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#WhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_WhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#get_AnyCharacter">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_AnyCharacter" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.InsignificantWhiteSpaceCached">
      <getter>
        <ensures>Contract.Result&lt;ICollection&lt;char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#AnyCharacterUntil(System.String[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#Word(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#AnyCharacter">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_AnyCharacter" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#AnyCharacterUntil(System.Char[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#Character(System.Func{System.Char,System.Boolean})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#Character(System.Globalization.UnicodeCategory)">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#get_InsignificantWhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#InsignificantWhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Rxx#Parsers#Reactive#IObservableParser{System#Char@TResult}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Rxx#Parsers#Reactive#IObservableParser{System#Char@TResult}#Parse(System.Reactive.IObservableCursor{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Rxx#Parsers#Reactive#IObservableParser{System#Char@TResult}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.#ctor(Rxx.Parsers.Reactive.IStringObservableParser{`0},`1)">
      <requires>parser != null</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Parser">
      <getter>
        <ensures>Contract.Result&lt;IStringObservableParser&lt;TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#AnyContent">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyContent" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Content(System.Func{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XText},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XText}},System.Boolean)">
      <requires>textSelector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XObject&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#get_Text">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Text" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XText&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#get_AnyElement">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyElement" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Comment">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Comment" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#get_AnyContent">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyContent" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XObject&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#AnyElement">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyElement" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#AnyAttribute">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(System.Func{System.String,System.Boolean},System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}})">
      <requires>name != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Content(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}}@,System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}})">
      <requires>content != null</requires>
      <ensures>Contract.ValueAtReturn(out attributes) != null</ensures>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, IObservable&lt;XObject&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#get_CData">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_CData" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XCData&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(System.Func{System.String,System.Boolean},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires>name != null</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Text">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Text" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#CData">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_CData" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#get_AnyAttribute">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Attribute(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrWhiteSpace(name)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#get_Comment">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Comment" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XComment&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.InlineObservableParser`2">
      <invariant>start != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineObservableParser`2.Rxx#Parsers#Reactive#IObservableParser{TSource@TSource}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineObservableParser`2.Start">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParser`2.get_Start" inheritedFromTypeName="ObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineObservableParser`2.Parse(System.Reactive.IObservableCursor{`0},Rxx.Parsers.Reactive.IObservableParser{`0,`1})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineObservableParser`2.Rxx#Parsers#Reactive#IObservableParser{TSource@TSource}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineObservableParser`2.Rxx#Parsers#Reactive#IObservableParser{TSource@TSource}#Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AllManyObservableParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllManyObservableParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{`0,System.IObservable{`1}}})">
      <requires>parsers != null</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllManyObservableParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllManyObservableParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllManyObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.Parser">
      <getter>
        <ensures>Contract.Result&lt;IXmlParser&lt;TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#Parse(System.Linq.ICursor{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.#ctor(Rxx.Parsers.IXmlParser{`0},`1)">
      <requires>parser != null</requires>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserStart`2.#ctor(System.Func{Rxx.Parsers.IParser{`0,`0},Rxx.Parsers.IParser{`0,`1}})">
      <requires>grammar != null</requires>
    </member>
    <member name="M:Rxx.Parsers.ParserStart`2.Parse(Rxx.Parsers.ParserTraceExecutionContext{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.ParserStartBase`2.Parse(Rxx.Parsers.ParserTraceExecutionContext{`0})" inheritedFromTypeName="ParserStartBase">Cursor != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.ParserStartBase`2.Parse(Rxx.Parsers.ParserTraceExecutionContext{`0})" inheritedFromTypeName="ParserStartBase">traceContext != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.ParserStartBase`2.Parse(Rxx.Parsers.ParserTraceExecutionContext{`0})" inheritedFromTypeName="ParserStartBase">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.InlineStringParser`1">
      <invariant>start != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#Character(System.Globalization.UnicodeCategory)">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#WhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_WhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#get_WhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_WhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#AnyCharacterUntil(System.Char[])">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Parse(System.Linq.ICursor{System.Char},Rxx.Parsers.IParser{System.Char,`0})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#AnyCharacter">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_AnyCharacter" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.InlineStringParser`1.Start">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Parser`2.get_Start" inheritedFromTypeName="Parser">Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#Character(System.Func{System.Char,System.Boolean})">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#InsignificantWhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#get_AnyCharacter">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_AnyCharacter" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#Word(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#Parse(System.Linq.ICursor{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#AnyCharacterUntil(System.String[])">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#get_InsignificantWhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#Character(System.Char)">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Char)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``2(Rxx.Parsers.IParseResult{``0},``1,System.Int32)">
      <requires>result != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TNewValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.YieldMany``1(Rxx.Parsers.IParseResult{``0},``0,System.Int32)">
      <requires>result != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IEnumerable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.AllUnorderedParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.AllUnorderedParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{`0,`1}})">
      <requires>parsers != null</requires>
    </member>
    <member name="P:Rxx.Parsers.AllUnorderedParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IParser&lt;TSource, TResult&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.AllUnorderedParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AllUnorderedParser`2.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Content(System.Func{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XText},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XText}},System.Boolean)">
      <requires>textSelector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_Comment">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Comment" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_AnyContent">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyContent" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_CData">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_CData" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#AnyContent">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyContent" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#AnyAttribute">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#AnyElement">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyElement" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.Func{System.String,System.Boolean},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires>name != null</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Content(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}}@,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}})">
      <requires>content != null</requires>
      <ensures>Contract.ValueAtReturn(out attributes) != null</ensures>
      <ensures>Contract.Result&lt;IParser&lt;char, IEnumerable&lt;XObject&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Attribute(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">!string.IsNullOrWhiteSpace(name)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_AnyAttribute">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#CData">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_CData" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_Text">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Text" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.Func{System.String,System.Boolean},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}})">
      <requires>name != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Text">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Text" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrWhiteSpace(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_AnyElement">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyElement" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Comment">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Comment" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserStartBase`2.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserStartBase`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.ParserStartBase`2.Cursor">
      <getter>
        <ensures>Contract.Result&lt;ParserCursor&lt;TSource&gt;&gt;() == cursor</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserStartBase`2.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserStartBase`2.CreateCursor(System.Linq.ICursor{`0})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <ensures>Contract.Result&lt;ParserCursor&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserStartBase`2.Parse(Rxx.Parsers.ParserTraceExecutionContext{`0})">
      <requires>Cursor != null</requires>
      <requires>traceContext != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserTraceSources.FormatName(System.String)">
      <ensures>Contract.Result&lt;string&gt;() == null || Contract.Result&lt;string&gt;().Length &gt; 0</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserTraceSources.TraceExecution``1(Rxx.Parsers.IParserCursor{``0},System.String)">
      <requires>cursor != null</requires>
      <requires>name == null || name.Length &gt; 0</requires>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#Parse(System.Linq.ICursor{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.#ctor(Rxx.Parsers.IStringParser{`0},`1)">
      <requires>parser != null</requires>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParserQueryContext`2.Parser">
      <getter>
        <ensures>Contract.Result&lt;IStringParser&lt;TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.ViewModel.System#Windows#Reactive#IViewModel#Attach(System.Windows.FrameworkElement)">
      <requires inheritedFrom="M:System.Windows.Reactive.IViewModel.Attach(System.Windows.FrameworkElement)" inheritedFromTypeName="IViewModel">element != null</requires>
      <requires inheritedFrom="M:System.Windows.Reactive.IViewModel.Attach(System.Windows.FrameworkElement)" inheritedFromTypeName="IViewModel">!IsAttached</requires>
      <ensures inheritedFrom="M:System.Windows.Reactive.IViewModel.Attach(System.Windows.FrameworkElement)" inheritedFromTypeName="IViewModel">IsAttached</ensures>
    </member>
    <member name="M:Rxx.ViewModel.EnsureNotDisposed">
      <ensures>IsAttached == Contract.OldValue(IsAttached)</ensures>
    </member>
    <member name="M:Rxx.ViewModel.System#Windows#Reactive#IViewModel#Detach">
      <requires inheritedFrom="M:System.Windows.Reactive.IViewModel.Detach" inheritedFromTypeName="IViewModel">IsAttached</requires>
      <ensures inheritedFrom="M:System.Windows.Reactive.IViewModel.Detach" inheritedFromTypeName="IViewModel">!IsAttached</ensures>
    </member>
  </members>
</doc>