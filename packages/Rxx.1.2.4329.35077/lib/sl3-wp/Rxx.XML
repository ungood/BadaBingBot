<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Rxx</name>
  </assembly>
  <members>
    <member name="T:System.Diagnostics.Contracts.ContractArgumentValidatorAttribute">
      <summary>
            Enables factoring legacy if-then-throw into separate methods for reuse and full control over
            thrown exception and arguments
            </summary>
    </member>
    <member name="T:System.Diagnostics.Contracts.ContractAbbreviatorAttribute">
      <summary>
            Enables writing abbreviations for contracts that get copied to other methods
            </summary>
    </member>
    <member name="T:System.Diagnostics.Contracts.ContractOptionAttribute">
      <summary>
            Allows setting contract and tool options at assembly, type, or method granularity.
            </summary>
    </member>
    <member name="T:Rxx.Parsers.IParser`2">
      <summary>
            Represents a parser over an enumerable sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})">
      <summary>
            Iterates the specified enumerable sequence and applies the parser's grammar, which is defined in 
            terms of the <see cref="P:Rxx.Parsers.IParser`2.Next" /> parser, to generate matches.
            </summary>
      <param name="source">The enumerable sequence to parse.</param>
      <returns>An enumerable sequence of parse results that contain information about the matches.</returns>
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.IParser`2.Next">
      <summary>
            Gets a parser with a grammar that matches the next element in the source sequence.
            </summary>
      <remarks>
            A parser's grammar is defined in terms of grammar rules, each of which is defined in terms of the <see cref="P:Rxx.Parsers.IParser`2.Next" /> parser
            or another rule.
            </remarks>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.AmbiguousParser`2">
      <summary>
            Represents an ambiguous parser that begins a parse operation at the current position of the source sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>parser != null</invariant>
      <invariant>untilCount &gt;= unlimitedCount</invariant>
    </member>
    <member name="T:Rxx.Parsers.ILookAheadParseResult`1">
      <summary>
            Represents a possible result of a parse operation over a sequence, depending upon whether a subsequent parser matches.
            </summary>
      <remarks>
        <para>
            This type of result is used by lazy quantifiers.  It does not represent <em>look-ahead</em> as in the Regular
            Expression sense.  That kind of look-ahead can be expressed using a normal <c>SelectMany</c> query by simply applying 
            the <c>NonGreedy</c> operator to the first parser.  That will effectively allow the first parser to look-ahead for a 
            match from the current position of the cursor, without consuming the results.  The second parser is then executed from 
            the same starting position as the first parser, but only when the first parser matches.
            </para>
        <para>
            Instead, this type of result allows quantifiers to end lazily by asking <c>SelectMany</c> if the second parser matches 
            after each successful match from the quantified parser, starting at the end of the current match.  Essentially, it's like 
            adding <c>NonGreedy</c> to each individual match instead of adding it to the entire quantified parser.  Behaviorally, it's 
            a special kind of result that indicates to <c>SelectMany</c> to look ahead at the second parser and notify the result 
            whether it's successful or not, without yielding.
            </para>
        <alert type="implementors">
            The <see cref="M:Rxx.Parsers.ILookAheadParseResult`1.OnCompleted(System.Boolean)" /> implementation must only accept a single call, specifying <see langword="true" /> to 
            indicate that the look-ahead succeeded and that the parse result can be captured by the parser that generated it; 
            otherwise, <see langword="false" /> should be specified.  The specified value must be buffered and replayed to all 
            observers.
            </alert>
        <alert type="warning">
            When developing custom parser operators, there is no need to use the <see cref="T:System.IObservable`1" />
            implementation of <see cref="T:Rxx.Parsers.ILookAheadParseResult`1" />.  In other words, do not call 
            <strong>Subscribe</strong> or <strong>OnCompleted</strong>.  Look-aheads are handled by the infrastructure, so simply 
            treat this type of result like a normal <see cref="T:Rxx.Parsers.IParseResult`1" />.
            </alert>
      </remarks>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
    </member>
    <member name="T:Rxx.Parsers.IParseResult`1">
      <summary>
            Represents a single result of a parse operation over a sequence.
            </summary>
      <typeparam name="TValue">The type of the parse result's <see cref="P:Rxx.Parsers.IParseResult`1.Value" />.</typeparam>
    </member>
    <member name="P:Rxx.Parsers.IParseResult`1.Value">
      <summary>
            Gets the projection of the matched elements in a sequence.
            </summary>
    </member>
    <member name="P:Rxx.Parsers.IParseResult`1.Length">
      <summary>
            Gets the number of elements in a sequence that were consumed to generate the <see cref="P:Rxx.Parsers.IParseResult`1.Value" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ILookAheadParseResult`1.OnCompleted(System.Boolean)">
      <summary>
            Completes the look-ahead operation and notifies subscribers.
            </summary>
      <param name="success">
        <see langword="True" /> to indicate that the look-ahead succeeded and that the parse result can 
            be captured by the parser that generated it; otherwise, <see langword="false" />.</param>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:Rxx.Parsers.ILookAheadParseResult`1.OnCompleted(System.Boolean)" /> has already been called on this parse result.</exception>
    </member>
    <member name="T:Rxx.Parsers.Parser`2">
      <summary>
            Represents a parser over an enumerable sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Parser`2.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.Parser`2" /> class for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Parser`2.Parse(System.Linq.ICursor{`0})">
      <summary>
            Iterates the specified enumerable sequence and applies the parser's grammar, 
            which is defined by <see cref="P:Rxx.Parsers.Parser`2.Start" />, to generate matches.
            </summary>
      <param name="source">The enumerable sequence to parse.</param>
      <returns>An enumerable sequence of parse results.</returns>
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Parser`2.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current parser.
            </summary>
      <returns>A <see cref="T:System.String" /> that represents the current parser.</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Parser`2.Next">
      <summary>
            Gets a parser with a grammar that matches the next element in the source sequence.
            </summary>
      <remarks>
            A parser's grammar is defined in terms of grammar rules, each of which is defined in terms of the <see cref="P:Rxx.Parsers.Parser`2.Next" /> parser
            or another rule.
            </remarks>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Parser`2.Start">
      <summary>
            Gets the parser's grammar as a parser that is defined in terms of the <see cref="P:Rxx.Parsers.Parser`2.Next" /> parser.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.StringParser`1">
      <summary>
            Represents a parser over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
      <invariant>whiteSpace != null</invariant>
      <invariant>insignificantWhiteSpace != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.IStringParser`1">
      <summary>
            Represents a parser over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires>stops != null</requires>
      <requires>stops.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires>stopWords != null</requires>
      <requires>stopWords.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires>!string.IsNullOrEmpty(value)</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IStringParser`1.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.IStringParser`1.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IStringParser`1.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IStringParser`1.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive insignificant whitespace characters and joins
            them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.StringParser`1" /> class for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires>stops != null</requires>
      <requires>stops.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires>stopWords != null</requires>
      <requires>stopWords.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires>!string.IsNullOrEmpty(value)</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures>Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive whitespace characters determined by the 
            <see cref="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpaceCharacters" /> collection and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpaceCharacters">
      <summary>
            Gets a collection of characters that are considered insignificant whitespace for the  
            <see cref="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpace" /> parser.  
            </summary>
      <getter>
        <ensures>Contract.Result&lt;ICollection&lt;char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.XmlParser`1">
      <summary>
            Represents an XML parser over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of XML nodes.</typeparam>
      <invariant>comparer != null</invariant>
      <invariant>id != null</invariant>
      <invariant>tagStart != null</invariant>
      <invariant>tagEnd != null</invariant>
      <invariant>tagName != null</invariant>
      <invariant>attributeDelimiter != null</invariant>
      <invariant>attributeName != null</invariant>
      <invariant>attributeValue != null</invariant>
      <invariant>attribute != null</invariant>
      <invariant>openTag != null</invariant>
      <invariant>closeTag != null</invariant>
      <invariant>text != null</invariant>
      <invariant>comment != null</invariant>
      <invariant>cData != null</invariant>
      <invariant>element != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.IXmlParser`1">
      <summary>
            Represents an XML parser over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of XML nodes.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)">
      <summary>
            Creates a parser that matches a single XML attribute with the specified <paramref name="name" />.
            </summary>
      <param name="name">The name of the attribute to match.</param>
      <returns>A parser that matches a single XML attribute with the specified <paramref name="name" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified children.
            </summary>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified children.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified attributes and children.
            </summary>
      <remarks>
            IParser is not covariant on TResult in Silverlight because <see cref="T:System.Collections.Generic.IEnumerable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.
            </summary>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.
            </summary>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.</returns>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified children.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified children.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.
            </summary>
      <remarks>
            IParser is not covariant on TResult in Silverlight because <see cref="T:System.Collections.Generic.IEnumerable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, having no attributes
            and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, having no attributes 
            and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">An enumerable sequence containing the names of the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.Text">
      <summary>
            Gets a parser with a grammar that matches all characters, including whitespace, up to the start tag of an element.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.Comment">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;!-- and ending with --&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.CData">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;![CDATA[ and ending with ]]&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.AnyContent">
      <summary>
            Gets a parser with a grammar that matches any <see cref="P:Rxx.Parsers.IXmlParser`1.Text" />, <see cref="P:Rxx.Parsers.IXmlParser`1.Comment" /> or <see cref="P:Rxx.Parsers.IXmlParser`1.CData" /> content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.AnyElement">
      <summary>
            Gets a parser with a grammar that matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.IXmlParser`1.AnyAttribute">
      <summary>
            Gets a parser with a grammar that matches an XML attribute.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.#ctor(System.Boolean)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.XmlParser`1" /> class with the specified case-sensitivity
            for derived classes.
            </summary>
      <param name="caseSensitive">Indicates whether the comparison behavior used for matching element and attribute names
            must ignore case.</param>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.XmlParser`1" /> class with case-sensitive element and 
            attribute name comparisons for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Attribute(System.String)">
      <summary>
            Creates a parser that matches a single XML attribute with the specified <paramref name="name" />.
            </summary>
      <param name="name">The name of the attribute to match.</param>
      <returns>A parser that matches a single XML attribute with the specified <paramref name="name" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified children.
            </summary>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified attributes and children.
            </summary>
      <remarks>
            IParser is not covariant on TResult in Silverlight because <see cref="T:System.Collections.Generic.IEnumerable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.
            </summary>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.
            </summary>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.</returns>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified children.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.
            </summary>
      <remarks>
            IParser is not covariant on TResult in Silverlight because <see cref="T:System.Collections.Generic.IEnumerable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, having no attributes
            and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, having no attributes 
            and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">An enumerable sequence containing the names of the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Start">
      <summary>
            Gets the <see cref="P:Rxx.Parsers.XmlParser`1.Schema" /> that is the parser's grammar.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Parser`2.get_Start" inheritedFromTypeName="Parser">Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Schema">
      <summary>
            Gets the parser's grammar as an XML schema that is defined in terms of the parsers created by
            <see cref="P:Rxx.Parsers.XmlParser`1.AnyElement" />, <see cref="P:Rxx.Parsers.XmlParser`1.AnyAttribute" />, <see cref="P:Rxx.Parsers.XmlParser`1.AnyContent" />, <see cref="P:Rxx.Parsers.XmlParser`1.Text" />, 
            <see cref="P:Rxx.Parsers.XmlParser`1.Comment" />, <see cref="P:Rxx.Parsers.XmlParser`1.CData" /> or any of the methods that create parsers with 
            context-sensitive grammars, such as <see cref="M:Rxx.Parsers.XmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" /> and 
            <see cref="M:Rxx.Parsers.XmlParser`1.Attribute(System.String)" /></summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Text">
      <summary>
            Gets a parser with a grammar that matches all characters, including whitespace, up to the start tag of an element.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Comment">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;!-- and ending with --&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.CData">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;![CDATA[ and ending with ]]&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.AnyContent">
      <summary>
            Gets a parser with a grammar that matches any <see cref="P:Rxx.Parsers.XmlParser`1.Text" />, <see cref="P:Rxx.Parsers.XmlParser`1.Comment" /> or <see cref="P:Rxx.Parsers.XmlParser`1.CData" /> content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.AnyElement">
      <summary>
            Gets a parser with a grammar that matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.AnyAttribute">
      <summary>
            Gets a parser with a grammar that matches an XML attribute.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Linq.ParserExtensions">
      <summary>
            Provides <see langword="static" /> methods for defining <see cref="T:Rxx.Parsers.IParser`2" /> grammars.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Aggregate``4(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``2},System.Func{``2,``1,``2},System.Func{``2,``3})">
      <summary>
            Applies an <paramref name="accumulator" /> function over each result sequence from the 
            specified <paramref name="parser" /> and yields a sequence of accumulated results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TAccumulate">The type of the accumulation.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulation.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be aggregated.</param>
      <param name="seed">A function that returns the initial value of the accumulation for each parse result.</param>
      <param name="accumulator">A function to be invoked on each element of each parse result.</param>
      <param name="selector">A function that projects the final aggregation of each parse result.</param>
      <returns>A parser that returns the aggregated results.</returns>
      <requires>parser != null</requires>
      <requires>accumulator != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Join``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Appends each element in each result sequence from the specified <paramref name="parser" /> 
            to an accumulated <see cref="T:System.String" />, yielding a single <see cref="T:System.String" /> per result
            sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined into strings.</param>
      <returns>A parser that returns the aggregated <see cref="T:System.String" /> results.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Join``3(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{System.String,``2})">
      <summary>
            Appends each element in each result from the specified <paramref name="parser" /> 
            to an accumulated <see cref="T:System.String" /> and projects the strings for each result.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulated <see cref="T:System.String" />.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined.</param>
      <param name="selector">A function that projects the aggregated <see cref="T:System.String" /> of each parse result.</param>
      <returns>A parser that returns the joined results.</returns>
      <requires>parser != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Join``4(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``1,``2},System.Func{System.String,``3})">
      <summary>
            Applies a <paramref name="joiner" /> function over each result from the specified 
            <paramref name="parser" /> to create an accumulated <see cref="T:System.String" /> and projects 
            the strings for each result.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TJoin">The type of the accumulation on which <see cref="M:System.Object.ToString" /> is called.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulated <see cref="T:System.String" />.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined.</param>
      <param name="joiner">A function to be invoked on each element of each parse result to produce a value 
            on which <see cref="M:System.Object.ToString" /> is called and appended to the accumulation.</param>
      <param name="selector">A function that projects the aggregated <see cref="T:System.String" /> of each parse result.</param>
      <returns>A parser that returns the joined results.</returns>
      <requires>parser != null</requires>
      <requires>joiner != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.ToList``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Appends the results of each result sequence from the specified <paramref name="parser" /> into an <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated by the parser.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be aggregated.</param>
      <returns>A parser that returns the results aggregated into an <see cref="T:System.Collections.Generic.IList`1" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IList&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.NonGreedy``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Converts greedy matches from the specified <paramref name="parser" /> into matches that 
            have a length of zero.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The greedy parser to be made into a non-greedy parser.</param>
      <returns>A parser that converts the greedy matches from the specified <paramref name="parser" /> into 
            matches that have a length of zero.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Ambiguous``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until there are no matches or the 
            source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until there are
            no matches or the source sequence ends.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until there are no matches or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Ambiguous``2(Rxx.Parsers.IParser{``0,``1},System.Int32)">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until the specified count is reached
            or the source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until the specified 
            count is reached or the source sequence ends.</param>
      <param name="untilCount">Indicates the maximum number of ambiguous matches to find.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until the specified count is reached or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <requires>untilCount &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Ambiguous``3(Rxx.Parsers.IParser{``0,``2},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until the other parser matches or the 
            source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TUntilResult">The type of the elements that are generated by the until parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until the other 
            parser matches or the source sequence ends.</param>
      <param name="untilParser">The parser that ends the ambiguity when it matches.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until the other parser matches or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <requires>untilParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Amplify``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into a singleton enumerable sequence
            that contains the match's value.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be projected into singleton enumerable sequences.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> projected into singleton
            enumerable sequences.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Single``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Matches the single element from the ambiguous result sequence in each match that is yielded by the specified 
            <paramref name="parser" /> and fails for any match in which there is zero or more than one element.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which the single result element is yielded for each match.</param>
      <returns>A parser that matches the single element from the result sequence of each match that is 
            yielded by the specified <paramref name="parser" /> and fails for any match in which there is zero 
            or more than one element.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> method 
            for the generated parser.</param>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.String,System.Func{System.Linq.ICursor{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> method 
            for the generated parser.</param>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> method 
            for the generated parser.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            is merely a convenience extension that works similar to 
            <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            except that it passes the specified <paramref name="parser" /> to the <paramref name="parse" /> function to facilitate writing 
            iterator blocks that must reference the original parser.
            </remarks>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.String,System.Func{System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> method 
            for the generated parser.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            is merely a convenience extension that works similar to 
            <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            except that it passes the specified <paramref name="parser" /> to the <paramref name="parse" /> function to facilitate writing 
            iterator blocks that must reference the original parser.
            </remarks>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``4(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``1},``2,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``3}}},``2)">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function and <paramref name="argument" />, starting at the index 
            of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TArgument">The type of the extra argument that is passed to the <paramref name="parse" /> function.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> method 
            for the generated parser.</param>
      <param name="argument">Extra data to be passed to the <paramref name="parse" /> function.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            is merely a convenience extension that works similar to 
            <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            except that it passes the specified <paramref name="parser" /> to the <paramref name="parse" /> function to facilitate writing 
            iterator blocks that must reference the original parser.
            </remarks>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Yield``4(Rxx.Parsers.IParser{``0,``1},System.String,System.Func{System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``1},``2,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``3}}},``2)">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function and <paramref name="argument" />, starting at the index 
            of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TArgument">The type of the extra argument that is passed to the <paramref name="parse" /> function.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> method 
            for the generated parser.</param>
      <param name="argument">Extra data to be passed to the <paramref name="parse" /> function.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``1},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            is merely a convenience extension that works similar to 
            <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Yield``3(Rxx.Parsers.IParser{``0,``1},System.Func{System.Linq.ICursor{``0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{``2}}})" />
            except that it passes the specified <paramref name="parser" /> to the <paramref name="parse" /> function to facilitate writing 
            iterator blocks that must reference the original parser.
            </remarks>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AsString``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Converts matches from the specified <paramref name="parser" /> into strings.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be converted into strings.</param>
      <returns>A parser that yields strings for the matches from the specified <paramref name="parser" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Cast``3(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Casts results from the specified <paramref name="parser" /> into the specified type.
            </summary>
      <remarks>
        <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Cast``3(Rxx.Parsers.IParser{``0,``1})" /> is required for Silverlight because it doesn't support covariance on 
            <see cref="T:System.Collections.Generic.IEnumerable`1" />, which is required for <see cref="T:Rxx.Parsers.IParser`2" /> to support covariance on 
            <strong>TResult</strong>.  A consequence is that parsers must sometimes be cast down to their base types before
            they can be combined using various parser operators.
            </remarks>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The original type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TCastResult">The type to which the elements that are generated from parsing the source elements are cast.</typeparam>
      <param name="parser">The parser from which results will be cast into the specified type.</param>
      <returns>A parser that casts results from the specified <paramref name="parser" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TCastResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Required``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> if the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> if there are no matches.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Required``2(Rxx.Parsers.IParser{``0,``1},System.String)">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> with the specified message if the specified <paramref name="parser" /> 
            does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="errorMessage">A <see cref="T:System.String" /> that describes the failed expectation to be used as the message 
            in the <see cref="T:Rxx.Parsers.ParseException" />.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> with the specified message if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(errorMessage)</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Required``2(Rxx.Parsers.IParser{``0,``1},System.Func{System.String})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> with a message returned by the specified function if the specified 
            <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="errorMessageFactory">A function that returns a <see cref="T:System.String" /> describing the failed expectation 
            to be used as the message in the <see cref="T:Rxx.Parsers.ParseException" />.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> with a message returned by the specified functions if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>errorMessageFactory != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Required``2(Rxx.Parsers.IParser{``0,``1},System.Func{System.Int32,System.Exception})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> returned by the specified function if the specified 
            <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="exceptionFactory">A function that returns the <see cref="T:Rxx.Parsers.ParseException" /> to be thrown describing the 
            failed expectation.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> returned by the specified functions if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>exceptionFactory != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Where``2(Rxx.Parsers.IParser{``0,``1},System.Func{``1,System.Boolean})">
      <summary>
            Matches all results from the specified <paramref name="parser" /> for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be filtered by the specified <paramref name="predicate" />.</param>
      <param name="predicate">A function that returns <see langword="true" /> to indicate when a match should be yielded and 
            <see langword="false" /> when a match should be ignored.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> for which 
            the specified <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>parser != null</requires>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.IgnoreBefore``3(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``2})">
      <summary>
            Matches the left parser followed by the right parser, but only returns the right parser's matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIgnore">The type of the elements that are generated by the left parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated by the right parser.</typeparam>
      <param name="ignoreParser">The parser from which to ignore matches.</param>
      <param name="parser">The parser from which to yield matches.</param>
      <returns>A parser that matches the left parser followed by the right parser, but only returns the 
            right parser's matches.</returns>
      <requires>ignoreParser != null</requires>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.IgnoreTrailing``3(Rxx.Parsers.IParser{``0,``2},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser, but only returns the left parser's matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIgnore">The type of the elements that are generated by the right parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated by the left parser.</typeparam>
      <param name="parser">The parser from which to yield matches.</param>
      <param name="ignoreParser">The parser from which to ignore matches.</param>
      <returns>A parser that matches the left parser followed by the right parser, but only returns the 
            left parser's matches.</returns>
      <requires>parser != null</requires>
      <requires>ignoreParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Of``2(Rxx.Parsers.IParser{``0,``1},``1)">
      <summary>
            Matches all results from the specified <paramref name="parser" /> that equal the specified
            <paramref name="value" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches equivalent to the specified <paramref name="value" /> will be yielded.</param>
      <param name="value">The value to be compared to matches for equality.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> that equal
            the specified <paramref name="value" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Of``2(Rxx.Parsers.IParser{``0,``1},``1,System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Matches all results from the specified <paramref name="parser" /> that equal the specified
            <paramref name="value" /> using the specified <paramref name="comparer" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches equivalent to the specified <paramref name="value" /> will be yielded.</param>
      <param name="value">The value to be compared to matches for equality.</param>
      <param name="comparer">The object that compares matches to the specified <paramref name="value" /> for equality.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> that equal
            the specified <paramref name="value" /> using the specified <paramref name="comparer" />.</returns>
      <requires>parser != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Group``4(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``3},Rxx.Parsers.IParser{``0,``2})">
      <summary>
            Matches the <paramref name="content" /> between the specified <paramref name="open" /> and <paramref name="close" /> parsers.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TOpen">The type of the elements that are generated from parsing the <paramref name="open" /> elements.</typeparam>
      <typeparam name="TClose">The type of the elements that are generated from parsing the <paramref name="close" /> elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the <paramref name="content" /> elements.</typeparam>
      <param name="open">The parser after which the matching of <paramref name="content" /> begins.</param>
      <param name="content">The parser that matches values between the <paramref name="open" /> and <paramref name="close" /> parsers.</param>
      <param name="close">The parser at which the matching of <paramref name="content" /> ends.</param>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by the <paramref name="content" /> parser
            and finally the <paramref name="close" /> parser, yielding the results of the <paramref name="content" /> parser only.</returns>
      <requires>open != null</requires>
      <requires>content != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Group``3(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``2})">
      <summary>
            Matches zero or more values in between the specified <paramref name="open" /> and <paramref name="close" /> parsers.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TOpen">The type of the elements that are generated from parsing the <paramref name="open" /> elements.</typeparam>
      <typeparam name="TClose">The type of the elements that are generated from parsing the <paramref name="close" /> elements.</typeparam>
      <param name="open">The parser after which the group begins.</param>
      <param name="close">The parser at which the group ends.</param>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by everything up to the first 
            match of the <paramref name="close" /> parser, yielding the results in between.</returns>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AmbiguousGroup``1(Rxx.Parsers.IParser{``0,``0},Rxx.Parsers.IParser{``0,``0})">
      <summary>
            Matches everything in between the specified <paramref name="open" /> and <paramref name="close" /> parsers, 
            yielding the first unambiguous match as well as everything in between any sub-groups and overlapping groups, 
            extending past the unambiguous match of the <paramref name="close" /> parser, that match the same grammar.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <param name="open">The parser after which the group begins.</param>
      <param name="close">The parser at which the group ends.</param>
      <remarks>
            The same <paramref name="open" /> or <paramref name="close" /> parser may produce multiple matches at the same index.
            </remarks>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by everything up to the first 
            match of the <paramref name="close" /> parser, yielding the results in between as well as the results of all ambiguous 
            matches of the group grammar.</returns>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Not``3(Rxx.Parsers.IParser{``0,``2},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> when the specified <paramref name="notParser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TNotResult">The type of the elements that are generated by the <paramref name="notParser" />.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match when the specified <paramref name="notParser" /> does not match.</param>
      <param name="notParser">The parser that when it matches will cause the matches from the specified 
            <paramref name="parser" /> to be ignored.</param>
      <returns>A parser that matches the specified <paramref name="parser" /> when the specified <paramref name="notParser" />
            does not match.</returns>
      <requires>parser != null</requires>
      <requires>notParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Or``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches either the left parser or the right parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that has precedence.</param>
      <param name="nextParser">The parser that is matched if the first <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields the matches from <paramref name="parser" /> if there are any; otherwise, the matches 
            from <paramref name="nextParser" /> are yielded.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Any``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{``0,``1}})">
      <summary>
            Matches the first parser that is successful.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched until one is successful.</param>
      <returns>A parser that yields the matches from the first parser in <paramref name="parsers" /> that is successful.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Any``2(Rxx.Parsers.IParser{``0,``1}[])">
      <summary>
            Matches the first parser that is successful.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched until one is successful.</param>
      <returns>A parser that yields the matches from the first parser in <paramref name="parsers" /> that is successful.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.And``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.And``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.And``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.And``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AndUnordered``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the left parser and the right parser in any order and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">A parser to be matched, before or after the other parser.</param>
      <param name="otherParser">The other parser to be matched, before or after the first parser.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser and the second parser in any order, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>otherParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AndUnordered``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the left parser and the right parser in any order and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">A parser to be matched, before or after the other parser.</param>
      <param name="otherParser">The other parser to be matched, before or after the first parser.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser and the second parser in any order, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>otherParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AndUnordered``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Matches the left parser and the right parser in any order and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">A parser to be matched, before or after the other parser.</param>
      <param name="otherParser">The other parser to be matched, before or after the first parser.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser and the second parser in any order, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>otherParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AndUnordered``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}},Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Matches the left parser and the right parser in any order and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">A parser to be matched, before or after the other parser.</param>
      <param name="otherParser">The other parser to be matched, before or after the first parser.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser and the second parser in any order, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>otherParser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.All``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{``0,``1}})">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.All``2(Rxx.Parsers.IParser{``0,``1}[])">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.All``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}}})">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.All``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}}[])">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AllUnordered``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{``0,``1}})">
      <summary>
            Matches all <paramref name="parsers" /> in any order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" /> in any order, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AllUnordered``2(Rxx.Parsers.IParser{``0,``1}[])">
      <summary>
            Matches all <paramref name="parsers" /> in any order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" /> in any order, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AllUnordered``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}}})">
      <summary>
            Matches all <paramref name="parsers" /> in any order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" /> in any order, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AllUnordered``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}}[])">
      <summary>
            Matches all <paramref name="parsers" /> in any order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" /> in any order, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Parse``2(System.Func{Rxx.Parsers.IParser{``0,``0},Rxx.Parsers.IParser{``0,``1}})">
      <summary>
            Creates a parser from the specified <paramref name="grammar" /> function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="grammar">A function the accepts a parser that acts as a cursor and returns a parser that matches 
            in terms of the cursor.</param>
      <returns>A parser that yields matches from the specified <paramref name="grammar" />.</returns>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Parse``2(System.Collections.Generic.IEnumerable{``0},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Applies the specified <paramref name="parser" /> to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The enumerable sequence to parse.</param>
      <param name="parser">An object that defines a grammar to be applied to the enumerable sequence to generate matches.</param>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Parse``2(System.Collections.Generic.IEnumerable{``0},System.Func{Rxx.Parsers.ParserQueryContext{``0,``0,Rxx.Parsers.IParser{``0,``0}},Rxx.Parsers.ParserQueryContext{``0,``0,Rxx.Parsers.IParser{``0,``1}}})">
      <summary>
            Applies the specified unambiguous parser grammar to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The enumerable sequence to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.Parse(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor
            	let letter = next.Where(char.IsLetter)
            	let number = next.Where(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Parse``2(System.Collections.Generic.IEnumerable{``0},System.Func{Rxx.Parsers.ParserQueryContext{``0,``0,Rxx.Parsers.IParser{``0,``0}},Rxx.Parsers.ParserQueryContext{``0,``0,Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}}}})">
      <summary>
            Applies the specified ambiguous parser grammar to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The enumerable sequence to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.Parse(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor
            	let letter = next.Where(char.IsLetter)
            	let number = next.Where(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.ParseString``1(System.Collections.Generic.IEnumerable{System.Char},System.Func{Rxx.Parsers.StringParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Char}},Rxx.Parsers.StringParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,``0}}})">
      <summary>
            Applies the specified unambiguous <see cref="T:System.String" /> parser grammar to generate matches.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source characters.</typeparam>
      <param name="source">The <see cref="T:System.String" /> or enumerable sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseString(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let letter = parser.Character(char.IsLetter)
            	let number = parser.Character(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.ParseString``1(System.Collections.Generic.IEnumerable{System.Char},System.Func{Rxx.Parsers.StringParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Char}},Rxx.Parsers.StringParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{``0}}}})">
      <summary>
            Applies the specified ambiguous <see cref="T:System.String" /> parser grammar to generate matches.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source characters.</typeparam>
      <param name="source">The <see cref="T:System.String" /> or enumerable sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseString(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let letter = parser.Character(char.IsLetter)
            	let number = parser.Character(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.ParseXml``1(System.Collections.Generic.IEnumerable{System.Char},System.Func{Rxx.Parsers.XmlParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Char}},Rxx.Parsers.XmlParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,``0}}})">
      <summary>
            Applies the specified unambiguous XML parser grammar to generate matches.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source XML nodes.</typeparam>
      <param name="source">The <see cref="T:System.String" /> or enumerable sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseXml(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let widget = parser.Element("widget")
            	// define the grammar in terms of the rules
            	select parser.Element("products", widget.OneOrMore()))]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.ParseXml``1(System.Collections.Generic.IEnumerable{System.Char},System.Func{Rxx.Parsers.XmlParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Char}},Rxx.Parsers.XmlParserQueryContext{System.Char,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{``0}}}})">
      <summary>
            Applies the specified ambiguous XML parser grammar to generate matches.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source XML nodes.</typeparam>
      <param name="source">The <see cref="T:System.String" /> or enumerable sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseXml(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let widget = parser.Element("widget")
            	// define the grammar in terms of the rules
            	select parser.Element("products", widget.OneOrMore()))]]></code></example>
      <returns>An enumerable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Select``4(Rxx.Parsers.ParserQueryContext{``0,``1,``2},System.Func{``2,``3})">
      <summary>
            Enables defining in-line parser grammars using LINQ.
            </summary>
      <typeparam name="TParseSource">The type of the original source elements.</typeparam>
      <typeparam name="TParseResult">The type of the elements that are originally generated from parsing the source elements.</typeparam>
      <typeparam name="TSource">The type of the source elements; typically, this will be an anonymous compiler-generaed type.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The parser query context to be projected.</param>
      <param name="selector">A function that projects the current result of the query context.</param>
      <returns>A new query context that is the projection of the specified query context using the specified <paramref name="selector" />.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ParserQueryContext&lt;TParseSource, TParseResult, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Select``3(Rxx.Parsers.StringParserQueryContext{``0,``1},System.Func{``1,``2})">
      <summary>
            Enables defining in-line parser grammars using LINQ.
            </summary>
      <typeparam name="TParseResult">The type of the elements that are originally generated from parsing the source elements.</typeparam>
      <typeparam name="TSource">The type of the source elements; typically, this will be an anonymous compiler-generaed type.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The parser query context to be projected.</param>
      <param name="selector">A function that projects the current result of the query context.</param>
      <returns>A new query context that is the projection of the specified query context using the specified <paramref name="selector" />.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;StringParserQueryContext&lt;TParseResult, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Select``3(Rxx.Parsers.XmlParserQueryContext{``0,``1},System.Func{``1,``2})">
      <summary>
            Enables defining in-line parser grammars using LINQ.
            </summary>
      <typeparam name="TParseResult">The type of the elements that are originally generated from parsing the source elements.</typeparam>
      <typeparam name="TSource">The type of the source elements; typically, this will be an anonymous compiler-generaed type.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The parser query context to be projected.</param>
      <param name="selector">A function that projects the current result of the query context.</param>
      <returns>A new query context that is the projection of the specified query context using the specified <paramref name="selector" />.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;XmlParserQueryContext&lt;TParseResult, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Select``3(Rxx.Parsers.IParser{``0,``1},System.Func{``1,``2})">
      <summary>
            Projects matches from the specified <paramref name="parser" /> into a new form.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the specified <paramref name="parser" />.</typeparam>
      <param name="parser">The parser from which matches will be projected by the specified <paramref name="selector" /> function.</param>
      <param name="selector">A transform function to apply to each match.</param>
      <returns>A parser that projects matches from the specified <paramref name="parser" /> into a new form.</returns>
      <requires>parser != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.SelectMany``4(Rxx.Parsers.IParser{``0,``1},System.Func{``1,Rxx.Parsers.IParser{``0,``2}},System.Func{``1,``2,``3})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into another parser, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TSecondResult">The type of the elements that are generated from the projected parsers.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the projected parsers.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified parser selector function to create 
            the next parser.</param>
      <param name="parserSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each match from the projected parsers.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into another parser, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>parserSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.SelectMany``4(Rxx.Parsers.IParser{``0,``1},System.Func{``1,Rxx.Parsers.IParser{``0,``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},Rxx.Parsers.IParseResult{``2},System.Int32})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into another parser, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TSecondResult">The type of the elements that are generated from the projected parsers.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the projected parsers.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified parser selector function to create 
            the next parser.</param>
      <param name="parserSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each match from the projected parsers.</param>
      <param name="lengthSelector">A function that returns the length for each pair of projected matches.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into another parser, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>parserSelector != null</requires>
      <requires>resultSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.SelectMany``4(Rxx.Parsers.IParser{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``2}},System.Func{``1,``2,``3})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into an enumerable sequence, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TCollection">The type of the elements in the sequences that are projected from the matches.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the projected sequences.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified collection selector function.</param>
      <param name="collectionSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each element from the projected sequences.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into an enumerable sequence, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>collectionSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.SelectMany``4(Rxx.Parsers.IParser{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},``2,System.Int32})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into an enumerable sequence, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TCollection">The type of the elements in the sequences that are projected from the matches.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the projected sequences.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified collection selector function.</param>
      <param name="collectionSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each element from the projected sequences.</param>
      <param name="lengthSelector">A function that returns the length for each pair of projected values.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into an enumerable sequence, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>collectionSelector != null</requires>
      <requires>resultSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.WithDefault``2(Rxx.Parsers.IParser{``0,``1},``1)">
      <summary>
            Matches the specified <paramref name="parser" /> or yields the specified default result if there are 
            no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <param name="defaultResult">The value that is yielded if the specified <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> or the specified default result
            if the <paramref name="parser" /> does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.None``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Yields success when the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which any match results in failure.</param>
      <returns>A parser that yields failure when the specified <paramref name="parser" /> matches or 
            an empty sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.None``3(Rxx.Parsers.IParser{``0,``1},``2)">
      <summary>
            Yields success when the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TSuccess">The type of the success value.</typeparam>
      <param name="parser">The parser for which any match results in failure.</param>
      <param name="successResult">The value that is yielded if the specified <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields failure when the specified <paramref name="parser" /> matches or success when 
            it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TSuccess&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Maybe``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> or yields success without a value when it does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> or 
            an empty enumerable sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Maybe``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Matches the specified <paramref name="parser" /> or yields success without a value when it does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> or 
            an empty enumerable sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Exactly``2(Rxx.Parsers.IParser{``0,``1},System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> the specified number of times.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched.</param>
      <param name="count">The specified number of times to match the specified <paramref name="parser" />.</param>
      <returns>A parser that matches the specified <paramref name="parser" /> the specified number of times.</returns>
      <requires>parser != null</requires>
      <requires>count &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.NoneOrMore``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.NoneOrMoreNonGreedy``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively, making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Linq.ParserExtensions.NoneOrMore``2(Rxx.Parsers.IParser{``0,``1})" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively, 
            making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.NoneOrMore``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.NoneOrMoreNonGreedy``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively, matching the specified 
            <paramref name="separator" /> in between and making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Linq.ParserExtensions.NoneOrMore``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively, 
            matching the specified <paramref name="separator" /> in between and making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.OneOrMore``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.OneOrMoreNonGreedy``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively, making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Linq.ParserExtensions.OneOrMore``2(Rxx.Parsers.IParser{``0,``1})" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively, 
            making the least number of matches possible..</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.OneOrMore``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.OneOrMoreNonGreedy``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively, matching the specified 
            <paramref name="separator" /> in between and making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Linq.ParserExtensions.OneOrMore``2(Rxx.Parsers.IParser{``0,``1},Rxx.Parsers.IParser{``0,``1})" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively, 
            matching the specified <paramref name="separator" /> in between and making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AtLeast``2(Rxx.Parsers.IParser{``0,``1},System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively a minimum number of times.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively a minimum number of times.</param>
      <param name="count">The minimum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> the minimum 
            number of times specified by <paramref name="count" />.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AtLeast``2(Rxx.Parsers.IParser{``0,``1},System.Int32,System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively between the specified number of times, inclusive.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively between the specified number of times.</param>
      <param name="count">The minimum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <param name="maximum">The maximum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> between the specified number of 
            times, inclusive.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <requires>maximum &gt;= count</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AtLeastNonGreedy``2(Rxx.Parsers.IParser{``0,``1},System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively a minimum number of times, making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Linq.ParserExtensions.AtLeast``2(Rxx.Parsers.IParser{``0,``1},System.Int32)" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively a minimum number of times.</param>
      <param name="count">The minimum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> the minimum 
            number of times specified by <paramref name="count" />, making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AtLeastNonGreedy``2(Rxx.Parsers.IParser{``0,``1},System.Int32,System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively between the specified number of times, inclusive, 
            making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Linq.ParserExtensions.AtLeast``2(Rxx.Parsers.IParser{``0,``1},System.Int32,System.Int32)" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively a minimum number of times.</param>
      <param name="count">The minimum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <param name="maximum">The maximum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> between the specified number of 
            times, inclusive, making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <requires>maximum &gt;= count</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.OnSuccess``2(Rxx.Parsers.IParser{``0,``1},System.Action{Rxx.Parsers.IParseResult{``1}})">
      <summary>
            Invokes the specified <paramref name="action" /> on each result for its side-effects.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which results will be supplied to the specified <paramref name="action" />.</param>
      <param name="action">The method that will be called for each parser result.</param>
      <returns>A new parser that is the same as the specified parser and also inovkes the specified 
            <paramref name="action" /> with each result for its side-effects.</returns>
      <requires>parser != null</requires>
      <requires>action != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.OnFailure``2(Rxx.Parsers.IParser{``0,``1},System.Action)">
      <summary>
            Invokes the specified <paramref name="action" /> for its side-effects if the specified <paramref name="parser" />
            does not yield any results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which no results will cause the specified <paramref name="action" /> to be invoked.</param>
      <param name="action">Invoked if the <paramref name="parser" /> does not yield any results.</param>
      <returns>A new parser that is the same as the specified parser and also inovkes the specified 
            <paramref name="action" /> for its side-effects if the specified <paramref name="parser" /> does not yield
            any results.</returns>
      <requires>parser != null</requires>
      <requires>action != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Defer``2(System.Func{Rxx.Parsers.IParser{``0,``1}})">
      <summary>
            Defers creation of a parser until the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> method is called.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parserFactory">A function that returns the underlying <see cref="T:Rxx.Parsers.IParser`2" /> on which 
            the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> method will be called.</param>
      <returns>A parser that defers creation of its underlying parser until the <see cref="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" /> 
            method is called.</returns>
      <requires>parserFactory != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Success``3(Rxx.Parsers.IParser{``0,``1},``2)">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding the specified scalar <paramref name="result" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the <paramref name="result" />.</typeparam>
      <param name="parser">The parser for which the specified <paramref name="result" /> indicates success.</param>
      <param name="result">The value of the created parser's result.</param>
      <returns>A parser that always returns the specified scalar <paramref name="result" /> with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Success``3(Rxx.Parsers.IParser{``0,``1},``2,System.Int32)">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding the specified scalar <paramref name="result" /> 
            with the specified length.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the <paramref name="result" />.</typeparam>
      <param name="parser">The parser for which the specified <paramref name="result" /> indicates success.</param>
      <param name="result">The value of the created parser's result.</param>
      <param name="length">The length of the created parser's result.</param>
      <returns>A parser that always returns the specified scalar <paramref name="result" /> with the specified 
            length, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Success``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding a single result containing an empty sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which a single empty result sequence is returned to indicate success.</param>
      <returns>A parser that returns a single result containing an empty sequence with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Success``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding a single result containing an empty sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements in the sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which a single empty result sequence is returned to indicate success.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Success``2(Rxx.Parsers.IParser{``0,System.Collections.Generic.IEnumerable{``1}})" /> is required as an explicit overload
            because the meaning of the parser's result sequence is special and must not be compounded into a sequence of sequences, 
            which would happen if the <see cref="M:Rxx.Parsers.Linq.ParserExtensions.Success``2(Rxx.Parsers.IParser{``0,``1})" /> overload were to be called
            instead.
            </remarks>
      <returns>A parser that returns a single result containing an empty sequence with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.Failure``2(Rxx.Parsers.IParser{``0,``1})">
      <summary>
            Indicates a failure to parse without actually parsing by returning an empty sequence of parse results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that is to fail.</param>
      <returns>A parser that always returns an empty sequence of parse results, starting from the index at which 
            the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.ParseException">
      <summary>
            Represents errors that occur while parsing a sequence.
            </summary>
      <invariant>sourceIndex &gt;= 0</invariant>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the default <see cref="P:Rxx.Parsers.ParseException.Message" />.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.Int32)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the default <see cref="P:Rxx.Parsers.ParseException.Message" />
            and the specified <see cref="P:Rxx.Parsers.ParseException.SourceIndex" />.
            </summary>
      <param name="sourceIndex">The index in the sequence at which the error occurred while parsing.</param>
      <requires>sourceIndex &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the specified <paramref name="message" />.
            </summary>
      <param name="message">The message that describes the parser error.</param>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.Int32,System.String)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the specified <paramref name="message" />
            and <see cref="P:Rxx.Parsers.ParseException.SourceIndex" />.
            </summary>
      <param name="sourceIndex">The index in the sequence at which the error occurred while parsing.</param>
      <param name="message">The message that describes the parser error.</param>
      <requires>sourceIndex &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.String,System.Exception)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the specified <paramref name="message" />
            and <paramref name="innerException" />.
            </summary>
      <param name="message">The message that describes the parser error.</param>
      <param name="innerException">The exception that is the cause of the current exception, or <see langword="null" /> if no inner exception is specified.</param>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.Int32,System.Exception)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the default <see cref="P:Rxx.Parsers.ParseException.Message" />
            and the specified <see cref="P:Rxx.Parsers.ParseException.SourceIndex" /> and <paramref name="innerException" />.
            </summary>
      <param name="sourceIndex">The index in the sequence at which the error occurred while parsing.</param>
      <param name="innerException">The exception that is the cause of the current exception, or <see langword="null" /> if no inner exception is specified.</param>
      <requires>sourceIndex &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.ParseException.#ctor(System.Int32,System.String,System.Exception)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.ParseException" /> class with the specified <paramref name="message" />, 
            <see cref="P:Rxx.Parsers.ParseException.SourceIndex" /> and <paramref name="innerException" />.
            </summary>
      <param name="sourceIndex">The index in the sequence at which the error occurred while parsing.</param>
      <param name="message">The message that describes the parser error.</param>
      <param name="innerException">The exception that is the cause of the current exception, or <see langword="null" /> if no inner exception is specified.</param>
      <requires>sourceIndex &gt;= 0</requires>
    </member>
    <member name="P:Rxx.Parsers.ParseException.SourceIndex">
      <summary>
            Gets the index in the sequence at which the error occurred while parsing.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.ParseException.Message">
      <summary>
            Gets a message that describes the parser error.
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Exception.get_Message" inheritedFromTypeName="Exception">Contract.Result&lt;string&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:System.Linq.ICursor`1">
      <summary>
            Represents a shared enumerable sequence that replays values from a current index that can be moved,
            along with support for optimized branching.
            </summary>
      <remarks>
        <alert type="implementors">
            The contracts of <see cref="T:System.Linq.ICursor`1" /> rely on some of the properties being immutable.
            The <see cref="P:System.Linq.ICursor`1.IsForwardOnly" /> property must be immutable.  Furthermore, the <see cref="P:System.Linq.ICursor`1.IsSequenceTerminated" /> property 
            must be <see langword="false" /> until the sequence terminates, at which time it must return <see langword="true" /> and then 
            hold that value indefinitely.
            </alert>
      </remarks>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <threadsafety instance="false" />
    </member>
    <member name="M:System.Linq.ICursor`1.Move(System.Int32)">
      <summary>
            Changes the current index of the cursor to the element at the specified number of elements forward or backward.
            </summary>
      <param name="count">The number of elements to move after the current index if the specified count is positive
            or before the current index if the specified count is negative.</param>
      <remarks>
        <para>
            The specified <paramref name="count" /> may be a negative number only if <see cref="P:System.Linq.ICursor`1.IsForwardOnly" /> is <see langword="false" />.
            </para>
        <alert type="implementors">
            If the specified <paramref name="count" /> is greater than the length from the current element to the latest
            element in the sequence, then the cursor must virtualize itself by skipping subsequent elements until the position 
            of the cursor is reached.
            </alert>
      </remarks>
      <seealso cref="P:System.Linq.ICursor`1.IsForwardOnly" />
      <requires>!IsForwardOnly || count &gt;= 0</requires>
      <requires>!AtEndOfSequence || count &lt;= 0</requires>
      <requires>CurrentIndex + count &gt;= 0</requires>
      <requires>!IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures>IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures>IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="M:System.Linq.ICursor`1.Branch">
      <summary>
            Returns a new cursor that starts at the current position of this cursor and is tied to the lifetime of this cursor.
            </summary>
      <remarks>
        <alert type="implementors">
          <see cref="M:System.Linq.ICursor`1.Branch" /> provides a means for cursor authors to optimize branches so that they can share the same state.
            </alert>
      </remarks>
      <returns>A new cursor that starts at the current position of this cursor.</returns>
      <ensures>Contract.Result&lt;ICursor&lt;T&gt;&gt;() != null</ensures>
      <ensures>IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures>IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures>AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="M:System.Linq.ICursor`1.Reset">
      <summary>
            Clears any buffered elements, branches and state, and ensures that a subsequent iteration will re-enumerate the source sequence.
            </summary>
      <ensures>IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures>CurrentIndex == 0</ensures>
      <ensures>LatestIndex == -1</ensures>
      <ensures>!IsSequenceTerminated</ensures>
    </member>
    <member name="P:System.Linq.ICursor`1.IsForwardOnly">
      <summary>
            Gets a value indicating whether the cursor only moves forward.
            </summary>
      <remarks>
        <alert type="implementors">
          <see cref="P:System.Linq.ICursor`1.IsForwardOnly" /> must be immutable.  Contracts of <see cref="T:System.Linq.ICursor`1" /> members depend upon it.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the cursor only moves forward; otherwise, <see langword="false" />.</value>
      <seealso cref="M:System.Linq.ICursor`1.Move(System.Int32)" />
    </member>
    <member name="P:System.Linq.ICursor`1.CurrentIndex">
      <summary>
            Gets the zero-based index of the element in the sequence at which the cursor is positioned after 
            <see cref="M:System.Linq.ICursor`1.Move(System.Int32)" /> is called.
            </summary>
      <remarks>
        <para>
          <see cref="P:System.Linq.ICursor`1.CurrentIndex" /> starts and remains at 0 until it is changed by the <see cref="M:System.Linq.ICursor`1.Move(System.Int32)" /> method.  A value of 0 indicates
            that the cursor is positioned at the end of an empty sequence.  If the sequence generates one or more values, then 0 indicates
            that the cursor is positioned at the beginning of the sequence.  Subscribing to a cursor that has not moved replays all values in 
            the sequence, if any.
            </para>
        <para>
            The valid range of values for <see cref="P:System.Linq.ICursor`1.CurrentIndex" /> changes depending upon whether the sequence has terminated.
            If the sequence has not terminated, then <see cref="P:System.Linq.ICursor`1.CurrentIndex" /> can be any value that is greater than or equal to zero, 
            even if that value is greater than <see cref="P:System.Linq.ICursor`1.LatestIndex" />; however, once the sequence has terminated, 
            <see cref="P:System.Linq.ICursor`1.CurrentIndex" /> cannot be moved past one more than the <see cref="P:System.Linq.ICursor`1.LatestIndex" />.  This final position 
            indicates that the cursor is at the end of the sequence.  Enumerating a cursor that is positioned at the end of the sequence 
            causes only the termination notification to be yielded, without replaying any values.
            </para>
        <para>
            If <see cref="P:System.Linq.ICursor`1.CurrentIndex" /> is moved past the latest element in the sequence, as indicated by the value of 
            <see cref="P:System.Linq.ICursor`1.LatestIndex" />, then the existing values in the sequence will not be replayed to new subscriptions; 
            furthermore, any new values with indices that are less than <see cref="P:System.Linq.ICursor`1.CurrentIndex" /> will also be excluded from
            new subscriptions.
            </para>
        <alert type="implementors">
            If the current index is positioned ahead of the latest element in the sequence and the sequence 
            subsequently ends, then the current index must automatically be changed to <see cref="P:System.Linq.ICursor`1.LatestIndex" /> + 1 to indicate 
            that the current index is at the end of the sequence.  Consumers can check whether <see cref="P:System.Linq.ICursor`1.CurrentIndex" /> has changed 
            during the <strong>OnCompleted</strong> notification.
            </alert>
      </remarks>
      <value>The zero-based index of the element in the sequence on which the cursor is positioned after 
            <see cref="M:System.Linq.ICursor`1.Move(System.Int32)" /> is called; otherwise, -1.</value>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures>!IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
    </member>
    <member name="P:System.Linq.ICursor`1.LatestIndex">
      <summary>
            Gets the zero-based index of the last known element in the sequence.
            </summary>
      <value>The zero-based index of the last known element in the sequence; -1 until the sequence produces an element, if any.
            If the sequence has terminated, then the value is the index of the last element in the sequence.</value>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="P:System.Linq.ICursor`1.AtEndOfSequence">
      <summary>
            Gets a value indicating whether the cursor is positioned at the end of the sequence.
            </summary>
      <remarks>
        <alert type="note">
            When <see cref="P:System.Linq.ICursor`1.AtEndOfSequence" /> returns <see langword="false" /> it does not indicate that the sequence has 
            not terminated.  It only indicates that the cursor is not currently positioned at the end of the sequence,
            regardless of whether the sequence has actually terminated or not.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the sequence has terminated and the cursor is currently positioned at the end of the sequence;
            otherwise, <see langword="false" />.</value>
      <seealso cref="P:System.Linq.ICursor`1.IsSequenceTerminated" />
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="P:System.Linq.ICursor`1.IsSequenceTerminated">
      <summary>
            Gets a value indicating whether the sequence has terminated.
            </summary>
      <remarks>
        <alert type="note">
            When <see cref="P:System.Linq.ICursor`1.IsSequenceTerminated" /> returns <see langword="true" /> it does not indicate that the cursor is at the
            end of the sequence.  It only indicates that the sequence has terminated, regardless of whether the cursor is actually 
            positioned at the end of the sequence or not.
            </alert>
        <alert type="implementors">
          <see cref="P:System.Linq.ICursor`1.IsSequenceTerminated" /> must be immutable when it returns <see langword="true" />.  Contracts of 
            <see cref="T:System.Linq.ICursor`1" /> members depend upon it.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the sequence has terminated; otherwise, <see langword="false" />.</value>
      <seealso cref="P:System.Linq.ICursor`1.AtEndOfSequence" />
    </member>
    <member name="T:Rxx.Parsers.ParseResult">
      <summary>
            Provides <see langword="static" /> methods for creating <see cref="T:Rxx.Parsers.ParseResult`1" /> objects.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Add``3(Rxx.Parsers.IParseResult{``0},Rxx.Parsers.IParseResult{``1},System.Func{``0,``1,``2})">
      <summary>
            Applies a selector function to two parse results to produce a new parse result.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TFirstResult">The type of the first parse result's value.</typeparam>
      <typeparam name="TSecondResult">The type of the second parse result's value.</typeparam>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The parse result to be combined with <paramref name="secondResult" />.</param>
      <param name="secondResult">The parse result to be combined with <paramref name="firstResult" />.</param>
      <param name="resultSelector">A function that selects a new parse result from the two specified parse results.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' 
            lengths and the return value of the <paramref name="resultSelector" /> function.</returns>
      <requires>firstResult != null</requires>
      <requires>!(firstResult is ILookAheadParseResult&lt;TFirstResult&gt;)</requires>
      <requires>secondResult != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Concat``1(Rxx.Parsers.IParseResult{System.Collections.Generic.IEnumerable{``0}},Rxx.Parsers.IParseResult{``0})">
      <summary>
            Concatenates the specified parse result value sequence and scalar parse result value into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The parse result value sequence to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The scalar parse result value to be concatenated to the value of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' lengths and 
            the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>firstResult.Value != null</requires>
      <requires>!(firstResult is ILookAheadParseResult&lt;IEnumerable&lt;TResult&gt;&gt;)</requires>
      <requires>secondResult != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Concat``1(Rxx.Parsers.IParseResult{``0},Rxx.Parsers.IParseResult{System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Concatenates the specified scalar parse result value and parse result value sequence into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The scalar parse result value to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The parse result value sequence to be concatenated to the value of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' 
            lengths and the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>!(firstResult is ILookAheadParseResult&lt;TResult&gt;)</requires>
      <requires>secondResult != null</requires>
      <requires>secondResult.Value != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Concat``1(Rxx.Parsers.IParseResult{System.Collections.Generic.IEnumerable{``0}},Rxx.Parsers.IParseResult{System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Concatenates the specified parse result value sequences into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The parse result value sequence to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The parse result value sequence to be concatenated to the value sequence of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' 
            lengths and the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>firstResult.Value != null</requires>
      <requires>!(firstResult is ILookAheadParseResult&lt;IEnumerable&lt;TResult&gt;&gt;)</requires>
      <requires>secondResult != null</requires>
      <requires>secondResult.Value != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Create``1(``0,System.Int32)">
      <summary>
            Creates a new <see cref="T:Rxx.Parsers.IParseResult`1" /> instance from the specified 
            <paramref name="value" /> and <paramref name="length" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="value">The projection of elements of a parse operation.</param>
      <param name="length">The number of elements that were consumed in the sequence to generate 
            the specified <paramref name="value" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> instance containing the specified 
            <paramref name="value" /> and <paramref name="length" />.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.CreateLookAhead``1(``0,System.Int32)">
      <summary>
            Creates a new <see cref="T:Rxx.Parsers.ILookAheadParseResult`1" /> instance from the specified 
            <paramref name="value" /> and <paramref name="length" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="value">The projection of elements of a parse operation.</param>
      <param name="length">The number of elements that were consumed in the sequence to generate 
            the specified <paramref name="value" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.ILookAheadParseResult`1" /> instance containing the specified 
            <paramref name="value" /> and <paramref name="length" />.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;ILookAheadParseResult&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Return``1(``0,System.Int32)">
      <summary>
            Creates a singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" />  
            with the specified <paramref name="value" /> and <paramref name="length" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="value">The projection of elements of a parse operation.</param>
      <param name="length">The number of elements that were consumed in the sequence to generate 
            the specified <paramref name="value" />.</param>
      <returns>A singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" />  
            with the specified <paramref name="value" /> and <paramref name="length" />.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Success``1(System.Int32)">
      <summary>
            Creates a new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified <paramref name="length" />
            and the default value for the specified <typeparamref name="TValue" /> type.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified 
            <paramref name="length" /> and a default value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.SuccessMany``1(System.Int32)">
      <summary>
            Creates a new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified 
            <paramref name="length" /> and an empty sequence for the value.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified 
            <paramref name="length" /> and an empty sequence for the value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IEnumerable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.ReturnSuccess``1(System.Int32)">
      <summary>
            Creates a singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> with 
            the specified <paramref name="length" /> and the default value for the specified 
            <typeparamref name="TValue" /> type.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> with 
            the specified <paramref name="length" /> and a default value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.ReturnSuccessMany``1(System.Int32)">
      <summary>
            Creates a singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> 
            with the specified <paramref name="length" /> and an empty sequence for the value.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A singleton enumerable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> 
            with the specified <paramref name="length" /> and an empty sequence for the value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;IEnumerable&lt;TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.ReturnFailure``1">
      <summary>
            Creates an empty enumerable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <returns>An empty enumerable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.</returns>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.ReturnFailureMany``1">
      <summary>
            Creates an empty enumerable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <returns>An empty enumerable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.</returns>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``1(Rxx.Parsers.IParseResult{``0})">
      <summary>
            Clones the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> from which to create a new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the same length and value as the 
            specified <paramref name="result" />.</returns>
      <requires>result != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``1(Rxx.Parsers.IParseResult{``0},System.Int32)">
      <summary>
            Creates a new parse result with the specified <paramref name="length" /> 
            and the same value as the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> that provides the length.</param>
      <param name="length">The length of the new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified <paramref name="length" /> 
            and the same value as the specified <paramref name="result" />.</returns>
      <requires>result != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``2(Rxx.Parsers.IParseResult{``0},``1)">
      <summary>
            Creates a new parse result with the specified value and the length of the specified 
            <paramref name="result" />.
            </summary>
      <typeparam name="TOldValue">The type of the old parse result's value.</typeparam>
      <typeparam name="TNewValue">The type of the new parse result's value</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> that provides the length.</param>
      <param name="value">The value of the new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified value and the length of the specified 
            <paramref name="result" />.</returns>
      <requires>result != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TNewValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``2(Rxx.Parsers.IParseResult{``0},System.Func{``0,``1})">
      <summary>
            Creates a new parse result with the value returned by the specified selector and the length of the 
            specified <paramref name="result" />.
            </summary>
      <typeparam name="TOldValue">The type of the old parse result's value.</typeparam>
      <typeparam name="TNewValue">The type of the new parse result's value</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> that provides the length.</param>
      <param name="valueSelector">A function that selects the value for the new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the value returned by the specified selector 
            and the length of the specified <paramref name="result" />.</returns>
      <requires>result != null</requires>
      <requires>valueSelector != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TNewValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``3(Rxx.Parsers.IParseResult{``0},Rxx.Parsers.IParseResult{``1},System.Func{``0,``1,``2},System.Func{Rxx.Parsers.IParseResult{``0},Rxx.Parsers.IParseResult{``1},System.Int32})">
      <summary>
            Creates a new parse result from two parse results with the length and value returned 
            by the specified selectors.
            </summary>
      <typeparam name="TFirstValue">The type of the first parse result's value.</typeparam>
      <typeparam name="TSecondValue">The type of the second parse result's value.</typeparam>
      <typeparam name="TNewValue">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The first parse result.</param>
      <param name="secondResult">The second parse result.</param>
      <param name="valueSelector">A function that selects the value for the new parse result.</param>
      <param name="lengthSelector">A function that selects the length for the new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the length and value returned by the 
            specified selectors.</returns>
      <requires>firstResult != null</requires>
      <requires>!(firstResult is ILookAheadParseResult&lt;TFirstValue&gt;)</requires>
      <requires>secondResult != null</requires>
      <requires>valueSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TNewValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``3(Rxx.Parsers.IParseResult{``0},``1,System.Func{``0,``1,``2},System.Func{Rxx.Parsers.IParseResult{``0},``1,System.Int32})">
      <summary>
            Creates a new parse result from a parse result and another value with the length and value 
            returned by the specified selectors.
            </summary>
      <typeparam name="TOldValue">The type of the old parse result's value.</typeparam>
      <typeparam name="TOther">The type of the other value.</typeparam>
      <typeparam name="TNewValue">The type of the new parse result's value.</typeparam>
      <param name="result">The old parse result from which to create a new parse result.</param>
      <param name="other">The other value from which to create a new parse result.</param>
      <param name="valueSelector">A function that selects the value for the new parse result.</param>
      <param name="lengthSelector">A function that selects the length for the new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the length and value returned by the 
            specified selectors.</returns>
      <requires>result != null</requires>
      <requires>other != null</requires>
      <requires>valueSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TNewValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.YieldMany``1(Rxx.Parsers.IParseResult{``0})">
      <summary>
            Creates a new parse result with the length of the specified <paramref name="result" />
            and a singleton enumerable sequence containing the value of the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> from which to create a new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the same length and value as the 
            specified <paramref name="result" />, although with the value wrapped in a singleton enumerable sequence.</returns>
      <requires>result != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IEnumerable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.YieldMany``1(Rxx.Parsers.IParseResult{``0},System.Int32)">
      <summary>
            Creates a new parse result with the specified <paramref name="length" /> and a singleton enumerable 
            sequence containing the value of the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> from which to create a new parse result.</param>
      <param name="length">The length of the new result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the same length and value as the 
            specified <paramref name="result" />, although with the value wrapped in a singleton enumerable sequence.</returns>
      <requires>result != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IEnumerable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.ParserQueryContext`3">
      <summary>
            Represents a parser context over an enumerable sequence to support in-line grammars.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TQueryValue">The type of the current value in the query context.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.ParserStart`2">
      <summary>
            Represents a parser that begins a parse operation at the beginning of the source sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>grammar != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.Reactive.IObservableParser`2">
      <summary>
            Represents a parser over an observable sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})">
      <summary>
            Subscribes to the specified observable sequence and applies the parser's grammar, which is defined in 
            terms of the <see cref="P:Rxx.Parsers.Reactive.IObservableParser`2.Next" /> parser, to generate matches asynchronously.
            </summary>
      <param name="source">The observable sequence to parse.</param>
      <returns>An observable sequence of parse results that contain information about the matches.</returns>
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IObservableParser`2.Next">
      <summary>
            Gets a parser with a grammar that matches the next element in the source sequence.
            </summary>
      <remarks>
            A parser's grammar is defined in terms of grammar rules, each of which is defined in terms of the <see cref="P:Rxx.Parsers.Reactive.IObservableParser`2.Next" /> parser
            or another rule.
            </remarks>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AmbiguousObservableParser`3">
      <summary>
            Represents an ambiguous parser that begins a parse operation at the current position of the source sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TUntilResult">The type of the elements that are generated by the optional until parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>parser != null</invariant>
      <invariant>untilCount &gt;= unlimitedCount</invariant>
    </member>
    <member name="T:Rxx.Parsers.Reactive.ObservableParser`2">
      <summary>
            Represents a parser over an observable sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParser`2.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.Parser`2" /> class for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})">
      <summary>
            Subscribes to the specified observable sequence and applies the parser's grammar, 
            which is defined by <see cref="P:Rxx.Parsers.Reactive.ObservableParser`2.Start" />, to generate matches.
            </summary>
      <param name="source">The oservable sequence to parse.</param>
      <returns>An observable sequence of parse results.</returns>
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParser`2.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current parser.
            </summary>
      <returns>A <see cref="T:System.String" /> that represents the current parser.</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParser`2.Next">
      <summary>
            Gets a parser with a grammar that matches the next element in the source sequence.
            </summary>
      <remarks>
            A parser's grammar is defined in terms of grammar rules, each of which is defined in terms of the <see cref="P:Rxx.Parsers.Reactive.ObservableParser`2.Next" /> parser
            or another rule.
            </remarks>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParser`2.Start">
      <summary>
            Gets the parser's grammar as a parser that is defined in terms of the <see cref="P:Rxx.Parsers.Reactive.ObservableParser`2.Next" /> parser.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.StringObservableParser`1">
      <summary>
            Represents a parser over an observable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
      <invariant>whiteSpace != null</invariant>
      <invariant>insignificantWhiteSpace != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.Reactive.IStringObservableParser`1">
      <summary>
            Represents a parser over an observable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires>stops != null</requires>
      <requires>stops.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires>stopWords != null</requires>
      <requires>stopWords.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires>!string.IsNullOrEmpty(value)</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IStringObservableParser`1.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IStringObservableParser`1.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive insignificant whitespace characters and joins
            them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.Reactive.StringObservableParser`1" /> class for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires>stops != null</requires>
      <requires>stops.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires>stopWords != null</requires>
      <requires>stopWords.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires>!string.IsNullOrEmpty(value)</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive whitespace characters determined by the 
            <see cref="P:Rxx.Parsers.Reactive.StringObservableParser`1.InsignificantWhiteSpaceCharacters" /> collection and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.InsignificantWhiteSpaceCharacters">
      <summary>
            Gets a collection of characters that are considered insignificant whitespace for the  
            <see cref="P:Rxx.Parsers.Reactive.StringObservableParser`1.InsignificantWhiteSpace" /> parser.  
            </summary>
      <getter>
        <ensures>Contract.Result&lt;ICollection&lt;char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.XmlObservableParser`1">
      <summary>
            Represents an XML parser over an observable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of XML nodes.</typeparam>
      <invariant>comparer != null</invariant>
      <invariant>id != null</invariant>
      <invariant>tagStart != null</invariant>
      <invariant>tagEnd != null</invariant>
      <invariant>tagName != null</invariant>
      <invariant>attributeDelimiter != null</invariant>
      <invariant>attributeName != null</invariant>
      <invariant>attributeValue != null</invariant>
      <invariant>attribute != null</invariant>
      <invariant>openTag != null</invariant>
      <invariant>closeTag != null</invariant>
      <invariant>text != null</invariant>
      <invariant>comment != null</invariant>
      <invariant>cData != null</invariant>
      <invariant>element != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.Reactive.IXmlObservableParser`1">
      <summary>
            Represents an XML parser over an observable sequence of <see cref="T:System.Char" />.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of XML nodes.</typeparam>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Attribute(System.String)">
      <summary>
            Creates a parser that matches a single XML attribute with the specified <paramref name="name" />.
            </summary>
      <param name="name">The name of the attribute to match.</param>
      <returns>A parser that matches a single XML attribute with the specified <paramref name="name" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified children.
            </summary>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified children.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified attributes and children.
            </summary>
      <remarks>
            IObservableParser is not covariant on TResult in Windows Phone because <see cref="T:System.IObservable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.
            </summary>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.
            </summary>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.</returns>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified children.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified children.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.
            </summary>
      <remarks>
            IObservableParser is not covariant on TResult in Windows Phone because <see cref="T:System.IObservable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, having no attributes
            and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, having no attributes 
            and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">An enumerable sequence containing the names of the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.Text">
      <summary>
            Gets a parser with a grammar that matches all characters, including whitespace, up to the start tag of an element.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.Comment">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;!-- and ending with --&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.CData">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;![CDATA[ and ending with ]]&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.AnyContent">
      <summary>
            Gets a parser with a grammar that matches any <see cref="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.Text" />, <see cref="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.Comment" /> or <see cref="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.CData" /> content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.AnyElement">
      <summary>
            Gets a parser with a grammar that matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.IXmlObservableParser`1.AnyAttribute">
      <summary>
            Gets a parser with a grammar that matches an XML attribute.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.#ctor(System.Boolean)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.Reactive.XmlObservableParser`1" /> class with the specified case-sensitivity
            for derived classes.
            </summary>
      <param name="caseSensitive">Indicates whether the comparison behavior used for matching element and attribute names
            must ignore case.</param>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.Reactive.XmlObservableParser`1" /> class with case-sensitive element and 
            attribute name comparisons for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Attribute(System.String)">
      <summary>
            Creates a parser that matches a single XML attribute with the specified <paramref name="name" />.
            </summary>
      <param name="name">The name of the attribute to match.</param>
      <returns>A parser that matches a single XML attribute with the specified <paramref name="name" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified children.
            </summary>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified attributes and children.
            </summary>
      <remarks>
            IObservableParser is not covariant on TResult in Windows Phone because <see cref="T:System.IObservable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.
            </summary>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.</returns>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.
            </summary>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.</returns>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified children.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.
            </summary>
      <remarks>
            IObservableParser is not covariant on TResult in Windows Phone because <see cref="T:System.IObservable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, having no attributes
            and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, having no attributes 
            and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">An enumerable sequence containing the names of the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Start">
      <summary>
            Gets the <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Schema" /> that is the parser's grammar.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParser`2.get_Start" inheritedFromTypeName="ObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Schema">
      <summary>
            Gets the parser's grammar as an XML schema that is defined in terms of the parsers created by
            <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.AnyElement" />, <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.AnyAttribute" />, <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.AnyContent" />, <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Text" />, 
            <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Comment" />, <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.CData" /> or any of the methods that create parsers with 
            context-sensitive grammars, such as <see cref="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" /> and 
            <see cref="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Attribute(System.String)" /></summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Text">
      <summary>
            Gets a parser with a grammar that matches all characters, including whitespace, up to the start tag of an element.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Comment">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;!-- and ending with --&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.CData">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;![CDATA[ and ending with ]]&gt;.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.AnyContent">
      <summary>
            Gets a parser with a grammar that matches any <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Text" />, <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Comment" /> or <see cref="P:Rxx.Parsers.Reactive.XmlObservableParser`1.CData" /> content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.AnyElement">
      <summary>
            Gets a parser with a grammar that matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.AnyAttribute">
      <summary>
            Gets a parser with a grammar that matches an XML attribute.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions">
      <summary>
            Provides <see langword="static" /> methods for defining <see cref="T:Rxx.Parsers.Reactive.IObservableParser`2" /> grammars.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Aggregate``4(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},System.Func{``2},System.Func{``2,``1,``2},System.Func{``2,``3})">
      <summary>
            Applies an <paramref name="accumulator" /> function over each result sequence from the 
            specified <paramref name="parser" /> and yields a sequence of accumulated results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TAccumulate">The type of the accumulation.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulation.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be aggregated.</param>
      <param name="seed">A function that returns the initial value of the accumulation for each parse result.</param>
      <param name="accumulator">A function to be invoked on each element of each parse result.</param>
      <param name="selector">A function that projects the final aggregation of each parse result.</param>
      <returns>A parser that returns the aggregated results.</returns>
      <requires>parser != null</requires>
      <requires>accumulator != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Join``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Appends each element in each result sequence from the specified <paramref name="parser" /> 
            to an accumulated <see cref="T:System.String" />, yielding a single <see cref="T:System.String" /> per result
            sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined into strings.</param>
      <returns>A parser that returns the aggregated <see cref="T:System.String" /> results.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Join``3(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},System.Func{System.String,``2})">
      <summary>
            Appends each element in each result from the specified <paramref name="parser" /> 
            to an accumulated <see cref="T:System.String" /> and projects the strings for each result.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulated <see cref="T:System.String" />.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined.</param>
      <param name="selector">A function that projects the aggregated <see cref="T:System.String" /> of each parse result.</param>
      <returns>A parser that returns the joined results.</returns>
      <requires>parser != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Join``4(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},System.Func{``1,``2},System.Func{System.String,``3})">
      <summary>
            Applies a <paramref name="joiner" /> function over each result from the specified 
            <paramref name="parser" /> to create an accumulated <see cref="T:System.String" /> and projects 
            the strings for each result.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TJoin">The type of the accumulation on which <see cref="M:System.Object.ToString" /> is called.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from projecting the accumulated <see cref="T:System.String" />.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be joined.</param>
      <param name="joiner">A function to be invoked on each element of each parse result to produce a value 
            on which <see cref="M:System.Object.ToString" /> is called and appended to the accumulation.</param>
      <param name="selector">A function that projects the aggregated <see cref="T:System.String" /> of each parse result.</param>
      <returns>A parser that returns the joined results.</returns>
      <requires>parser != null</requires>
      <requires>joiner != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.ToList``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Appends the results of each result sequence from the specified <paramref name="parser" /> into an <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated by the parser.</typeparam>
      <param name="parser">The parser that produces a sequence of result sequences to be aggregated.</param>
      <returns>A parser that returns the results aggregated into an <see cref="T:System.Collections.Generic.IList`1" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IList&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.NonGreedy``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Converts greedy matches from the specified <paramref name="parser" /> into matches that 
            have a length of zero.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The greedy parser to be made into a non-greedy parser.</param>
      <returns>A parser that converts the greedy matches from the specified <paramref name="parser" /> into 
            matches that have a length of zero.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Ambiguous``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until there are no matches or the 
            source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until there are
            no matches or the source sequence ends.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until there are no matches or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Ambiguous``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32)">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until the specified count is reached
            or the source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until the specified 
            count is reached or the source sequence ends.</param>
      <param name="untilCount">Indicates the maximum number of ambiguous matches to find.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until the specified count is reached or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <requires>untilCount &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Ambiguous``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Parses multiple sequences with the specified <paramref name="parser" />, starting from the beginning 
            of the source sequence and then skipping one element at a time, until the other parser matches or the 
            source sequence ends.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TUntilResult">The type of the elements that are generated by the until parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The unambiguous parser that will parse each consecutive sequence until the other 
            parser matches or the source sequence ends.</param>
      <param name="untilParser">The parser that ends the ambiguity when it matches.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> for each 
            consecutive sequence, starting from the beginning of the source sequence and then skipping one element 
            at a time, until the other parser matches or the source sequence ends.</returns>
      <requires>parser != null</requires>
      <requires>untilParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Amplify``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into a singleton observable sequence
            that contains the match's value.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be projected into singleton observable sequences.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> projected into singleton
            observable sequences.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Single``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Matches the single element from the ambiguous result sequence in each match that is yielded by the specified 
            <paramref name="parser" /> and fails for any match in which there is zero or more than one element.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which the single result element is yielded for each match.</param>
      <returns>A parser that matches the single element from the result sequence of each match that is 
            yielded by the specified <paramref name="parser" /> and fails for any match in which there is zero 
            or more than one element.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{System.Reactive.IObservableCursor{``0},System.IObservable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> method 
            for the generated parser.</param>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.String,System.Func{System.Reactive.IObservableCursor{``0},System.IObservable{Rxx.Parsers.IParseResult{``2}}})">
      <summary>
            Creates a parser with the specified <paramref name="parse" /> function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified <paramref name="parse" /> 
            function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parse">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> method 
            for the generated parser.</param>
      <returns>A parser with the specified <paramref name="parse" /> function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parse != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{System.Reactive.IObservableCursor{``0},System.IObserver{Rxx.Parsers.IParseResult{``1}},System.IDisposable})">
      <summary>
            Creates a parser with the specified subscriber function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parseSubscribe">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> method 
            for the generated parser as an observable subscription.</param>
      <returns>A parser with the specified subscriber function.</returns>
      <requires>parser != null</requires>
      <requires>parseSubscribe != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.String,System.Func{System.Reactive.IObservableCursor{``0},System.IObserver{Rxx.Parsers.IParseResult{``1}},System.IDisposable})">
      <summary>
            Creates a parser with the specified subscriber function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parseSubscribe">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> method 
            for the generated parser as an observable subscription.</param>
      <returns>A parser with the specified subscriber function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parseSubscribe != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{System.Reactive.IObservableCursor{``0},System.IObserver{Rxx.Parsers.IParseResult{``2}},System.IDisposable})">
      <summary>
            Creates a parser with the specified subscriber function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified subscriber function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="parseSubscribe">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> method 
            for the generated parser as an observable subscription.</param>
      <returns>A parser with the specified subscriber function.</returns>
      <requires>parser != null</requires>
      <requires>parseSubscribe != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Yield``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.String,System.Func{System.Reactive.IObservableCursor{``0},System.IObserver{Rxx.Parsers.IParseResult{``2}},System.IDisposable})">
      <summary>
            Creates a parser with the specified subscriber function, starting at the index of the specified parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from the specified subscriber function.</typeparam>
      <param name="parser">The parser at which parsing begins.</param>
      <param name="name">The name of the parser that will appear in diagnostic trace output.</param>
      <param name="parseSubscribe">A function that defines the behavior of the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> method 
            for the generated parser as an observable subscription.</param>
      <returns>A parser with the specified subscriber function.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>parseSubscribe != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AsString``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Converts matches from the specified <paramref name="parser" /> into strings.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be converted into strings.</param>
      <returns>A parser that yields strings for the matches from the specified <paramref name="parser" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Cast``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Casts results from the specified <paramref name="parser" /> into the specified type.
            </summary>
      <remarks>
        <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Cast``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1})" /> is required for Windows Phone because it doesn't support covariance on 
            <see cref="T:System.IObservable`1" />, which is required for <see cref="T:Rxx.Parsers.Reactive.IObservableParser`2" /> to support covariance on 
            <strong>TResult</strong>.  A consequence is that parsers must sometimes be cast down to their base types before
            they can be combined using various parser operators.
            </remarks>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The original type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TCastResult">The type to which the elements that are generated from parsing the source elements are cast.</typeparam>
      <param name="parser">The parser from which results will be cast into the specified type.</param>
      <returns>A parser that casts results from the specified <paramref name="parser" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TCastResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Required``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> if the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> if there are no matches.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Required``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.String)">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> with the specified message if the specified <paramref name="parser" /> 
            does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="errorMessage">A <see cref="T:System.String" /> that describes the failed expectation to be used as the message 
            in the <see cref="T:Rxx.Parsers.ParseException" />.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> with the specified message if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(errorMessage)</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Required``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{System.String})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> with a message returned by the specified function if the specified 
            <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="errorMessageFactory">A function that returns a <see cref="T:System.String" /> describing the failed expectation 
            to be used as the message in the <see cref="T:Rxx.Parsers.ParseException" />.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> with a message returned by the specified functions if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>errorMessageFactory != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Required``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{System.Int32,System.Exception})">
      <summary>
            Throws a <see cref="T:Rxx.Parsers.ParseException" /> returned by the specified function if the specified 
            <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that must succeed otherwise a <see cref="T:Rxx.Parsers.ParseException" /> is thrown.</param>
      <param name="exceptionFactory">A function that returns the <see cref="T:Rxx.Parsers.ParseException" /> to be thrown describing the 
            failed expectation.</param>
      <returns>A parser that yields the matches from the specified <paramref name="parser" /> or throws
            a <see cref="T:Rxx.Parsers.ParseException" /> returned by the specified functions if there are no matches.</returns>
      <requires>parser != null</requires>
      <requires>exceptionFactory != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Where``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,System.Boolean})">
      <summary>
            Matches all results from the specified <paramref name="parser" /> for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches will be filtered by the specified <paramref name="predicate" />.</param>
      <param name="predicate">A function that returns <see langword="true" /> to indicate when a match should be yielded and 
            <see langword="false" /> when a match should be ignored.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> for which 
            the specified <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires>parser != null</requires>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.IgnoreBefore``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``2})">
      <summary>
            Matches the left parser followed by the right parser, but only returns the right parser's matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIgnore">The type of the elements that are generated by the left parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated by the right parser.</typeparam>
      <param name="ignoreParser">The parser from which to ignore matches.</param>
      <param name="parser">The parser from which to yield matches.</param>
      <returns>A parser that matches the left parser followed by the right parser, but only returns the 
            right parser's matches.</returns>
      <requires>ignoreParser != null</requires>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.IgnoreTrailing``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser, but only returns the left parser's matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIgnore">The type of the elements that are generated by the right parser.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated by the left parser.</typeparam>
      <param name="parser">The parser from which to yield matches.</param>
      <param name="ignoreParser">The parser from which to ignore matches.</param>
      <returns>A parser that matches the left parser followed by the right parser, but only returns the 
            left parser's matches.</returns>
      <requires>parser != null</requires>
      <requires>ignoreParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Of``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``1)">
      <summary>
            Matches all results from the specified <paramref name="parser" /> that equal the specified
            <paramref name="value" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches equivalent to the specified <paramref name="value" /> will be yielded.</param>
      <param name="value">The value to be compared to matches for equality.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> that equal
            the specified <paramref name="value" />.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Of``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``1,System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Matches all results from the specified <paramref name="parser" /> that equal the specified
            <paramref name="value" /> using the specified <paramref name="comparer" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which matches equivalent to the specified <paramref name="value" /> will be yielded.</param>
      <param name="value">The value to be compared to matches for equality.</param>
      <param name="comparer">The object that compares matches to the specified <paramref name="value" /> for equality.</param>
      <returns>A parser that matches only those results from the specified <paramref name="parser" /> that equal
            the specified <paramref name="value" /> using the specified <paramref name="comparer" />.</returns>
      <requires>parser != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Group``4(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``3},Rxx.Parsers.Reactive.IObservableParser{``0,``2})">
      <summary>
            Matches the <paramref name="content" /> between the specified <paramref name="open" /> and <paramref name="close" /> parsers.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TOpen">The type of the elements that are generated from parsing the <paramref name="open" /> elements.</typeparam>
      <typeparam name="TClose">The type of the elements that are generated from parsing the <paramref name="close" /> elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the <paramref name="content" /> elements.</typeparam>
      <param name="open">The parser after which the matching of <paramref name="content" /> begins.</param>
      <param name="content">The parser that matches values between the <paramref name="open" /> and <paramref name="close" /> parsers.</param>
      <param name="close">The parser at which the matching of <paramref name="content" /> ends.</param>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by the <paramref name="content" /> parser
            and finally the <paramref name="close" /> parser, yielding the results of the <paramref name="content" /> parser only.</returns>
      <requires>open != null</requires>
      <requires>content != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Group``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``2})">
      <summary>
            Matches zero or more values in between the specified <paramref name="open" /> and <paramref name="close" /> parsers.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TOpen">The type of the elements that are generated from parsing the <paramref name="open" /> elements.</typeparam>
      <typeparam name="TClose">The type of the elements that are generated from parsing the <paramref name="close" /> elements.</typeparam>
      <param name="open">The parser after which the group begins.</param>
      <param name="close">The parser at which the group ends.</param>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by everything up to the first 
            match of the <paramref name="close" /> parser, yielding the results in between.</returns>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AmbiguousGroup``1(Rxx.Parsers.Reactive.IObservableParser{``0,``0},Rxx.Parsers.Reactive.IObservableParser{``0,``0})">
      <summary>
            Matches everything in between the specified <paramref name="open" /> and <paramref name="close" /> parsers, 
            yielding the first unambiguous match as well as everything in between any sub-groups and overlapping groups, 
            extending past the unambiguous match of the <paramref name="close" /> parser, that match the same grammar.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <param name="open">The parser after which the group begins.</param>
      <param name="close">The parser at which the group ends.</param>
      <remarks>
            The same <paramref name="open" /> or <paramref name="close" /> parser may produce multiple matches at the same index.
            </remarks>
      <returns>A parser with a grammar that matches the <paramref name="open" /> parser, followed by everything up to the first 
            match of the <paramref name="close" /> parser, yielding the results in between as well as the results of all ambiguous 
            matches of the group grammar.</returns>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Not``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> when the specified <paramref name="notParser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TNotResult">The type of the elements that are generated by the <paramref name="notParser" />.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match when the specified <paramref name="notParser" /> does not match.</param>
      <param name="notParser">The parser that when it matches will cause the matches from the specified 
            <paramref name="parser" /> to be ignored.</param>
      <returns>A parser that matches the specified <paramref name="parser" /> when the specified <paramref name="notParser" />
            does not match.</returns>
      <requires>parser != null</requires>
      <requires>notParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Or``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches either the left parser or the right parser.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that has precedence.</param>
      <param name="nextParser">The parser that is matched if the first <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields the matches from <paramref name="parser" /> if there are any; otherwise, the matches 
            from <paramref name="nextParser" /> are yielded.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Any``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{``0,``1}})">
      <summary>
            Matches the first parser that is successful.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched until one is successful.</param>
      <returns>A parser that yields the matches from the first parser in <paramref name="parsers" /> that is successful.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Any``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1}[])">
      <summary>
            Matches the first parser that is successful.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched until one is successful.</param>
      <returns>A parser that yields the matches from the first parser in <paramref name="parsers" /> that is successful.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.And``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.And``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.And``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.And``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Matches the left parser followed by the right parser and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched first.</param>
      <param name="nextParser">The parser to be matched after the first <paramref name="parser" />.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser followed by the second parser, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>nextParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AndUnordered``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the left parser and the right parser in any order and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">A parser to be matched, before or after the other parser.</param>
      <param name="otherParser">The other parser to be matched, before or after the first parser.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser and the second parser in any order, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>otherParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AndUnordered``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the left parser and the right parser in any order and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">A parser to be matched, before or after the other parser.</param>
      <param name="otherParser">The other parser to be matched, before or after the first parser.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser and the second parser in any order, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>otherParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AndUnordered``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Matches the left parser and the right parser in any order and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">A parser to be matched, before or after the other parser.</param>
      <param name="otherParser">The other parser to be matched, before or after the first parser.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser and the second parser in any order, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>otherParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AndUnordered``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}},Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Matches the left parser and the right parser in any order and yields the matches from both in a concatenated sequence, 
            or yields no matches if either the first or second parser has no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">A parser to be matched, before or after the other parser.</param>
      <param name="otherParser">The other parser to be matched, before or after the first parser.</param>
      <returns>A parser that yields a concatenated sequence of matches from the first parser and the second parser in any order, 
            or no matches if either the first or second parser has no matches.</returns>
      <requires>parser != null</requires>
      <requires>otherParser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.All``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{``0,``1}})">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.All``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1}[])">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.All``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}}})">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.All``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}}[])">
      <summary>
            Matches all <paramref name="parsers" /> in the specified order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" />, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AllUnordered``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{``0,``1}})">
      <summary>
            Matches all <paramref name="parsers" /> in any order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" /> in any order, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AllUnordered``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1}[])">
      <summary>
            Matches all <paramref name="parsers" /> in any order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" /> in any order, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AllUnordered``2(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}}})">
      <summary>
            Matches all <paramref name="parsers" /> in any order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The enumerable sequence of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" /> in any order, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AllUnordered``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}}[])">
      <summary>
            Matches all <paramref name="parsers" /> in any order and yields the results in a concatenated sequence, 
            or yields no matches if any of the parsers have no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parsers">The array of parsers to be matched.</param>
      <returns>A parser that yields a concatenated sequence of matches from all of the specified <paramref name="parsers" /> in any order, 
            or no matches if any of the parsers have no matches.</returns>
      <requires>parsers != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Parse``2(System.Func{Rxx.Parsers.Reactive.IObservableParser{``0,``0},Rxx.Parsers.Reactive.IObservableParser{``0,``1}})">
      <summary>
            Creates a parser from the specified <paramref name="grammar" /> function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="grammar">A function the accepts a parser that acts as a cursor and returns a parser that matches 
            in terms of the cursor.</param>
      <returns>A parser that yields matches from the specified <paramref name="grammar" />.</returns>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Parse``2(System.IObservable{``0},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Applies the specified <paramref name="parser" /> to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The observable sequence to parse.</param>
      <param name="parser">An object that defines a grammar to be applied to the observable sequence to generate matches.</param>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Parse``2(System.IObservable{``0},System.Func{Rxx.Parsers.Reactive.ObservableParserQueryContext{``0,``0,Rxx.Parsers.Reactive.IObservableParser{``0,``0}},Rxx.Parsers.Reactive.ObservableParserQueryContext{``0,``0,Rxx.Parsers.Reactive.IObservableParser{``0,``1}}})">
      <summary>
            Applies the specified unambiguous parser grammar to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The observable sequence to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.Parse(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor
            	let letter = next.Where(char.IsLetter)
            	let number = next.Where(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Parse``2(System.IObservable{``0},System.Func{Rxx.Parsers.Reactive.ObservableParserQueryContext{``0,``0,Rxx.Parsers.Reactive.IObservableParser{``0,``0}},Rxx.Parsers.Reactive.ObservableParserQueryContext{``0,``0,Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}}}})">
      <summary>
            Applies the specified ambiguous parser grammar to generate matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The observable sequence to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.Parse(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor
            	let letter = next.Where(char.IsLetter)
            	let number = next.Where(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.ParseString``1(System.IObservable{System.Char},System.Func{Rxx.Parsers.Reactive.StringObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Char}},Rxx.Parsers.Reactive.StringObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,``0}}})">
      <summary>
            Applies the specified unambiguous parser grammar to generate matches from a sequence of characters.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source characters.</typeparam>
      <param name="source">The observable sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseString(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let letter = parser.Character(char.IsLetter)
            	let number = parser.Character(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.ParseString``1(System.IObservable{System.Char},System.Func{Rxx.Parsers.Reactive.StringObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Char}},Rxx.Parsers.Reactive.StringObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{``0}}}})">
      <summary>
            Applies the specified ambiguous parser grammar to generate matches from a sequence of characters.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source characters.</typeparam>
      <param name="source">The sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseString(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let letter = parser.Character(char.IsLetter)
            	let number = parser.Character(char.IsNumber)
            	// define the grammar in terms of the rules
            	select from _ in number
            				 from twoInARow in letter.And(letter).Join()
            				 select twoInARow)]]></code></example>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.ParseXml``1(System.IObservable{System.Char},System.Func{Rxx.Parsers.Reactive.XmlObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Char}},Rxx.Parsers.Reactive.XmlObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,``0}}})">
      <summary>
            Applies the specified unambiguous XML parser grammar to generate matches.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source XML nodes.</typeparam>
      <param name="source">The sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseXml(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let widget = parser.Element("widget")
            	// define the grammar in terms of the rules
            	select parser.Element("products", widget.OneOrMore()))]]></code></example>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.ParseXml``1(System.IObservable{System.Char},System.Func{Rxx.Parsers.Reactive.XmlObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Char}},Rxx.Parsers.Reactive.XmlObservableParserQueryContext{System.Char,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{``0}}}})">
      <summary>
            Applies the specified ambiguous XML parser grammar to generate matches.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source XML nodes.</typeparam>
      <param name="source">The sequence of <see cref="T:System.Char" /> to parse.</param>
      <param name="grammarSelector">A function that receives an object from which a parser cursor can be obtained and returns a grammar
            defined as a LINQ <see langword="select" /> query.</param>
      <remarks>
            The recommended approach to defining an in-line query is to use query comprehension syntax, starting with a <see langword="from" /> 
            statement to bind the cursor parser to a query variable named <strong>next</strong>, followed by the definitions of zero or more 
            individual grammar rules as <see langword="let" /> statements, and finally the complete grammar as a parser query in terms of the 
            previously defined rules projected as a <see langword="select" /> statement.
            </remarks>
      <example>
            The following example illustrates the recommended approach to defining an in-line grammar.
            <code><![CDATA[source.ParseXml(parser =>
            	// get the cursor
            	from next in parser
            	// define the grammar rules in terms of the cursor or specialized parser functions
            	// that use the cursor
            	let widget = parser.Element("widget")
            	// define the grammar in terms of the rules
            	select parser.Element("products", widget.OneOrMore()))]]></code></example>
      <returns>An observable sequence of matches.</returns>
      <requires>source != null</requires>
      <requires>grammarSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Select``4(Rxx.Parsers.Reactive.ObservableParserQueryContext{``0,``1,``2},System.Func{``2,``3})">
      <summary>
            Enables defining in-line parser grammars using LINQ.
            </summary>
      <typeparam name="TParseSource">The type of the original source elements.</typeparam>
      <typeparam name="TParseResult">The type of the elements that are originally generated from parsing the source elements.</typeparam>
      <typeparam name="TSource">The type of the source elements; typically, this will be an anonymous compiler-generaed type.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The parser query context to be projected.</param>
      <param name="selector">A function that projects the current result of the query context.</param>
      <returns>A new query context that is the projection of the specified query context using the specified <paramref name="selector" />.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ObservableParserQueryContext&lt;TParseSource, TParseResult, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Select``3(Rxx.Parsers.Reactive.StringObservableParserQueryContext{``0,``1},System.Func{``1,``2})">
      <summary>
            Enables defining in-line parser grammars using LINQ.
            </summary>
      <typeparam name="TParseResult">The type of the elements that are originally generated from parsing the source elements.</typeparam>
      <typeparam name="TSource">The type of the source elements; typically, this will be an anonymous compiler-generaed type.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The parser query context to be projected.</param>
      <param name="selector">A function that projects the current result of the query context.</param>
      <returns>A new query context that is the projection of the specified query context using the specified <paramref name="selector" />.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;StringObservableParserQueryContext&lt;TParseResult, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Select``3(Rxx.Parsers.Reactive.XmlObservableParserQueryContext{``0,``1},System.Func{``1,``2})">
      <summary>
            Enables defining in-line parser grammars using LINQ.
            </summary>
      <typeparam name="TParseResult">The type of the elements that are originally generated from parsing the source elements.</typeparam>
      <typeparam name="TSource">The type of the source elements; typically, this will be an anonymous compiler-generaed type.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="source">The parser query context to be projected.</param>
      <param name="selector">A function that projects the current result of the query context.</param>
      <returns>A new query context that is the projection of the specified query context using the specified <paramref name="selector" />.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;XmlObservableParserQueryContext&lt;TParseResult, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Select``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,``2})">
      <summary>
            Projects matches from the specified <paramref name="parser" /> into a new form.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the specified <paramref name="parser" />.</typeparam>
      <param name="parser">The parser from which matches will be projected by the specified <paramref name="selector" /> function.</param>
      <param name="selector">A transform function to apply to each match.</param>
      <returns>A parser that projects matches from the specified <paramref name="parser" /> into a new form.</returns>
      <requires>parser != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectMany``4(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,Rxx.Parsers.Reactive.IObservableParser{``0,``2}},System.Func{``1,``2,``3})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into another parser, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TSecondResult">The type of the elements that are generated from the projected parsers.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the projected parsers.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified parser selector function to create 
            the next parser.</param>
      <param name="parserSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each match from the projected parsers.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into another parser, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>parserSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectMany``4(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,Rxx.Parsers.Reactive.IObservableParser{``0,``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},Rxx.Parsers.IParseResult{``2},System.Int32})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into another parser, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TSecondResult">The type of the elements that are generated from the projected parsers.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the matches of the projected parsers.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified parser selector function to create 
            the next parser.</param>
      <param name="parserSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each match from the projected parsers.</param>
      <param name="lengthSelector">A function that returns the length for each pair of projected matches.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into another parser, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>parserSelector != null</requires>
      <requires>resultSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectMany``4(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,System.IObservable{``2}},System.Func{``1,``2,``3})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into an observable sequence, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TCollection">The type of the elements in the sequences that are projected from the matches.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the projected sequences.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified collection selector function.</param>
      <param name="collectionSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each element from the projected sequences.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into an observable sequence, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>collectionSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectMany``4(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,System.IObservable{``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},``2,System.Int32})">
      <summary>
            Projects each match from the specified <paramref name="parser" /> into an observable sequence, merges all of the results
            and transforms them with the result selector function.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TFirstResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TCollection">The type of the elements in the sequences that are projected from the matches.</typeparam>
      <typeparam name="TResult">The type of the elements that are projected from the projected sequences.</typeparam>
      <param name="parser">The parser from which each match is passed to the specified collection selector function.</param>
      <param name="collectionSelector">A transform function to apply to each match from the first <paramref name="parser" />.</param>
      <param name="resultSelector">A transform function to apply to each element from the projected sequences.</param>
      <param name="lengthSelector">A function that returns the length for each pair of projected values.</param>
      <returns>A parser that projects each match from the specified <paramref name="parser" /> into an observable sequence, 
            merges all of the results and transforms them with the result selector function.</returns>
      <requires>parser != null</requires>
      <requires>collectionSelector != null</requires>
      <requires>resultSelector != null</requires>
      <requires>lengthSelector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.WithDefault``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``1)">
      <summary>
            Matches the specified <paramref name="parser" /> or yields the specified default result if there are 
            no matches.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <param name="defaultResult">The value that is yielded if the specified <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> or the specified default result
            if the <paramref name="parser" /> does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.None``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Yields success when the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which any match results in failure.</param>
      <returns>A parser that yields failure when the specified <paramref name="parser" /> matches or 
            an empty sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.None``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``2)">
      <summary>
            Yields success when the specified <paramref name="parser" /> does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TSuccess">The type of the success value.</typeparam>
      <param name="parser">The parser for which any match results in failure.</param>
      <param name="successResult">The value that is yielded if the specified <paramref name="parser" /> does not match.</param>
      <returns>A parser that yields failure when the specified <paramref name="parser" /> matches or success when 
            it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TSuccess&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Maybe``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> or yields success without a value when it does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> or
            an empty observable sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Maybe``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Matches the specified <paramref name="parser" /> or yields success without a value when it does not match.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements of the result sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that might produce matches.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> or
            an empty observable sequence to indicate success when it does not match.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Exactly``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> the specified number of times.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched.</param>
      <param name="count">The specified number of times to match the specified <paramref name="parser" />.</param>
      <returns>A parser that matches the specified <paramref name="parser" /> the specified number of times.</returns>
      <requires>parser != null</requires>
      <requires>count &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.NoneOrMore``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.NoneOrMoreNonGreedy``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively, making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.NoneOrMore``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively, 
            making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.NoneOrMore``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TSeparator">The type of the separator elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.NoneOrMoreNonGreedy``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> zero or more times consecutively, matching the specified 
            <paramref name="separator" /> in between and making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.NoneOrMore``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},Rxx.Parsers.Reactive.IObservableParser{``0,``1})" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match zero or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> zero or more times consecutively, 
            matching the specified <paramref name="separator" /> in between and making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OneOrMore``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OneOrMoreNonGreedy``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively, making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OneOrMore``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively, 
            making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OneOrMore``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TSeparator">The type of the separator elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively, 
            matching the specified <paramref name="separator" /> in between.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OneOrMoreNonGreedy``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Matches the specified <paramref name="parser" /> one or more times consecutively, matching the specified 
            <paramref name="separator" /> in between and making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OneOrMore``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},Rxx.Parsers.Reactive.IObservableParser{``0,``1})" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to match one or more times consecutively.</param>
      <param name="separator">The parser that matches between consecutive matches of the specified <paramref name="parser" />.</param>
      <returns>A parser that yields matches from the specified <paramref name="parser" /> one or more times consecutively, 
            matching the specified <paramref name="separator" /> in between and making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <requires>separator != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AtLeast``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively a minimum number of times.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively a minimum number of times.</param>
      <param name="count">The minimum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> the minimum 
            number of times specified by <paramref name="count" />.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AtLeast``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32,System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively between the specified number of times, inclusive.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively between the specified number of times.</param>
      <param name="count">The minimum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <param name="maximum">The maximum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> between the specified number of 
            times, inclusive.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <requires>maximum &gt;= count</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AtLeastNonGreedy``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively a minimum number of times, making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AtLeast``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32)" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively a minimum number of times.</param>
      <param name="count">The minimum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> the minimum 
            number of times specified by <paramref name="count" />, making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AtLeastNonGreedy``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32,System.Int32)">
      <summary>
            Matches the specified <paramref name="parser" /> consecutively between the specified number of times, inclusive, 
            making the least number of matches possible.
            This is the non-greedy variant of <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AtLeast``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Int32,System.Int32)" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser to be matched consecutively a minimum number of times.</param>
      <param name="count">The minimum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <param name="maximum">The maximum number of times to match the specified <paramref name="parser" /> consecutively.</param>
      <returns>A parser that consecutively matches the specified <paramref name="parser" /> between the specified number of 
            times, inclusive, making the least number of matches possible.</returns>
      <requires>parser != null</requires>
      <requires>count &gt; 0</requires>
      <requires>maximum &gt;= count</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OnSuccess``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Action{Rxx.Parsers.IParseResult{``1}})">
      <summary>
            Invokes the specified <paramref name="action" /> on each result for its side-effects.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser from which results will be supplied to the specified <paramref name="action" />.</param>
      <param name="action">The method that will be called for each parser result.</param>
      <returns>A new parser that is the same as the specified parser and also inovkes the specified 
            <paramref name="action" /> with each result for its side-effects.</returns>
      <requires>parser != null</requires>
      <requires>action != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.OnFailure``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Action)">
      <summary>
            Invokes the specified <paramref name="action" /> for its side-effects if the specified <paramref name="parser" />
            does not yield any results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which no results will cause the specified <paramref name="action" /> to be invoked.</param>
      <param name="action">Invoked if the <paramref name="parser" /> does not yield any results.</param>
      <returns>A new parser that is the same as the specified parser and also inovkes the specified 
            <paramref name="action" /> for its side-effects if the specified <paramref name="parser" /> does not yield
            any results.</returns>
      <requires>parser != null</requires>
      <requires>action != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Defer``2(System.Func{Rxx.Parsers.Reactive.IObservableParser{``0,``1}})">
      <summary>
            Defers creation of a parser until the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> method is called.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parserFactory">A function that returns the underlying <see cref="T:Rxx.Parsers.Reactive.IObservableParser`2" /> on which 
            the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> method will be called.</param>
      <returns>A parser that defers creation of its underlying parser until the <see cref="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" /> 
            method is called.</returns>
      <requires>parserFactory != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``2)">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding the specified scalar <paramref name="result" />.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the <paramref name="result" />.</typeparam>
      <param name="parser">The parser for which the specified <paramref name="result" /> indicates success.</param>
      <param name="result">The value of the created parser's result.</param>
      <returns>A parser that always returns the specified scalar <paramref name="result" /> with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``3(Rxx.Parsers.Reactive.IObservableParser{``0,``1},``2,System.Int32)">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding the specified scalar <paramref name="result" /> 
            with the specified length.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TIntermediate">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TResult">The type of the <paramref name="result" />.</typeparam>
      <param name="parser">The parser for which the specified <paramref name="result" /> indicates success.</param>
      <param name="result">The value of the created parser's result.</param>
      <param name="length">The length of the created parser's result.</param>
      <returns>A parser that always returns the specified scalar <paramref name="result" /> with the specified 
            length, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding a single result containing an empty sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which a single empty result sequence is returned to indicate success.</param>
      <returns>A parser that returns a single result containing an empty sequence with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})">
      <summary>
            Indicates a successful parse operation without actually parsing by yielding a single result containing an empty sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements in the sequences that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser for which a single empty result sequence is returned to indicate success.</param>
      <remarks>
        <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``2(Rxx.Parsers.Reactive.IObservableParser{``0,System.IObservable{``1}})" /> is required as an explicit overload
            because the meaning of the parser's result sequence is special and must not be compounded into a sequence of sequences, 
            which would happen if the <see cref="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Success``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})" /> overload were to be called
            instead.
            </remarks>
      <returns>A parser that returns a single result containing an empty sequence with a length 
            of zero, starting from the index at which the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.Failure``2(Rxx.Parsers.Reactive.IObservableParser{``0,``1})">
      <summary>
            Indicates a failure to parse without actually parsing by returning an empty sequence of parse results.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <param name="parser">The parser that is to fail.</param>
      <returns>A parser that always returns an empty sequence of parse results, starting from the index at which 
            the specified <paramref name="parser" /> starts.</returns>
      <requires>parser != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.IObservableCursor`1">
      <summary>
            Represents a shared observable sequence that replays values from a current index that can be moved,
            along with support for optimized branching.
            </summary>
      <remarks>
        <alert type="implementors">
            The contracts of <see cref="T:System.Reactive.IObservableCursor`1" /> rely on some of the properties being immutable.
            The <see cref="P:System.Reactive.IObservableCursor`1.IsSynchronized" /> and <see cref="P:System.Reactive.IObservableCursor`1.IsForwardOnly" /> properties must be immutable.  Furthermore, 
            the <see cref="P:System.Reactive.IObservableCursor`1.IsSequenceTerminated" /> property must be <see langword="false" /> until the sequence terminates, 
            at which time it must return <see langword="true" /> and then hold that value indefinitely.
            </alert>
      </remarks>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <threadsafety instance="false" />
    </member>
    <member name="M:System.Reactive.IObservableCursor`1.Move(System.Int32)">
      <summary>
            Changes the current index of the cursor to the element at the specified number of elements forward or backward.
            </summary>
      <param name="count">The number of elements to move after the current index if the specified count is positive
            or before the current index if the specified count is negative.</param>
      <remarks>
        <para>
            The specified <paramref name="count" /> may be a negative number only if <see cref="P:System.Reactive.IObservableCursor`1.IsForwardOnly" /> is <see langword="false" />.
            </para>
        <alert type="implementors">
            If the specified <paramref name="count" /> is greater than the length from the current element to the latest
            element in the sequence, then the cursor must virtualize itself by skipping subsequent elements until the position 
            of the cursor is reached.
            </alert>
      </remarks>
      <seealso cref="P:System.Reactive.IObservableCursor`1.IsForwardOnly" />
      <requires>!IsForwardOnly || count &gt;= 0</requires>
      <requires>IsSynchronized || !AtEndOfSequence || count &lt;= 0</requires>
      <requires>IsSynchronized || CurrentIndex + count &gt;= 0</requires>
      <requires>IsSynchronized || !IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures>IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures>IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures>IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="M:System.Reactive.IObservableCursor`1.Branch">
      <summary>
            Returns a new cursor that starts at the current position of this cursor and is tied to the lifetime of this cursor.
            </summary>
      <remarks>
        <alert type="implementors">
          <see cref="M:System.Reactive.IObservableCursor`1.Branch" /> provides a means for cursor authors to optimize branches so that they can share the same state.
            </alert>
      </remarks>
      <returns>A new cursor that starts at the current position of this cursor.</returns>
      <ensures>Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;() != null</ensures>
      <ensures>IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures>IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures>IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures>IsSynchronized || AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSynchronized == IsSynchronized</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures>IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures>IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures>IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures>IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)">
      <summary>
            Notifies the provider that an observer is to receive the specified maximum number of <strong>OnNext</strong> notifications.
            </summary>
      <remarks>
        <para>
            This overload to <see cref="M:System.IObservable`1.Subscribe(System.IObserver{`0})" /> behaves similarly except that it has a 
            <paramref name="count" /> parameter that specifies the maximum number of elements that may be pushed to the
            <paramref name="observer" />.  Essentially, it provides an optimized alternative to <see cref="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)" />.
            </para>
        <para>
            The <paramref name="count" /> parameter applies to cursors because they typically will buffer data from the source 
            sequence and replay it to subscribers, starting from the current index and continuing to the latest value that has 
            been buffered.  When a subscriber only wants to view a range of data, then <see cref="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)" /> is often 
            added to the query to specify the number of notifications that are desired; however, the <see cref="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)" /> 
            operator cannot cancel the notifications that are being replayed from the cursor, so it simply drops any additional 
            notifications that exceed the specified limit.  The specified <paramref name="observer" /> will not observe the 
            additional notifications, although the overhead of replaying an entire buffered sequence to the 
            <see cref="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)" /> operator could have a noticeable impact on the performance of your code.  By implementing
            <see cref="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" />, replayed notifications can be stopped  when the specified <paramref name="count" />
            is reached.
            </para>
      </remarks>
      <param name="observer">The object that is to receive notifications.</param>
      <param name="count">The maximum number of elements to be observed.</param>
      <returns>The observer's interface that enables resources to be disposed.</returns>
      <requires>observer != null</requires>
      <requires>count &gt;= 0</requires>
      <ensures>IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures>IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="P:System.Reactive.IObservableCursor`1.IsSynchronized">
      <summary>
            Gets a value indicating whether the cursor's methods and properties can be used concurrently by multiple threads.
            </summary>
      <remarks>
        <alert type="implementors">
          <see cref="P:System.Reactive.IObservableCursor`1.IsSynchronized" /> must be immutable.  Contracts of <see cref="T:System.Reactive.IObservableCursor`1" /> members depend upon it.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the cursor is safe for multi-threaded operations; otherwise, <see langword="false" />.</value>
    </member>
    <member name="P:System.Reactive.IObservableCursor`1.IsForwardOnly">
      <summary>
            Gets a value indicating whether the cursor only moves forward.
            </summary>
      <remarks>
        <alert type="implementors">
          <see cref="P:System.Reactive.IObservableCursor`1.IsForwardOnly" /> must be immutable.  Contracts of <see cref="T:System.Reactive.IObservableCursor`1" /> members depend upon it.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the cursor only moves forward; otherwise, <see langword="false" />.</value>
      <seealso cref="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" />
    </member>
    <member name="P:System.Reactive.IObservableCursor`1.CurrentIndex">
      <summary>
            Gets the zero-based index of the element in the sequence at which the cursor is positioned after 
            <see cref="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" /> is called.
            </summary>
      <remarks>
        <para>
          <see cref="P:System.Reactive.IObservableCursor`1.CurrentIndex" /> starts and remains at 0 until it is changed by the <see cref="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" /> method.  A value of 0 indicates
            that the cursor is positioned at the end of an empty sequence.  If the sequence generates one or more values, then 0 indicates
            that the cursor is positioned at the beginning of the sequence.  Subscribing to a cursor that has not moved replays all values in 
            the sequence, if any.
            </para>
        <para>
            The valid range of values for <see cref="P:System.Reactive.IObservableCursor`1.CurrentIndex" /> changes depending upon whether the sequence has terminated.
            If the sequence has not terminated, then <see cref="P:System.Reactive.IObservableCursor`1.CurrentIndex" /> can be any value that is greater than or equal to zero, 
            even if that value is greater than <see cref="P:System.Reactive.IObservableCursor`1.LatestIndex" />; however, once the sequence has terminated, 
            <see cref="P:System.Reactive.IObservableCursor`1.CurrentIndex" /> cannot be moved past one more than the <see cref="P:System.Reactive.IObservableCursor`1.LatestIndex" />.  This final position 
            indicates that the cursor is at the end of the sequence.  Calling <see cref="M:System.IObservable`1.Subscribe(System.IObserver{`0})" /> on a cursor that is 
            positioned at the end of the sequence causes only the termination notification to be pushed, without replaying any values.
            </para>
        <para>
            If <see cref="P:System.Reactive.IObservableCursor`1.CurrentIndex" /> is moved past the latest element in the sequence, as indicated by the value of 
            <see cref="P:System.Reactive.IObservableCursor`1.LatestIndex" />, then the existing values in the sequence will not be replayed to new subscriptions; 
            furthermore, any new values with indices that are less than <see cref="P:System.Reactive.IObservableCursor`1.CurrentIndex" /> will also be excluded from
            new subscriptions.
            </para>
        <alert type="implementors">
            If the current index is positioned ahead of the latest element in the sequence and the sequence 
            subsequently ends, then the current index must automatically be changed to <see cref="P:System.Reactive.IObservableCursor`1.LatestIndex" /> + 1 to indicate 
            that the current index is at the end of the sequence.  Consumers can check whether <see cref="P:System.Reactive.IObservableCursor`1.CurrentIndex" /> has changed 
            during the <strong>OnCompleted</strong> notification.
            </alert>
      </remarks>
      <value>The zero-based index of the element in the sequence on which the cursor is positioned after 
            <see cref="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" /> is called; otherwise, -1.</value>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures>IsSynchronized || !IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.IObservableCursor`1.LatestIndex">
      <summary>
            Gets the zero-based index of the last known element in the sequence.
            </summary>
      <value>The zero-based index of the last known element in the sequence; -1 until the sequence produces an element, if any.
            If the sequence has terminated, then the value is the index of the last element in the sequence.</value>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.IObservableCursor`1.AtEndOfSequence">
      <summary>
            Gets a value indicating whether the cursor is positioned at the end of the sequence.
            </summary>
      <remarks>
        <alert type="note">
            When <see cref="P:System.Reactive.IObservableCursor`1.AtEndOfSequence" /> returns <see langword="false" /> it does not indicate that the sequence has 
            not terminated.  It only indicates that the cursor is not currently positioned at the end of the sequence,
            regardless of whether the sequence has actually terminated or not.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the sequence has terminated and the cursor is currently positioned at the end of the sequence;
            otherwise, <see langword="false" />.</value>
      <seealso cref="P:System.Reactive.IObservableCursor`1.IsSequenceTerminated" />
      <getter>
        <ensures>!Contract.Result&lt;bool&gt;() || IsSequenceTerminated</ensures>
        <ensures>IsSynchronized || Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.IObservableCursor`1.IsSequenceTerminated">
      <summary>
            Gets a value indicating whether the sequence has terminated.
            </summary>
      <remarks>
        <alert type="note">
            When <see cref="P:System.Reactive.IObservableCursor`1.IsSequenceTerminated" /> returns <see langword="true" /> it does not indicate that the cursor is at the
            end of the sequence.  It only indicates that the sequence has terminated, regardless of whether the cursor is actually 
            positioned at the end of the sequence or not.
            </alert>
        <alert type="implementors">
          <see cref="P:System.Reactive.IObservableCursor`1.IsSequenceTerminated" /> must be immutable when it returns <see langword="true" />.  Contracts of 
            <see cref="T:System.Reactive.IObservableCursor`1" /> members depend upon it.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the sequence has terminated; otherwise, <see langword="false" />.</value>
      <seealso cref="P:System.Reactive.IObservableCursor`1.AtEndOfSequence" />
    </member>
    <member name="P:System.Reactive.IObservableCursor`1.IsDisposed">
      <summary>
            Gets a value indicating whether the cursor is disposed.
            </summary>
      <value>
        <see langword="True" /> if the cursor is disposed; otherwise, <see langword="false" />.</value>
    </member>
    <member name="T:Rxx.Parsers.Reactive.ObservableParseResult">
      <summary>
            Provides <see langword="static" /> methods for creating <see cref="T:Rxx.Parsers.ParseResult`1" /> objects.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.Concat``1(Rxx.Parsers.IParseResult{System.IObservable{``0}},Rxx.Parsers.IParseResult{``0})">
      <summary>
            Concatenates the specified parse result value sequence and scalar parse result value into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The parse result value sequence to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The scalar parse result value to be concatenated to the value of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' lengths and 
            the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>firstResult.Value != null</requires>
      <requires>secondResult != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.Concat``1(Rxx.Parsers.IParseResult{``0},Rxx.Parsers.IParseResult{System.IObservable{``0}})">
      <summary>
            Concatenates the specified scalar parse result value and parse result value sequence into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The scalar parse result value to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The parse result value sequence to be concatenated to the value of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' 
            lengths and the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>secondResult != null</requires>
      <requires>secondResult.Value != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.Concat``1(Rxx.Parsers.IParseResult{System.IObservable{``0}},Rxx.Parsers.IParseResult{System.IObservable{``0}})">
      <summary>
            Concatenates the specified parse result value sequences into a new parse result value sequence.
            The lengths are summed to indicate that the new parse result 
            encompesses both of the specified parse results and that they match consecutively
            in the input sequence.
            </summary>
      <typeparam name="TResult">The type of the new parse result's value.</typeparam>
      <param name="firstResult">The parse result value sequence to which <paramref name="secondResult" /> will be concatenated.</param>
      <param name="secondResult">The parse result value sequence to be concatenated to the value sequence of <paramref name="firstResult" />.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> object containing the sum of the specified parse results' 
            lengths and the concatenation of their values.</returns>
      <requires>firstResult != null</requires>
      <requires>firstResult.Value != null</requires>
      <requires>secondResult != null</requires>
      <requires>secondResult.Value != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.Return``1(``0,System.Int32)">
      <summary>
            Creates a singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" />  
            with the specified <paramref name="value" /> and <paramref name="length" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="value">The projection of elements of a parse operation.</param>
      <param name="length">The number of elements that were consumed in the sequence to generate 
            the specified <paramref name="value" />.</param>
      <returns>A singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" />  
            with the specified <paramref name="value" /> and <paramref name="length" />.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.SuccessMany``1(System.Int32)">
      <summary>
            Creates a new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified 
            <paramref name="length" /> and an empty sequence for the value.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the specified 
            <paramref name="length" /> and an empty sequence for the value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IObservable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.ReturnSuccess``1(System.Int32)">
      <summary>
            Creates a singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> with 
            the specified <paramref name="length" /> and the default value for the specified 
            <typeparamref name="TValue" /> type.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> with 
            the specified <paramref name="length" /> and a default value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.ReturnSuccessMany``1(System.Int32)">
      <summary>
            Creates a singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> 
            with the specified <paramref name="length" /> and an empty sequence for the value.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="length">The number of elements that were consumed in the sequence.</param>
      <returns>A singleton observable sequence containing an <see cref="T:Rxx.Parsers.IParseResult`1" /> 
            with the specified <paramref name="length" /> and an empty sequence for the value.</returns>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;IObservable&lt;TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.ReturnFailure``1">
      <summary>
            Creates an empty observable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <returns>An empty observable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.</returns>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.ReturnFailureMany``1">
      <summary>
            Creates an empty observable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <returns>An empty observable sequence of <see cref="T:Rxx.Parsers.IParseResult`1" />.</returns>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.YieldMany``1(Rxx.Parsers.IParseResult{``0})">
      <summary>
            Creates a new parse result with the length of the specified <paramref name="result" />
            and a singleton observable sequence containing the value of the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> from which to create a new parse result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the same length and value as the 
            specified <paramref name="result" />, although with the value wrapped in a singleton observable sequence.</returns>
      <requires>result != null</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IObservable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParseResult.YieldMany``1(Rxx.Parsers.IParseResult{``0},System.Int32)">
      <summary>
            Creates a new parse result with the specified <paramref name="length" /> and a singleton observable 
            sequence containing the value of the specified <paramref name="result" />.
            </summary>
      <typeparam name="TValue">The type of the parse result's value.</typeparam>
      <param name="result">The <see cref="T:Rxx.Parsers.IParseResult`1" /> from which to create a new parse result.</param>
      <param name="length">The length of the new result.</param>
      <returns>A new <see cref="T:Rxx.Parsers.IParseResult`1" /> with the same length and value as the 
            specified <paramref name="result" />, although with the value wrapped in a singleton observable sequence.</returns>
      <requires>result != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IObservable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.ObservableParserQueryContext`3">
      <summary>
            Represents a parser context over an observable sequence to support in-line grammars.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <typeparam name="TQueryValue">The type of the current value in the query context.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.Reactive.ObservableParserStart`2">
      <summary>
            Represents a parser that begins a parse operation at the beginning of the source sequence.
            </summary>
      <typeparam name="TSource">The type of the source elements.</typeparam>
      <typeparam name="TResult">The type of the elements that are generated from parsing the source elements.</typeparam>
      <invariant>grammar != null</invariant>
    </member>
    <member name="T:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2">
      <summary>
            Represents a parser context over an enumerable sequence of <see cref="T:System.Char" />
            to support in-line grammars.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
      <typeparam name="TQueryValue">The type of the current value in the query context.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Char)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_AnyCharacter" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_WhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive insignificant whitespace characters and joins
            them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.XmlObservableParser">
      <summary>
            Represents a context-free XML parser over an observable sequence of <see cref="T:System.Char" />.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser.#ctor(System.Boolean)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.Reactive.XmlObservableParser" /> class with the specified case-sensitivity.
            </summary>
      <param name="caseSensitive">Indicates whether the comparison behavior used for matching element and attribute names
            must ignore case.</param>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.Reactive.XmlObservableParser" /> class.
            </summary>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser.Schema">
      <summary>
            Gets the parser's grammar.  The default grammar matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.XmlObservableParser`1.get_Schema" inheritedFromTypeName="XmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2">
      <summary>
            Represents an XML parser context over an observable sequence of <see cref="T:System.Char" />
            to support in-line grammars.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of XML nodes.</typeparam>
      <typeparam name="TQueryValue">The type of the current value in the query context.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Attribute(System.String)">
      <summary>
            Creates a parser that matches a single XML attribute with the specified <paramref name="name" />.
            </summary>
      <param name="name">The name of the attribute to match.</param>
      <returns>A parser that matches a single XML attribute with the specified <paramref name="name" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified children.
            </summary>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified children.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified attributes and children.
            </summary>
      <remarks>
            IObservableParser is not covariant on TResult in Windows Phone because <see cref="T:System.IObservable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.
            </summary>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.
            </summary>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified children.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified children.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.
            </summary>
      <remarks>
            IObservableParser is not covariant on TResult in Windows Phone because <see cref="T:System.IObservable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, having no attributes
            and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, having no attributes 
            and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">An enumerable sequence containing the names of the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Text">
      <summary>
            Gets a parser with a grammar that matches all characters, including whitespace, up to the start tag of an element.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Text" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Comment">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;!-- and ending with --&gt;.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Comment" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.CData">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;![CDATA[ and ending with ]]&gt;.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_CData" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.AnyContent">
      <summary>
            Gets a parser with a grammar that matches any <see cref="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Text" />, <see cref="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Comment" /> or <see cref="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.CData" /> content.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyContent" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.AnyElement">
      <summary>
            Gets a parser with a grammar that matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyElement" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.AnyAttribute">
      <summary>
            Gets a parser with a grammar that matches an XML attribute.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.StringParserDefaults">
      <summary>
            Provides default values for <see cref="T:Rxx.Parsers.StringParser`1" />.
            </summary>
    </member>
    <member name="F:Rxx.Parsers.StringParserDefaults.InsignificantWhiteSpaceCharacters">
      <summary>
            The default collection of whitespace characters returned by <see cref="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpaceCharacters" />.
            The collection contains a space, tab, new-line, and carriage return.
            </summary>
    </member>
    <member name="T:Rxx.Parsers.StringParserQueryContext`2">
      <summary>
            Represents a parser context over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />
            to support in-line grammars.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of characters.</typeparam>
      <typeparam name="TQueryValue">The type of the current value in the query context.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.AnyCharacterUntil(System.Char[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop characters are parsed and joins them into a <see cref="T:System.String" />, excluding the stop character.
            </summary>
      <param name="stops">The characters at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop character is parsed
            or the sequence ends.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.AnyCharacterUntil(System.String[])">
      <summary>
            Creates a parser with a grammar that matches one or more consecutive characters until any of the specified 
            stop words are parsed and joins them into a <see cref="T:System.String" />, excluding the stop word.
            </summary>
      <param name="stopWords">The strings at which to stop consuming characters.</param>
      <returns>A parser with a grammar that consumes consecutive characters until any stop word is parsed
            or the sequence ends.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Word(System.String)">
      <summary>
            Creates a parser with a grammar that matches the specified string of characters.
            </summary>
      <param name="value">The string of characters to match.</param>
      <returns>A parser with a grammar that matches the specified string.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Character(System.Char)">
      <summary>
            Creates a parser with a grammar that matches the specified character.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> to match.</param>
      <returns>A parser with a grammar that matches the specified character.</returns>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Char)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Character(System.Func{System.Char,System.Boolean})">
      <summary>
            Creates a parser with a grammar that matches when the specified <paramref name="predicate" />
            returns <see langword="true" /> for any given character.
            </summary>
      <param name="predicate">A function that receives each character and returns whether it will be consumed.</param>
      <returns>A parser with a grammar that matches each character for which the specified 
            <paramref name="predicate" /> returns <see langword="true" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Character(System.Globalization.UnicodeCategory)">
      <summary>
            Creates a parser with a grammar that matches each character within the specified 
            <paramref name="category" />.
            </summary>
      <param name="category">The unicode character in which to match characters.</param>
      <returns>A parser with a grammar that matches each character within the specified 
            <paramref name="category" />.</returns>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParserQueryContext`2.AnyCharacter">
      <summary>
            Gets a parser with a grammar that matches any character.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_AnyCharacter" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.StringParserQueryContext`2.WhiteSpace">
      <summary>
            Gets a parser with a grammar that matches one or more consecutive whitespace characters according to the 
            rules of <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> and joins them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_WhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.StringParserQueryContext`2.InsignificantWhiteSpace">
      <summary>
            Gets a parser with a grammar that matches zero or more consecutive insignificant whitespace characters and joins
            them into a <see cref="T:System.String" />.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.XmlParser">
      <summary>
            Represents a context-free XML parser over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />.
            </summary>
    </member>
    <member name="M:Rxx.Parsers.XmlParser.#ctor(System.Boolean)">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.XmlParser" /> class with the specified case-sensitivity.
            </summary>
      <param name="caseSensitive">Indicates whether the comparison behavior used for matching element and attribute names
            must ignore case.</param>
    </member>
    <member name="M:Rxx.Parsers.XmlParser.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.Parsers.XmlParser" /> class.
            </summary>
    </member>
    <member name="P:Rxx.Parsers.XmlParser.Schema">
      <summary>
            Gets the parser's grammar.  The default grammar matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.XmlParser`1.get_Schema" inheritedFromTypeName="XmlParser">Contract.Result&lt;IParser&lt;char, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.XmlParserQueryContext`2">
      <summary>
            Represents an XML parser context over a <see cref="T:System.String" /> or an enumerable sequence of <see cref="T:System.Char" />
            to support in-line grammars.
            </summary>
      <typeparam name="TResult">The type of the elements that are generated from parsing the sequence of XML nodes.</typeparam>
      <typeparam name="TQueryValue">The type of the current value in the query context.</typeparam>
      <invariant>parser != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Attribute(System.String)">
      <summary>
            Creates a parser that matches a single XML attribute with the specified <paramref name="name" />.
            </summary>
      <param name="name">The name of the attribute to match.</param>
      <returns>A parser that matches a single XML attribute with the specified <paramref name="name" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified children.
            </summary>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified children.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element containing the specified attributes and children.
            </summary>
      <remarks>
            IParser is not covariant on TResult in Silverlight because <see cref="T:System.Collections.Generic.IEnumerable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element containing the specified attributes and children.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.
            </summary>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element having no attributes and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.
            </summary>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="attributes" /> and containing 
            the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified children.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified children.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.
            </summary>
      <remarks>
            IParser is not covariant on TResult in Silverlight because <see cref="T:System.Collections.Generic.IEnumerable`1" /> is not covariant on T.
            For this reason, the <paramref name="content" /> parameter cannot accept attributes.
            </remarks>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parsers that match the element's attributes.</param>
      <param name="content">The parsers that match the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" /> and containing 
            the specified attributes and children.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, having no attributes
            and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, having no attributes 
            and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">The parser that matches the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <summary>
            Creates a parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.
            </summary>
      <param name="name">The name of the element to match.</param>
      <param name="attributes">An enumerable sequence containing the names of the element's attributes.</param>
      <param name="content">The parser that matches the element's child elements, text, cdata and comments.</param>
      <returns>A parser that matches a single XML element with the specified <paramref name="name" />, the specified 
            <paramref name="attributes" /> and containing the specified <paramref name="content" />.</returns>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.Text">
      <summary>
            Gets a parser with a grammar that matches all characters, including whitespace, up to the start tag of an element.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Text" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.Comment">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;!-- and ending with --&gt;.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Comment" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.CData">
      <summary>
            Gets a parser with a grammar that matches content sequences beginning with &lt;![CDATA[ and ending with ]]&gt;.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_CData" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.AnyContent">
      <summary>
            Gets a parser with a grammar that matches any <see cref="P:Rxx.Parsers.XmlParserQueryContext`2.Text" />, <see cref="P:Rxx.Parsers.XmlParserQueryContext`2.Comment" /> or <see cref="P:Rxx.Parsers.XmlParserQueryContext`2.CData" /> content.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyContent" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.AnyElement">
      <summary>
            Gets a parser with a grammar that matches an XML element with any attributes or content.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyElement" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.AnyAttribute">
      <summary>
            Gets a parser with a grammar that matches an XML attribute.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Properties.Errors">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.CannotDetermineRoutedEventArgsType">
      <summary>
              Looks up a localized string similar to The argument type for the specified RoutedEvent cannot be determined from the type of its delegate..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.CannotResetCursorBranch">
      <summary>
              Looks up a localized string similar to Individual cursor branches cannot be reset.  To reset the entire cursor, call Reset on the primary cursor object instead..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.DependencyPropertyNotFound">
      <summary>
              Looks up a localized string similar to The specified DependencyProperty was not found on the specified DependencyObject..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.EventIsNotCompatibleWithEventArgs">
      <summary>
              Looks up a localized string similar to The event member's delegate has an arguments parameter that is not compatible with System.EventArgs.  Member name: {0}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.EventIsNotCompatibleWithEventHandler">
      <summary>
              Looks up a localized string similar to The event member's delegate is not compatible with System.EventHandler&lt;TEventArgs&gt;.  Member name: {0}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.EventSubscriptionIncompatibleDelegate">
      <summary>
              Looks up a localized string similar to The specified delegate type is not compatible with the delegate type of the RoutedEvent..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.EventSubscriptionIncompatibleHandler">
      <summary>
              Looks up a localized string similar to The specified handler is not a compatible delegate type, ICommand or IObserver&lt;EventPattern&lt;TEventArgs&gt;&gt; object for the specified RoutedEvent..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.EventSubscriptionIncompatibleObserver">
      <summary>
              Looks up a localized string similar to The specified observer's type argument is not compatible with the delegate type of the RoutedEvent.  Expected EventPattern&lt;TEventArgs&gt; where TEventArgs is any type that is compatible with the argument type of the RoutedEvent..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.InlineParseNotSupported">
      <summary>
              Looks up a localized string similar to An in-line query cannot be parsed while the grammar is being defined..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.InlineParserWithoutGrammar">
      <summary>
              Looks up a localized string similar to The temporary in-line parser does not have a grammar..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.InvalidFormatDirectoryPath">
      <summary>
              Looks up a localized string similar to The format of the specified directory path is invalid..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.InvalidPairDirectionValue">
      <summary>
              Looks up a localized string similar to The PairDirection value is invalid..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParseCalledWhileParsing">
      <summary>
              Looks up a localized string similar to Parse cannot be called again until the current parse operation completes..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParseExceptionMessage">
      <summary>
              Looks up a localized string similar to Syntax error in parser input sequence..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParseExceptionMessageOverrideFormat">
      <summary>
              Looks up a localized string similar to {0}{1}Source index: {2}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParseNotCalledOrFailed">
      <summary>
              Looks up a localized string similar to The operation is unavailable until after Parse has been called and it has completed successfully..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParserCannotMoveToEndBackward">
      <summary>
              Looks up a localized string similar to The parser cannot move the cursor to the end of the input sequence because the current index is ahead of the latest index..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParserNextNotReady">
      <summary>
              Looks up a localized string similar to The Next property cannot be read until after Parse is called..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.ParseSubscribeCalledWhileParsing">
      <summary>
              Looks up a localized string similar to The parser does not allow new subscriptions until the current parse operation completes..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyDoesNotSupportChangeEvents">
      <summary>
              Looks up a localized string similar to The specified property does not support change events..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyExpressionContainsIndexer">
      <summary>
              Looks up a localized string similar to The specified expression contains an indexer..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyExpressionNotUnderstood">
      <summary>
              Looks up a localized string similar to The specified expression cannot be understood as a property..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyExpressionOwnerNotUnderstood">
      <summary>
              Looks up a localized string similar to The specified expression cannot be understood as a property being read from a local variable, field, another property, or a chain of fields and properties..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyExpressionTooComplex">
      <summary>
              Looks up a localized string similar to The specified expression contains more than just fields and properties..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyExpresssionOwnerNotDetermined">
      <summary>
              Looks up a localized string similar to The owner of the specified property could not be determined..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Errors.PropertyIsReadOnly">
      <summary>
              Looks up a localized string similar to The specified property is read-only.  Property name: {0}..
            </summary>
    </member>
    <member name="T:Rxx.Properties.Text">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DefaultDisposedSubscriptionMessage">
      <summary>
              Looks up a localized string similar to Disposed subscription..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DefaultDisposingSubscriptionMessage">
      <summary>
              Looks up a localized string similar to Disposing subscription..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DefaultOnCompletedMessage">
      <summary>
              Looks up a localized string similar to Sequence completed..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DefaultSubscribedMessage">
      <summary>
              Looks up a localized string similar to Subscribed to observable..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DefaultSubscribingMessage">
      <summary>
              Looks up a localized string similar to Subscribing to observable..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DisposedSubscriptionFormat">
      <summary>
              Looks up a localized string similar to Disposed subscription: {0}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.DisposingSubscriptionFormat">
      <summary>
              Looks up a localized string similar to Disposing subscription: {0}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.FileSystemWatcherBufferChangeFormat">
      <summary>
              Looks up a localized string similar to Increasing FileSystemWatcher buffer size from {0} to {1}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.FileSystemWatcherBufferOverflowFormat">
      <summary>
              Looks up a localized string similar to FileSystemWatcher buffer overflow: {0}.
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.SubscribedFormat">
      <summary>
              Looks up a localized string similar to Subscribed to observable: {0}..
            </summary>
    </member>
    <member name="P:Rxx.Properties.Text.SubscribingFormat">
      <summary>
              Looks up a localized string similar to Subscribing to observable: {0}..
            </summary>
    </member>
    <member name="T:System.Collections.Generic.OperationalEnumerable`2">
      <summary>
            Represents an enumerable that uses its unary and binary operator overloads as query operators.
            </summary>
      <typeparam name="TIn">Input type.</typeparam>
      <typeparam name="TOut">Output type.</typeparam>
      <invariant>source != null</invariant>
      <invariant>resultSelector != null</invariant>
      <invariant>binaryOperation != null</invariant>
      <invariant>add != null</invariant>
      <invariant>subtract != null</invariant>
      <invariant>multiply != null</invariant>
      <invariant>divide != null</invariant>
      <invariant>positive != null</invariant>
      <invariant>negative != null</invariant>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Addition(System.Collections.Generic.OperationalEnumerable{`0,`1},System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that adds the values in the specified enumerables 
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first enumerable.</param>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Add(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that adds the values in this enumerable to the values in the specified enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Addition(System.Collections.Generic.OperationalEnumerable{`0,`1},`0)">
      <summary>
            Creates a new operational enumerable that adds the values in the specified enumerable to the specified value
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The enumerable.</param>
      <param name="second">A value that is added to each value in the <paramref name="first" /> enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Add(`0)">
      <summary>
            Creates a new operational enumerable that adds the values in this enumerable to the specified value.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is added to each value in this enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Subtraction(System.Collections.Generic.OperationalEnumerable{`0,`1},System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that subtracts the values in the specified enumerables 
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first enumerable.</param>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Subtract(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that subtracts the values in the specified enumerable from the values in this enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Subtraction(System.Collections.Generic.OperationalEnumerable{`0,`1},`0)">
      <summary>
            Creates a new operational enumerable that subtracts the specified value from the values in the specified enumerable
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The enumerable.</param>
      <param name="second">A value that is subtracted from each value in the <paramref name="first" /> enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Subtract(`0)">
      <summary>
            Creates a new operational enumerable that subtracts the specified value from the values in this enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is subtracted from each value in this enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Multiply(System.Collections.Generic.OperationalEnumerable{`0,`1},System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that multiplies the values in the specified enumerables 
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first enumerable.</param>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Multiply(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that multiplies the values in this enumerable by the values in the specified enumerable.
            </summary>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Multiply(System.Collections.Generic.OperationalEnumerable{`0,`1},`0)">
      <summary>
            Creates a new operational enumerable that multiplies the values in the specified enumerable by the specified value
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The enumerable.</param>
      <param name="second">A value that is multiplied against each value in the <paramref name="first" /> enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Multiply(`0)">
      <summary>
            Creates a new operational enumerable that multiplies the values in this enumerable by the specified <paramref name="value" />.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is multiplied against each value in this enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Division(System.Collections.Generic.OperationalEnumerable{`0,`1},System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that divides the values in the specified enumerables 
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first enumerable.</param>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Divide(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new operational enumerable that divides the values in this enumerable by the values in the specified enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_Division(System.Collections.Generic.OperationalEnumerable{`0,`1},`0)">
      <summary>
            Creates a new operational enumerable that divides the values in the specified enumerable by the specified value
            based on the binary operation logic of the <paramref name="first" /> enumerable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The enumerable.</param>
      <param name="second">A value that divides each value in the <paramref name="first" /> enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Divide(`0)">
      <summary>
            Creates a new operational enumerable that divides the values in this enumerable by the specified <paramref name="value" />.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that divides each value in this enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_UnaryPlus(System.Collections.Generic.OperationalEnumerable{`0,`1})">
      <summary>
            Creates a new operational enumerable that ensures the sign of the specified enumerable's values are positive.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="enumerable">The enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>enumerable != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Plus">
      <summary>
            Creates a new operational enumerable that ensures the sign of this enumerable's values are positive.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.op_UnaryNegation(System.Collections.Generic.OperationalEnumerable{`0,`1})">
      <summary>
            Creates a new operational enumerable that ensures the sign of the specified enumerable's values are negative.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="enumerable">The enumerable.</param>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <requires>enumerable != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.Negate">
      <summary>
            Creates a new operational enumerable that ensures the sign of this enumerable's values are negative.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})" />.
            </alert>
      </remarks>
      <returns>An operational enumerable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Collections.Generic.OperationalEnumerable`1">
      <summary>
            Represents an enumerable that uses its unary and binary operator overloads as query operators.
            </summary>
      <typeparam name="T">Input and output type.</typeparam>
    </member>
    <member name="T:System.ComponentModel.MemberDescriptorExtensions">
      <summary>
            Provides extension methods for <see cref="T:System.ComponentModel.PropertyDescriptor" /> and <see cref="T:System.ComponentModel.EventDescriptor" />.
            </summary>
    </member>
    <member name="M:System.ComponentModel.MemberDescriptorExtensions.PropertyChanged(System.ComponentModel.PropertyDescriptor,System.Object)">
      <summary>
            Returns an observable sequence of property changed notifications from the 
            specified <paramref name="property" /> descriptor.
            </summary>
      <param name="property">The descriptor from which to create an observable sequence of changed notifications.</param>
      <param name="source">The object to which the <paramref name="property" /> belongs.</param>
      <returns>An observable sequence of property changed notifications.</returns>
      <exception cref="T:System.ArgumentException">The specified property does not support change events.</exception>
      <requires>property != null</requires>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;PropertyChangedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Either">
      <summary>
            Provides <see langword="static" /> factory methods for creating instances of <see cref="T:System.Either`2" /> objects.
            </summary>
    </member>
    <member name="M:System.Either.Left``2(``0)">
      <summary>
            Creates a new instance of <see cref="T:System.Either`2" /> with the specified <paramref name="value" />
            and <see cref="P:System.Either`2.IsLeft" /> set to <see langword="true" />.
            </summary>
      <typeparam name="TLeft">Type of the left value.</typeparam>
      <typeparam name="TRight">Type of the right value.</typeparam>
      <param name="value">The left value.</param>
      <returns>A new instance of <see cref="T:System.Either`2" /> with the specified <paramref name="value" />
            and <see cref="P:System.Either`2.IsLeft" /> set to <see langword="true" />.</returns>
      <ensures>Contract.Result&lt;Either&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Either.Right``2(``1)">
      <summary>
            Creates a new instance of <see cref="T:System.Either`2" /> with the specified <paramref name="value" />
            and <see cref="P:System.Either`2.IsLeft" /> set to <see langword="false" />.
            </summary>
      <typeparam name="TLeft">Type of the left value.</typeparam>
      <typeparam name="TRight">Type of the right value.</typeparam>
      <param name="value">The right value.</param>
      <returns>A new instance of <see cref="T:System.Either`2" /> with the specified <paramref name="value" />
            and <see cref="P:System.Either`2.IsLeft" /> set to <see langword="false" />.</returns>
      <ensures>Contract.Result&lt;Either&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Either.LeftValue`2">
      <summary>
            Holds the value of the left side of an <see cref="T:System.Either`2" />.
            </summary>
      <typeparam name="TLeft">Type of the left side.</typeparam>
      <typeparam name="TRight">Type of the right side.</typeparam>
    </member>
    <member name="T:System.Either`2">
      <summary>
            Represents one of two possible values.
            </summary>
      <typeparam name="TLeft">Type of the left value.</typeparam>
      <typeparam name="TRight">Type of the right value.</typeparam>
    </member>
    <member name="M:System.Either`2.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Either`2" /> class for derived classes.
            </summary>
    </member>
    <member name="M:System.Either`2.Switch(System.Action{`0},System.Action{`1})">
      <summary>
            Invokes the specified <paramref name="left" /> or <paramref name="right" /> action depending upon 
            the value of <see cref="P:System.Either`2.IsLeft" />.
            </summary>
      <param name="left">The action to be invoked when <see cref="P:System.Either`2.IsLeft" /> is <see langword="true" />.</param>
      <param name="right">The action to be invoked when <see cref="P:System.Either`2.IsLeft" /> is <see langword="false" />.</param>
      <requires>left != null</requires>
      <requires>right != null</requires>
    </member>
    <member name="M:System.Either`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})">
      <summary>
            Invokes the specified <paramref name="left" /> or <paramref name="right" /> function depending upon 
            the value of <see cref="P:System.Either`2.IsLeft" />.
            </summary>
      <typeparam name="TResult">The type of the result.</typeparam>
      <param name="left">The function to be invoked when <see cref="P:System.Either`2.IsLeft" /> is <see langword="true" />.</param>
      <param name="right">The function to be invoked when <see cref="P:System.Either`2.IsLeft" /> is <see langword="false" />.</param>
      <returns>The return value of either the <paramref name="left" /> or <paramref name="right" /> function
            depending upon the value of <see cref="P:System.Either`2.IsLeft" />.</returns>
      <requires>left != null</requires>
      <requires>right != null</requires>
    </member>
    <member name="P:System.Either`2.IsLeft">
      <summary>
            Gets a value indicating whether the object holds the left value or the right value.
            </summary>
      <value>
        <see langword="true" /> if the object holds the left value; otherwise, <see langword="false" />.</value>
    </member>
    <member name="P:System.Either`2.Left">
      <summary>
            Gets the left value when <see cref="P:System.Either`2.IsLeft" /> is <see langword="true" />.
            </summary>
      <value>The left value when <see cref="P:System.Either`2.IsLeft" /> is <see langword="true" />.</value>
      <getter>
        <requires>IsLeft</requires>
      </getter>
    </member>
    <member name="P:System.Either`2.Right">
      <summary>
            Gets the right value when <see cref="P:System.Either`2.IsLeft" /> is <see langword="false" />.
            </summary>
      <value>The right value when <see cref="P:System.Either`2.IsLeft" /> is <see langword="false" />.</value>
      <getter>
        <requires>!IsLeft</requires>
      </getter>
    </member>
    <member name="M:System.Either.LeftValue`2.#ctor(`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Either.LeftValue`2" /> class.
            </summary>
      <param name="value">The left value.</param>
    </member>
    <member name="M:System.Either.LeftValue`2.Switch(System.Action{`0},System.Action{`1})">
      <summary>
            Invokes the specified <paramref name="left" /> action.
            </summary>
      <param name="left">The action to be invoked.</param>
      <param name="right">This parameter is ignored.</param>
      <requires inheritedFrom="M:System.Either`2.Switch(System.Action{`0},System.Action{`1})" inheritedFromTypeName="Either">left != null</requires>
      <requires inheritedFrom="M:System.Either`2.Switch(System.Action{`0},System.Action{`1})" inheritedFromTypeName="Either">right != null</requires>
    </member>
    <member name="M:System.Either.LeftValue`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})">
      <summary>
            Invokes the specified <paramref name="left" /> function.
            </summary>
      <typeparam name="TResult">The type of the result.</typeparam>
      <param name="left">The function to be invoked.</param>
      <param name="right">This parameter is ignored.</param>
      <returns>The return value of the <paramref name="left" /> function</returns>
      <requires inheritedFrom="M:System.Either`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})" inheritedFromTypeName="Either">left != null</requires>
      <requires inheritedFrom="M:System.Either`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})" inheritedFromTypeName="Either">right != null</requires>
    </member>
    <member name="P:System.Either.LeftValue`2.IsLeft">
      <summary>
            Gets whether the object holds the left value or the right value.
            </summary>
      <value>Always returns <see langword="true" />.</value>
    </member>
    <member name="P:System.Either.LeftValue`2.Left">
      <summary>
            Gets the left value when <see cref="P:System.Either.LeftValue`2.IsLeft" /> is <see langword="true" />.
            </summary>
      <value>Always returns the left value.</value>
      <getter>
        <requires inheritedFrom="M:System.Either`2.get_Left" inheritedFromTypeName="Either">IsLeft</requires>
      </getter>
    </member>
    <member name="P:System.Either.LeftValue`2.Right">
      <summary>
            Gets the right value when <see cref="P:System.Either.LeftValue`2.IsLeft" /> is <see langword="false" />.
            </summary>
      <value>Always throws <strong>System.Diagnostics.Contracts.ContractException</strong>.</value>
      <getter>
        <requires inheritedFrom="M:System.Either`2.get_Right" inheritedFromTypeName="Either">!IsLeft</requires>
      </getter>
    </member>
    <member name="T:System.Either.RightValue`2">
      <summary>
            Holds the value of the right side of an <see cref="T:System.Either`2" />.
            </summary>
      <typeparam name="TLeft">Type of the left side.</typeparam>
      <typeparam name="TRight">Type of the right side.</typeparam>
    </member>
    <member name="M:System.Either.RightValue`2.#ctor(`1)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Either.RightValue`2" /> class.
            </summary>
      <param name="value">The right value.</param>
    </member>
    <member name="M:System.Either.RightValue`2.Switch(System.Action{`0},System.Action{`1})">
      <summary>
            Invokes the specified <paramref name="right" /> action.
            </summary>
      <param name="left">This parameter is ignored.</param>
      <param name="right">The action to be invoked.</param>
      <requires inheritedFrom="M:System.Either`2.Switch(System.Action{`0},System.Action{`1})" inheritedFromTypeName="Either">left != null</requires>
      <requires inheritedFrom="M:System.Either`2.Switch(System.Action{`0},System.Action{`1})" inheritedFromTypeName="Either">right != null</requires>
    </member>
    <member name="M:System.Either.RightValue`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})">
      <summary>
            Invokes the specified <paramref name="right" /> function.
            </summary>
      <typeparam name="TResult">The type of the result.</typeparam>
      <param name="left">This parameter is ignored.</param>
      <param name="right">The function to be invoked.</param>
      <returns>The return value of the <paramref name="right" /> function.</returns>
      <requires inheritedFrom="M:System.Either`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})" inheritedFromTypeName="Either">left != null</requires>
      <requires inheritedFrom="M:System.Either`2.Switch``1(System.Func{`0,``0},System.Func{`1,``0})" inheritedFromTypeName="Either">right != null</requires>
    </member>
    <member name="P:System.Either.RightValue`2.IsLeft">
      <summary>
            Gets whether the object holds the left value or the right value.
            </summary>
      <value>Always returns <see langword="false" />.</value>
    </member>
    <member name="P:System.Either.RightValue`2.Left">
      <summary>
            Gets the left value when <see cref="P:System.Either.RightValue`2.IsLeft" /> is <see langword="true" />.
            </summary>
      <value>Always throws <strong>System.Diagnostics.Contracts.ContractException</strong>.</value>
      <getter>
        <requires inheritedFrom="M:System.Either`2.get_Left" inheritedFromTypeName="Either">IsLeft</requires>
      </getter>
    </member>
    <member name="P:System.Either.RightValue`2.Right">
      <summary>
            Gets the right value when <see cref="P:System.Either.RightValue`2.IsLeft" /> is <see langword="false" />.
            </summary>
      <value>Always returns the left value.</value>
      <getter>
        <requires inheritedFrom="M:System.Either`2.get_Right" inheritedFromTypeName="Either">!IsLeft</requires>
      </getter>
    </member>
    <member name="T:System.IO.StreamExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for <see cref="T:System.IO.Stream" /> objects.
            </summary>
    </member>
    <member name="M:System.IO.StreamExtensions.WriteObservable(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
      <summary>
            Writes a section of bytes asynchronously from the specified <paramref name="buffer" /> into the specified <paramref name="stream" /> 
            and advances the position within the stream by the number of bytes written.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" /> to which the <paramref name="buffer" /> is written.</param>
      <param name="buffer">The buffer to write data from.</param>
      <param name="offset">The byte offset in <paramref name="buffer" /> from which to begin writing.</param>
      <param name="count">The maximum number of bytes to write.</param>
      <returns>A scalar observable sequence that indicates when the data has been written.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanWrite</requires>
      <requires>buffer != null</requires>
      <requires>offset &gt;= 0</requires>
      <requires>count &gt;= 0</requires>
      <requires>offset + count &lt;= buffer.Length</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ReadObservable(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
      <summary>
            Reads bytes asynchronously from the specified <paramref name="stream" /> into the specified <paramref name="buffer" /> 
            and advances the position within the stream by the number of bytes read.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" /> to be read.</param>
      <param name="buffer">The buffer to read the data into.</param>
      <param name="offset">The byte offset in <paramref name="buffer" /> at which to begin writing data read from the <paramref name="stream" />.</param>
      <param name="count">The maximum number of bytes to read.</param>
      <returns>A scalar observable sequence containing the total number of bytes read into the buffer.  This can be 
            less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end
            of the stream has been reached.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanWrite</requires>
      <requires>buffer != null</requires>
      <requires>offset &gt;= 0</requires>
      <requires>count &gt;= 0</requires>
      <requires>offset + count &lt;= buffer.Length</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ReadObservable(System.IO.Stream,System.Int32)">
      <summary>
            Reads bytes asynchronously from the specified <paramref name="stream" /> and advances the position within the stream
            by the number of bytes read.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" /> to be read.</param>
      <param name="count">The maximum number of bytes to read.</param>
      <returns>A scalar observable sequence containing the byte array that is read.  The length of the array can be 
            less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end 
            of the stream has been reached.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>count &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ReadToEndObservable(System.IO.Stream)">
      <summary>
            Creates an observable sequence by asynchronously reading bytes from the current position to the end of the specified <paramref name="stream" />
            and advances the position within the stream to the end.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" /> to be read.</param>
      <returns>An observable sequence of byte arrays of a default maximum size read from the current position to the end of the 
            specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ReadToEndObservable(System.IO.Stream,System.Int32)">
      <summary>
            Creates an observable sequence by asynchronously reading bytes from the current position to the end of the specified <paramref name="stream" />
            and advances the position within the stream to the end.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" /> to be read.</param>
      <param name="bufferSize">The maximum length of each byte array that is read.</param>
      <returns>An observable sequence of byte arrays of the specified maximum size read from the current position to the end of the 
            specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>bufferSize &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ToObservable``1(System.IO.Stream,System.IObservable{``0})">
      <summary>
            Creates an observable sequence of bytes by asynchronously reading to the end of the specified <paramref name="stream" /> each time 
            the <paramref name="dataAvailable" /> sequence notifies that additional data is available to be read
            and advances the position within the stream to the end.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when data is available to be read.</typeparam>
      <param name="stream">The object from which bytes are read as data becomes available.</param>
      <param name="dataAvailable">An observable sequence that notifies when additional data is available to be read.</param>
      <remarks>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the <paramref name="dataAvailable" /> sequence notifies that additional data is available, 
            reading is expected to begin at the previous position in the stream, but if the stream is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </remarks>
      <returns>An observable sequence of byte arrays of a default maximum size read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>dataAvailable != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ToObservable``1(System.IO.Stream,System.Int32,System.IObservable{``0})">
      <summary>
            Creates an observable sequence of bytes by asynchronously reading to the end of the specified <paramref name="stream" /> each time 
            the <paramref name="dataAvailable" /> sequence notifies that additional data is available to be read
            and advances the position within the stream to the end.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when data is available to be read.</typeparam>
      <param name="stream">The object from which bytes are read as data becomes available.</param>
      <param name="bufferSize">The maximum length of each byte array that is read.</param>
      <param name="dataAvailable">An observable sequence that notifies when additional data is available to be read.</param>
      <remarks>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the <paramref name="dataAvailable" /> sequence notifies that additional data is available, 
            reading is expected to begin at the previous position in the stream, but if the stream is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </remarks>
      <returns>An observable sequence of byte arrays of the specified maximum size read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>bufferSize &gt; 0</requires>
      <requires>dataAvailable != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ToObservable``1(System.IO.Stream,System.Text.Encoding,System.IObservable{``0})">
      <summary>
            Creates an observable sequence by asynchronously reading to the end of the specified <paramref name="stream" /> each time 
            the <paramref name="textAvailable" /> sequence notifies that additional text is available to be read
            and advances the position within the stream to the end.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when text is available to be read.</typeparam>
      <param name="stream">The object from which text is read as it becomes available.</param>
      <param name="encoding">The character encoding to use.</param>
      <param name="textAvailable">An observable sequence that notifies when additional text is available to be read.</param>
      <remarks>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the <paramref name="textAvailable" /> sequence notifies that additional data is available, 
            reading is expected to begin at the previous position in the stream, but if the stream is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </remarks>
      <returns>An observable sequence of strings read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>encoding != null</requires>
      <requires>textAvailable != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ToObservable``1(System.IO.Stream,System.Text.Encoding,System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Creates an observable sequence by asynchronously reading to the end of the specified <paramref name="stream" /> each time 
            the <paramref name="textAvailable" /> sequence notifies that additional text is available to be read
            and advances the position within the stream to the end.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when text is available to be read.</typeparam>
      <param name="stream">The object from which text is read as it becomes available.</param>
      <param name="encoding">The character encoding to use.</param>
      <param name="textAvailable">An observable sequence that notifies when additional text is available to be read.</param>
      <param name="scheduler">An object used to schedule reads.</param>
      <remarks>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the <paramref name="textAvailable" /> sequence notifies that additional data is available, 
            reading is expected to begin at the previous position in the stream, but if the stream is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </remarks>
      <returns>An observable sequence of strings read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>encoding != null</requires>
      <requires>textAvailable != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ToObservableLines``1(System.IO.Stream,System.Text.Encoding,System.IObservable{``0})">
      <summary>
            Creates an observable sequence by reading lines to the end of the specified <paramref name="stream" /> each time 
            the <paramref name="textAvailable" /> sequence notifies that additional text is available to be read
            and advances the position within the stream to the end.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when text is available to be read.</typeparam>
      <param name="stream">The object from which lines are read as they become available.</param>
      <param name="encoding">The character encoding to use.</param>
      <param name="textAvailable">An observable sequence that notifies when additional text is available to be read.</param>
      <remarks>
        <para>
            The <paramref name="textAvailable" /> sequence does not have to notify when new lines are available.  It only must notify when 
            new text is available, which may or may not have new lines.  Characters that are read up to the end of the stream are automatically
            buffered until a new line sequence is encountered in a subsequent read.  A consequence of this behavior is that if the stream does
            not end with a new line sequence and it's not going to receive any more text, then the last line will not be read until 
            <paramref name="textAvailable" /> calls <strong>OnCompleted</strong>.
            </para>
        <para>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the <paramref name="textAvailable" /> sequence notifies that additional text is available, 
            reading is expected to begin at the previous position in the stream, but if the stream is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </para>
      </remarks>
      <returns>An observable sequence of lines read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>encoding != null</requires>
      <requires>textAvailable != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ToObservableLines``1(System.IO.Stream,System.Text.Encoding,System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Creates an observable sequence by reading lines to the end of the specified <paramref name="stream" /> each time 
            the <paramref name="textAvailable" /> sequence notifies that additional text is available to be read
            and advances the position within the stream to the end.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when text is available to be read.</typeparam>
      <param name="stream">The object from which lines are read as they become available.</param>
      <param name="encoding">The character encoding to use.</param>
      <param name="textAvailable">An observable sequence that notifies when additional text is available to be read.</param>
      <param name="scheduler">An object used to schedule reads.</param>
      <remarks>
        <para>
            The <paramref name="textAvailable" /> sequence does not have to notify when new lines are available.  It only must notify when 
            new text is available, which may or may not have new lines.  Characters that are read up to the end of the stream are automatically
            buffered until a new line sequence is encountered in a subsequent read.  A consequence of this behavior is that if the stream does
            not end with a new line sequence and it's not going to receive any more text, then the last line will not be read until 
            <paramref name="textAvailable" /> calls <strong>OnCompleted</strong>.
            </para>
        <para>
            The generated sequence is intended to match the specified stream; however, this behavior 
            depends on whether the stream is well-behaved and whether the stream is not being shared.  Reading always starts from the 
            current position of the stream.  The stream is expected to increment its position
            when it's read.  Each time that the <paramref name="textAvailable" /> sequence notifies that additional text is available, 
            reading is expected to begin at the previous position in the stream, but if the stream is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </para>
      </remarks>
      <returns>An observable sequence of lines read from the specified <paramref name="stream" />.</returns>
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>encoding != null</requires>
      <requires>textAvailable != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.IO.TextReaderExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for <see cref="T:System.IO.TextReader" /> objects.
            </summary>
    </member>
    <member name="M:System.IO.TextReaderExtensions.ToObservable``1(System.IO.TextReader,System.IObservable{``0})">
      <summary>
            Creates an observable sequence by reading to the end of the specified <paramref name="reader" /> each time 
            the <paramref name="textAvailable" /> sequence notifies that additional text is available to be read
            and advances the position within the reader to the end of the stream.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when text is available to be read.</typeparam>
      <param name="reader">The object from which text is read as it becomes available.</param>
      <param name="textAvailable">An observable sequence that notifies when additional text is available to be read.</param>
      <remarks>
            The generated sequence is intended to match the underlying stream; however, this behavior 
            depends on whether the reader is well-behaved and whether the reader is not being shared.  Reading always starts from the 
            current position of the reader in the underlying stream.  The reader is expected to increment its position in the stream
            when it's read.  Each time that the <paramref name="textAvailable" /> sequence notifies that additional text is available, 
            reading is expected to begin at the previous position in the stream, but if the reader is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </remarks>
      <returns>An observable sequence of strings read from the specified <paramref name="reader" />.</returns>
      <requires>reader != null</requires>
      <requires>textAvailable != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.TextReaderExtensions.ToObservable``1(System.IO.TextReader,System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Creates an observable sequence by reading to the end of the specified <paramref name="reader" /> each time 
            the <paramref name="textAvailable" /> sequence notifies that additional text is available to be read
            and advances the position within the reader to the end of the stream.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when text is available to be read.</typeparam>
      <param name="reader">The object from which text is read as it becomes available.</param>
      <param name="textAvailable">An observable sequence that notifies when additional text is available to be read.</param>
      <param name="scheduler">An object used to schedule reads.</param>
      <remarks>
            The generated sequence is intended to match the underlying stream; however, this behavior 
            depends on whether the reader is well-behaved and whether the reader is not being shared.  Reading always starts from the 
            current position of the reader in the underlying stream.  The reader is expected to increment its position in the stream
            when it's read.  Each time that the <paramref name="textAvailable" /> sequence notifies that additional text is available, 
            reading is expected to begin at the previous position in the stream, but if the reader is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </remarks>
      <returns>An observable sequence of strings read from the specified <paramref name="reader" />.</returns>
      <requires>reader != null</requires>
      <requires>textAvailable != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.TextReaderExtensions.ToObservableLines``1(System.IO.TextReader,System.IObservable{``0})">
      <summary>
            Creates an observable sequence by reading lines to the end of the specified <paramref name="reader" /> each time 
            the <paramref name="textAvailable" /> sequence notifies that additional text is available to be read
            and advances the position within the reader to the end of the stream.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when text is available to be read.</typeparam>
      <param name="reader">The object from which lines are read as they become available.</param>
      <param name="textAvailable">An observable sequence that notifies when additional text is available to be read.</param>
      <remarks>
        <para>
            The <paramref name="textAvailable" /> sequence does not have to notify when new lines are available.  It only must notify when 
            new text is available, which may or may not have new lines.  Characters that are read up to the end of the stream are automatically
            buffered until a new line sequence is encountered in a subsequent read.  A consequence of this behavior is that if the stream does
            not end with a new line sequence and it's not going to receive any more text, then the last line will not be read until 
            <paramref name="textAvailable" /> calls <strong>OnCompleted</strong>.
            </para>
        <para>
            The generated sequence is intended to match the underlying stream; however, this behavior 
            depends on whether the reader is well-behaved and whether the reader is not being shared.  Reading always starts from the 
            current position of the reader in the underlying stream.  The reader is expected to increment its position in the stream
            when it's read.  Each time that the <paramref name="textAvailable" /> sequence notifies that additional text is available, 
            reading is expected to begin at the previous position in the stream, but if the reader is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </para>
      </remarks>
      <returns>An observable sequence of lines read from the specified <paramref name="reader" />.</returns>
      <requires>reader != null</requires>
      <requires>textAvailable != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.TextReaderExtensions.ToObservableLines``1(System.IO.TextReader,System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Creates an observable sequence by reading lines to the end of the specified <paramref name="reader" /> each time 
            the <paramref name="textAvailable" /> sequence notifies that additional text is available to be read
            and advances the position within the reader to the end of the stream.
            </summary>
      <typeparam name="TOther">The type of elements in the sequence that notifies when text is available to be read.</typeparam>
      <param name="reader">The object from which lines are read as they become available.</param>
      <param name="textAvailable">An observable sequence that notifies when additional text is available to be read.</param>
      <param name="scheduler">An object used to schedule reads.</param>
      <remarks>
        <para>
            The <paramref name="textAvailable" /> sequence does not have to notify when new lines are available.  It only must notify when 
            new text is available, which may or may not have new lines.  Characters that are read up to the end of the stream are automatically
            buffered until a new line sequence is encountered in a subsequent read.  A consequence of this behavior is that if the stream does
            not end with a new line sequence and it's not going to receive any more text, then the last line will not be read until 
            <paramref name="textAvailable" /> calls <strong>OnCompleted</strong>.
            </para>
        <para>
            The generated sequence is intended to match the underlying stream; however, this behavior 
            depends on whether the reader is well-behaved and whether the reader is not being shared.  Reading always starts from the 
            current position of the reader in the underlying stream.  The reader is expected to increment its position in the stream
            when it's read.  Each time that the <paramref name="textAvailable" /> sequence notifies that additional text is available, 
            reading is expected to begin at the previous position in the stream, but if the reader is shared or it's not well-behaved, 
            then the generated sequence may contain unexpected data.
            </para>
      </remarks>
      <returns>An observable sequence of lines read from the specified <paramref name="reader" />.</returns>
      <requires>reader != null</requires>
      <requires>textAvailable != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="F:System.Linq.Cursor`1.firstElementIndex">
      <summary>
            Stores the index offset, relative to the source sequence, of the first value in the <see cref="F:System.Linq.Cursor`1.elements" /> list.
            </summary>
      <remarks>
            This field is used as part of a memory optimization in a forward-only cursor that allows elements to be removed
            when the cursor and all dependent branches have moved passed them, consequently offsetting the indexes in the 
            <see cref="F:System.Linq.Cursor`1.elements" /> list with respect to the actual source sequence.
            </remarks>
    </member>
    <member name="M:System.Linq.Cursor`1.Reset">
      <summary>
            Clears any buffered elements, branches and state, and ensures that a subsequent iteration will re-enumerate the source sequence.
            </summary>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">CurrentIndex == 0</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">LatestIndex == -1</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">!IsSequenceTerminated</ensures>
    </member>
    <member name="T:System.Linq.Enumerable2">
      <summary>
            Provides a set of <see langword="static" /> methods for query operations over enumerable sequences.
            </summary>
    </member>
    <member name="M:System.Linq.Enumerable2.ToCursor``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns a cursor for the specified enumerable sequence.
            </summary>
      <typeparam name="TSource">The type of objects to enumerate.</typeparam>
      <param name="source">The enumerable sequence that the cursor moves over.</param>
      <remarks>
            The cursor's <see cref="P:System.Linq.ICursor`1.IsForwardOnly" /> property returns <see langword="false" />, 
            indicating that it can move forward and backward.
            </remarks>
      <returns>A cursor for the specified enumerable sequence.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;ICursor&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.Enumerable2.ToCursor``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
      <summary>
            Returns a cursor for the specified enumerable sequence with the specified support for backward movement.
            </summary>
      <typeparam name="TSource">The type of objects to enumerate.</typeparam>
      <param name="source">The enumerable sequence that the cursor moves over.</param>
      <param name="forwardOnly">Specifies whether the cursor only moves forward.</param>
      <returns>A cursor for the specified enumerable sequence with the specified support for backward movement.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;ICursor&lt;TSource&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;TSource&gt;&gt;().IsForwardOnly == forwardOnly</ensures>
    </member>
    <member name="M:System.Linq.Enumerable2.Remainder``1(System.Linq.ICursor{``0},System.Int32)">
      <summary>
            Branches from the specified <paramref name="cursor" /> and moves the branch forward the specified number of elements.
            </summary>
      <typeparam name="TSource">The type of objects to enumerate.</typeparam>
      <param name="cursor">The enumerable cursor from which to branch.</param>
      <param name="skip">The number of elements that the new branch must skip.</param>
      <returns>A new branch from the specified <paramref name="cursor" /> with its current index moved ahead the specified 
            number of elements.</returns>
      <requires>cursor != null</requires>
      <requires>skip &gt;= 0</requires>
      <ensures>cursor.IsForwardOnly == Contract.OldValue(cursor.IsForwardOnly)</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;TSource&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;TSource&gt;&gt;().IsForwardOnly == cursor.IsForwardOnly</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;TSource&gt;&gt;().IsSequenceTerminated == cursor.IsSequenceTerminated</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;TSource&gt;&gt;().LatestIndex == cursor.LatestIndex</ensures>
      <ensures>Contract.Result&lt;ICursor&lt;TSource&gt;&gt;().CurrentIndex ==
				(cursor.AtEndOfSequence
				? cursor.CurrentIndex
				: cursor.IsSequenceTerminated
					? Math.Min(cursor.CurrentIndex + skip, cursor.LatestIndex + 1)
					: cursor.CurrentIndex + skip)</ensures>
    </member>
    <member name="M:System.Linq.Enumerable2.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.IObserver{``0})">
      <summary>
            Notifies the specified <paramref name="observer" /> of values, an exception and completion, for its side-effects.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values on which to notify the specified <paramref name="observer" />.</param>
      <param name="observer">An object to observe each value in the <paramref name="source" /> sequence, an exception if thrown 
            or completion if the sequence terminates successfully.</param>
      <requires>source != null</requires>
      <requires>observer != null</requires>
    </member>
    <member name="M:System.Linq.Enumerable2.Do``1(System.Collections.Generic.IEnumerable{``0},System.IObserver{``0})">
      <summary>
            Notifies the specified <paramref name="observer" /> of values, an exception and completion, for its side-effects.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values on which to notify the specified <paramref name="observer" />.</param>
      <param name="observer">An object to observe each value in the <paramref name="source" /> sequence, an exception if thrown 
            or completion if the sequence terminates successfully.</param>
      <returns>An enumerable sequence containing the same values as the <paramref name="source" /> sequence.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionExtensions">
      <summary>
            Provides extension methods for <see cref="T:System.Linq.Expressions.Expression`1" /> objects.
            </summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionExtensions.GetPropertyInfo``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>
            Gets property information for the specified <paramref name="property" /> expression.
            </summary>
      <typeparam name="TSource">Type of the parameter in the <paramref name="property" /> expression.</typeparam>
      <typeparam name="TValue">Type of the property's value.</typeparam>
      <param name="property">The expression from which to retrieve the property information.</param>
      <returns>Property information for the specified expression.</returns>
      <exception cref="T:System.ArgumentException">The expression is not understood.</exception>
      <requires>property != null</requires>
      <ensures>Contract.Result&lt;PropertyInfo&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionExtensions.GetPropertyInfo``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Object@)">
      <summary>
            Gets property information for the specified <paramref name="property" /> expression.
            </summary>
      <typeparam name="TValue">Type of the property's value.</typeparam>
      <param name="property">The expression from which to retrieve the property information.</param>
      <param name="owner">Instance of the object that defines the specified property.</param>
      <returns>Property information for the specified expression.</returns>
      <exception cref="T:System.ArgumentException">The expression is too complex or is not understood.</exception>
      <exception cref="T:System.ArgumentException">The expression does not represent a chain of one or more fields and properties, ending with a property.</exception>
      <exception cref="T:System.ArgumentException">The expression contains an indexer.</exception>
      <exception cref="T:System.ArgumentException">The owner cannot be determined from the expression.</exception>
      <requires>property != null</requires>
      <ensures>Contract.Result&lt;PropertyInfo&gt;() != null</ensures>
      <ensures>Contract.ValueAtReturn(out owner) != null</ensures>
    </member>
    <member name="T:System.Linq.OperationalEnumerable">
      <summary>
            Provides extension methods that convert an <see cref="T:System.Collections.Generic.IEnumerable`1" /> into an <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.
            </summary>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.SByte})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.SByte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.Collections.Generic.IEnumerable{System.SByte},System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.SByte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.Collections.Generic.IEnumerable{System.SByte},System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.SByte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Byte})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Collections.Generic.IEnumerable{System.Byte},System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Collections.Generic.IEnumerable{System.Byte},System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Char})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Collections.Generic.IEnumerable{System.Char},System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Collections.Generic.IEnumerable{System.Char},System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int16})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Collections.Generic.IEnumerable{System.Int16},System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Collections.Generic.IEnumerable{System.Int16},System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt16})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.Collections.Generic.IEnumerable{System.UInt16},System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.Collections.Generic.IEnumerable{System.UInt16},System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Collections.Generic.OperationalEnumerable`2" />.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int32" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int32" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt32})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt32" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt32},System.Func{System.Collections.Generic.IEnumerable{System.UInt32},System.Collections.Generic.IEnumerable{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32},System.Collections.Generic.IEnumerable{System.UInt32}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt32" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int64" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Int64},System.Func{System.Collections.Generic.IEnumerable{System.Int64},System.Collections.Generic.IEnumerable{System.Int64},System.Func{System.Int64,System.Int64,System.Int64},System.Collections.Generic.IEnumerable{System.Int64}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Int64" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt64})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt64" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.UInt64},System.Func{System.Collections.Generic.IEnumerable{System.UInt64},System.Collections.Generic.IEnumerable{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64},System.Collections.Generic.IEnumerable{System.UInt64}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.UInt64" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Single})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Single" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Single},System.Func{System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Single},System.Func{System.Single,System.Single,System.Single},System.Collections.Generic.IEnumerable{System.Single}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Single" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Double" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Double},System.Func{System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Func{System.Double,System.Double,System.Double},System.Collections.Generic.IEnumerable{System.Double}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Double" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Decimal})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Decimal" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational(System.Collections.Generic.IEnumerable{System.Decimal},System.Func{System.Collections.Generic.IEnumerable{System.Decimal},System.Collections.Generic.IEnumerable{System.Decimal},System.Func{System.Decimal,System.Decimal,System.Decimal},System.Collections.Generic.IEnumerable{System.Decimal}})">
      <summary>
            Creates a standard <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <see cref="T:System.Decimal" /><paramref name="source" />.
            </summary>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0},System.Collections.Generic.IEnumerable{``0}},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0},System.Func{``0,``0})">
      <summary>
            Creates an <see cref="T:System.Collections.Generic.OperationalEnumerable`1" /> for the specified <paramref name="source" /> from the specified operators.
            </summary>
      <typeparam name="T">The type of objects to enumerate.</typeparam>
      <param name="source">The enumerable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="add">The addition operator.</param>
      <param name="subtract">The subtraction operator.</param>
      <param name="multiply">The multiplication operator.</param>
      <param name="divide">The division operator.</param>
      <param name="positive">The plus operator.</param>
      <param name="negative">The negation operator.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`1" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperational``2(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.OperationalEnumerable{``1}},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``1},System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``1},System.Func{``0,``1})">
      <summary>
            Creates an <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> for the specified <paramref name="source" /> from the specified operators.
            </summary>
      <typeparam name="TIn">The type of input to enumerate.</typeparam>
      <typeparam name="TOut">The type of output that each operation generates.</typeparam>
      <param name="source">The enumerable to be converted.</param>
      <param name="resultSelector">Projects the result sequence into an <see cref="T:System.Collections.Generic.OperationalEnumerable`1" />.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="add">The addition operator.</param>
      <param name="subtract">The subtraction operator.</param>
      <param name="multiply">The multiplication operator.</param>
      <param name="divide">The division operator.</param>
      <param name="positive">The plus operator.</param>
      <param name="negative">The negation operator.</param>
      <returns>An <see cref="T:System.Collections.Generic.OperationalEnumerable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another enumerable.</returns>
      <requires>source != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TIn, TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Maybe">
      <summary>
            Provides methods that construct instances of <see cref="T:System.Maybe`1" />.
            </summary>
    </member>
    <member name="M:System.Maybe.Empty``1">
      <summary>
            Gets a <see cref="T:System.Maybe`1" /> that represents a missing instance of <typeparamref name="T" />.
            </summary>
      <typeparam name="T">Type of object.</typeparam>
      <returns>A <see cref="T:System.Maybe`1" /> with <see cref="P:System.Maybe`1.HasValue" /> set to <see langword="false" />.</returns>
      <ensures>!Contract.Result&lt;Maybe&lt;T&gt;&gt;().HasValue</ensures>
    </member>
    <member name="M:System.Maybe.Return``1(``0)">
      <summary>
            Creates a new instance of <see cref="T:System.Maybe`1" /> with the specified <paramref name="value" />.
            </summary>
      <typeparam name="T">Type of <paramref name="value" /></typeparam>
      <param name="value">The value assigned to the <see cref="P:System.Maybe`1.Value" /> property.</param>
      <returns>A new instance of <see cref="T:System.Maybe`1" /> with the specified <paramref name="value" /> and 
            <see cref="P:System.Maybe`1.HasValue" /> set to <see langword="true" />.</returns>
      <ensures>Contract.Result&lt;Maybe&lt;T&gt;&gt;().HasValue</ensures>
      <ensures>object.Equals(Contract.Result&lt;Maybe&lt;T&gt;&gt;().Value, value)</ensures>
    </member>
    <member name="T:System.Maybe`1">
      <summary>
            Represents an instance of an object or a missing instance of an object.
            </summary>
      <typeparam name="T">Type of object.</typeparam>
    </member>
    <member name="F:System.Maybe`1.Empty">
      <summary>
            Indicates a missing instance of <typeparamref name="T" />.
            </summary>
    </member>
    <member name="M:System.Maybe`1.#ctor(`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Maybe`1" /> struct with the specified available <paramref name="value" />.
            </summary>
      <remarks>
            Constructing a <see cref="T:System.Maybe`1" /> instance with this constructor always sets <see cref="P:System.Maybe`1.HasValue" /> to <see langword="true" />.
            </remarks>
      <param name="value">The value assigned to the <see cref="P:System.Maybe`1.Value" /> property.</param>
      <ensures>Contract.ValueAtReturn(out hasValue)</ensures>
      <ensures>object.Equals(Contract.ValueAtReturn(out this.value), value)</ensures>
    </member>
    <member name="M:System.Maybe`1.op_Equality(System.Maybe{`0},System.Maybe{`0})">
      <summary>
            Determines the equality of two <see cref="T:System.Maybe`1" /> values.
            </summary>
      <param name="first">The first value.</param>
      <param name="second">The second value.</param>
      <returns>
        <see langword="true" /> if the <paramref name="first" /> value equals the <paramref name="second" /> value; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Maybe`1.op_Inequality(System.Maybe{`0},System.Maybe{`0})">
      <summary>
            Determines the inequality of two <see cref="T:System.Maybe`1" /> values.
            </summary>
      <param name="first">The first value.</param>
      <param name="second">The second value.</param>
      <returns>
        <see langword="true" /> if the <paramref name="first" /> value does not equal the <paramref name="second" /> value; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Maybe`1.Equals(System.Object)">
      <summary>
            Determines the equality of this instance and the specified <paramref name="obj" />.
            </summary>
      <param name="obj">The object that is compared to this instance.</param>
      <returns>
        <see langword="true" /> if this instance equals the specified <paramref name="obj" />; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Maybe`1.Equals(System.Maybe{`0})">
      <summary>
            Determines the equality of this instance and the <paramref name="other" /> instance.
            </summary>
      <param name="other">The instance that is compared to this instance.</param>
      <returns>
        <see langword="true" /> if this instance equals the <paramref name="other" /> instance; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Maybe`1.GetHashCode">
      <summary>
            Gets the hash code of this instance.
            </summary>
      <returns>-1 if <see cref="P:System.Maybe`1.HasValue" /> is <see langword="false" /> and 0 if <see cref="P:System.Maybe`1.Value" /> is <see langword="null" />; otherwise, the hash code of <see cref="P:System.Maybe`1.Value" />.</returns>
    </member>
    <member name="M:System.Maybe`1.ToString">
      <summary>
            Returns the string representation of <see cref="P:System.Maybe`1.Value" />.
            </summary>
      <returns>String that represents this instance.</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:System.Maybe`1.HasValue">
      <summary>
            Gets a value indicating whether <see cref="P:System.Maybe`1.Value" /> is available.
            </summary>
      <value>
        <see langword="true" /> if <see cref="P:System.Maybe`1.Value" /> is available; otherwise, <see langword="false" />.</value>
    </member>
    <member name="P:System.Maybe`1.Value">
      <summary>
            Gets the value when <see cref="P:System.Maybe`1.HasValue" /> is <see langword="true" />.
            </summary>
      <getter>
        <requires>HasValue</requires>
      </getter>
    </member>
    <member name="T:System.Net.NetworkInformation.ObservableNetworkChange">
      <summary>
            Provides common properties for subscribing to changes in network status.
            </summary>
    </member>
    <member name="P:System.Net.NetworkInformation.ObservableNetworkChange.NetworkAvailability">
      <summary>
            Gets an observable that will notify the subscriber of current network availability and then any changes to network availability.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IObservable&lt;bool&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:System.Net.ObservableWebClient">
      <summary>
            Provides <see langword="static" /> methods for asynchronously sending data to and observing data from a resource identified by a URI.
            </summary>
    </member>
    <member name="M:System.Net.ObservableWebClient.DownloadString(System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.String" />.
            </summary>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>An observable that caches the result of the download and replays it to observers.</returns>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.OpenRead(System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.IO.Stream" />.
            </summary>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>An observable containing the readable stream that reads data from the resource.</returns>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.OpenReadWithProgress(System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.IO.Stream" /> and includes a channel for progress notifications.
            </summary>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>A paired observable that pushes progress notifications through the left channel and 
            contains the readable stream that reads data from the resource in the right channel.</returns>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;DownloadProgressChangedEventArgs, Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.OpenWrite(System.Uri,System.String)">
      <summary>
            Opens a writeable stream to the specified resource.
            </summary>
      <param name="address">The URI of the resource to receive the stream.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <returns>An observable containing the writeable stream that sends data to the resource.</returns>
      <requires>address != null</requires>
      <requires>method != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebClient.UploadString(System.Uri,System.String,System.String)">
      <summary>
            Uploads a string to the specified resource.
            </summary>
      <param name="address">The URI of the resource to receive the string.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="data">The string to send to the resource.</param>
      <returns>An observable that caches the response from the server and replays it to observers.</returns>
      <requires>address != null</requires>
      <requires>method != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Net.WebClientExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for asynchronously sending and receiving data from <see cref="T:System.Net.WebClient" /> objects.
            </summary>
    </member>
    <member name="M:System.Net.WebClientExtensions.DownloadStringObservable(System.Net.WebClient,System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.String" />.
            </summary>
      <param name="client">The object that downloads the resource.</param>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>An observable that caches the result of the download and replays it to observers.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.OpenReadObservable(System.Net.WebClient,System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.IO.Stream" />.
            </summary>
      <param name="client">The object that downloads the resource.</param>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>An observable containing the readable stream that reads data from the resource.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.OpenReadWithProgress(System.Net.WebClient,System.Uri)">
      <summary>
            Downloads the specified resource as a <see cref="T:System.IO.Stream" /> and includes a channel for progress notifications.
            </summary>
      <param name="client">The object that downloads the resource.</param>
      <param name="address">A <see cref="T:System.Uri" /> containing the URI to download.</param>
      <returns>A paired observable that pushes progress notifications through the left channel and 
            contains the readable stream that reads data from the resource in the right channel.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;DownloadProgressChangedEventArgs, Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.OpenWriteObservable(System.Net.WebClient,System.Uri,System.String)">
      <summary>
            Opens a writeable stream to the specified resource.
            </summary>
      <param name="client">The object that uploads to the resource.</param>
      <param name="address">The URI of the resource to receive the stream.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <returns>An observable containing the writeable stream that sends data to the resource.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <requires>method != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.WebClientExtensions.UploadStringObservable(System.Net.WebClient,System.Uri,System.String,System.String)">
      <summary>
            Uploads a string to the specified resource.
            </summary>
      <param name="client">The object that uploads to the resource.</param>
      <param name="address">The URI of the resource to receive the string.</param>
      <param name="method">The HTTP method used to send data to the resource.  If <see langword="null" />, the default is POST for HTTP and STOR for FTP.</param>
      <param name="data">The string to send to the resource.</param>
      <returns>An observable that caches the response from the server and replays it to observers.</returns>
      <requires>client != null</requires>
      <requires>address != null</requires>
      <requires>method != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;string&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Net.ObservableWebRequest">
      <summary>
            Provides <see langword="static" /> extension methods that return observable sequences for various asynchronous methods defined 
            by the <see cref="T:System.Net.WebRequest" /> and <see cref="T:System.Net.HttpWebRequest" /> classes.
            </summary>
    </member>
    <member name="M:System.Net.ObservableWebRequest.GetRequestStreamObservable(System.Net.WebRequest)">
      <summary>
            Creates a <see cref="T:System.IO.Stream" /> for writing data to the Internet resource.
            </summary>
      <param name="request">The <see cref="T:System.Net.WebRequest" /> that provides the writable stream.</param>
      <returns>A singleton observable containing the writable <see cref="T:System.IO.Stream" />.</returns>
      <requires>request != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Stream&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebRequest.GetResponseObservable(System.Net.WebRequest)">
      <summary>
            Returns a response to an Internet request.
            </summary>
      <param name="request">The <see cref="T:System.Net.WebRequest" /> that creates the response.</param>
      <returns>A singleton observable containing the response.</returns>
      <requires>request != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;WebResponse&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Net.ObservableWebRequest.GetResponseObservable(System.Net.HttpWebRequest)">
      <summary>
            Returns a response to an Internet request.
            </summary>
      <param name="request">The <see cref="T:System.Net.HttpWebRequest" /> that creates the response.</param>
      <returns>A singleton observable containing the response.</returns>
      <requires>request != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;HttpWebResponse&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.IPairedObservable`2">
      <summary>
            Represents an observable with two notification channels for values.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
    </member>
    <member name="M:System.Reactive.IPairedObservable`2.Subscribe(System.Reactive.IPairedObserver{`0,`1})">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <param name="observer">The object that is to receive notifications.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>observer != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.AnonymousPairedObservable`2.#ctor(System.IObservable{System.Either{`0,`1}})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.AnonymousPairedObservable`2" /> class.
            </summary>
      <param name="observable">The observable that receives subscriptions.</param>
      <requires>observable != null</requires>
    </member>
    <member name="T:System.Reactive.IPairedObserver`2">
      <summary>
            Provides a mechanism for receiving push-based notifications from an <see cref="T:System.Reactive.IPairedObservable`2" />.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
    </member>
    <member name="M:System.Reactive.IPairedObserver`2.OnNextLeft(`0)">
      <summary>
            Notifies left observers of a new value in the sequence.
            </summary>
      <param name="left">The current left notification information.</param>
    </member>
    <member name="M:System.Reactive.IPairedObserver`2.OnNextRight(`1)">
      <summary>
            Notifies right observers of a new value in the sequence.
            </summary>
      <param name="right">The current right notification information.</param>
    </member>
    <member name="M:System.Reactive.AnonymousPairedObserver`2.#ctor(System.IObserver{System.Either{`0,`1}})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.AnonymousPairedObserver`2" /> class.
            </summary>
      <param name="observer">The observer that receives notifications.</param>
      <requires>observer != null</requires>
    </member>
    <member name="T:System.Reactive.CollectionModification">
      <summary>
            Provides <see langword="static" /> factory methods for creating <see cref="T:System.Reactive.CollectionModification`1" /> objects.
            </summary>
    </member>
    <member name="M:System.Reactive.CollectionModification.CreateAdd``1(``0)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionModification`1" /> object that is an <see cref="F:System.Reactive.CollectionModificationKind.Add" /> 
            modification for the specified <paramref name="value" />.
            </summary>
      <typeparam name="T">The object that provides modification information.</typeparam>
      <param name="value">The item to be added.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionModification`1" /> object that is an <see cref="F:System.Reactive.CollectionModificationKind.Add" /> 
            modification for the specified <paramref name="value" />.</returns>
      <ensures>Contract.Result&lt;CollectionModification&lt;T&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionModification&lt;T&gt;&gt;().Kind == CollectionModificationKind.Add</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification.CreateRemove``1(``0)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionModification`1" /> object that is a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> 
            modification for the specified <paramref name="value" />.
            </summary>
      <typeparam name="T">The object that provides modification information.</typeparam>
      <param name="value">The item to be removed.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionModification`1" /> object that is a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> 
            modification for the specified <paramref name="value" />.</returns>
      <ensures>Contract.Result&lt;CollectionModification&lt;T&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionModification&lt;T&gt;&gt;().Kind == CollectionModificationKind.Remove</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification.CreateClear``1">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionModification`1" /> object that is a <see cref="F:System.Reactive.CollectionModificationKind.Clear" /> 
            modification.
            </summary>
      <typeparam name="T">The object that provides modification information.</typeparam>
      <returns>A new <see cref="T:System.Reactive.CollectionModification`1" /> object that is a <see cref="F:System.Reactive.CollectionModificationKind.Clear" /> 
            modification.</returns>
      <ensures>Contract.Result&lt;CollectionModification&lt;T&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionModification&lt;T&gt;&gt;().Kind == CollectionModificationKind.Clear</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification.CreateDictionaryAdd``2(``0,``1)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionModification`1" /> object that is an <see cref="F:System.Reactive.CollectionModificationKind.Add" /> 
            modification for the specified <paramref name="key" /> and <paramref name="value" /> pair.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="key">The key of the item to be added.</param>
      <param name="value">The item to be added.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionModification`1" /> object that is an <see cref="F:System.Reactive.CollectionModificationKind.Add" /> 
            modification for the specified <paramref name="key" /> and <paramref name="value" />.</returns>
      <ensures>Contract.Result&lt;CollectionModification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionModification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;().Kind == CollectionModificationKind.Add</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification.CreateDictionaryRemove``2(``0)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionModification`1" /> object that is a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> 
            modification for the specified <paramref name="key" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="key">The key of the item to be removed.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionModification`1" /> object that is a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> 
            modification for the specified <paramref name="key" />.</returns>
      <ensures>Contract.Result&lt;CollectionModification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionModification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;().Kind == CollectionModificationKind.Remove</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification.CreateDictionaryClear``2">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionModification`1" /> object that is a <see cref="F:System.Reactive.CollectionModificationKind.Clear" /> 
            modification.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <returns>A new <see cref="T:System.Reactive.CollectionModification`1" /> object that is a <see cref="F:System.Reactive.CollectionModificationKind.Clear" /> 
            modification.</returns>
      <ensures>Contract.Result&lt;CollectionModification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionModification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;().Kind == CollectionModificationKind.Clear</ensures>
    </member>
    <member name="T:System.Reactive.CollectionModificationExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for <see cref="T:System.Reactive.CollectionModification`1" /> objects.
            </summary>
    </member>
    <member name="M:System.Reactive.CollectionModificationExtensions.ToNotification``1(System.Reactive.CollectionModification{``0})">
      <summary>
            Converts a <see cref="T:System.Reactive.CollectionModification`1" /> to a <see cref="T:System.Reactive.CollectionNotification`1" />.
            </summary>
      <typeparam name="T">The object that provides modification information.</typeparam>
      <param name="modification">The <see cref="T:System.Reactive.CollectionModification`1" /> to be converted.</param>
      <returns>A <see cref="T:System.Reactive.CollectionNotification`1" /> of <see cref="F:System.Reactive.CollectionNotificationKind.OnAdded" /> when the specified <paramref name="modification" />
            is <see cref="F:System.Reactive.CollectionModificationKind.Add" />, a <see cref="T:System.Reactive.CollectionNotification`1" /> of <see cref="F:System.Reactive.CollectionNotificationKind.OnRemoved" /> when the 
            specified <paramref name="modification" /> is <see cref="F:System.Reactive.CollectionModificationKind.Remove" />, or a <see cref="T:System.Reactive.CollectionNotification`1" /> of 
            <see cref="F:System.Reactive.CollectionNotificationKind.OnCleared" /> when the specified <paramref name="modification" /> is <see cref="F:System.Reactive.CollectionModificationKind.Clear" />.</returns>
      <requires>modification != null</requires>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.CollectionModificationKind">
      <summary>
            Indicates the type of a collection modification.
            </summary>
    </member>
    <member name="F:System.Reactive.CollectionModificationKind.Add">
      <summary>
            Indicates that an item is to be added to the collection.
            </summary>
    </member>
    <member name="F:System.Reactive.CollectionModificationKind.Remove">
      <summary>
            Indicates that an item is to be removed from the collection.
            </summary>
    </member>
    <member name="F:System.Reactive.CollectionModificationKind.Clear">
      <summary>
            Indicates that all items are to be removed from the collection.
            </summary>
    </member>
    <member name="T:System.Reactive.CollectionModification`1">
      <summary>
            Represents a modifying notification to a collection.
            </summary>
      <typeparam name="T">The object that provides modification information.</typeparam>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionModification`1" /> class for derived classes.
            </summary>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Accept(System.Collections.Generic.ICollection{`0})">
      <summary>
            Invokes the collection's method corresponding to the modification.
            </summary>
      <param name="collection">Collection on which to invoke the modification.</param>
      <requires>collection != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)">
      <summary>
            Invokes the delegate corresponding to the modification.
            </summary>
      <param name="add">Delegate to invoke for an <see cref="T:System.Reactive.CollectionModification`1.Add" /> modification.</param>
      <param name="remove">Delegate to invoke for a <see cref="T:System.Reactive.CollectionModification`1.Remove" /> modification.</param>
      <param name="clear">Delegate to invoke for a <see cref="T:System.Reactive.CollectionModification`1.Clear" /> modification.</param>
      <requires>add != null</requires>
      <requires>remove != null</requires>
      <requires>clear != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <summary>
            Invokes the delegate corresponding to the modification and returns the produced result.
            </summary>
      <typeparam name="TResult">Type of the produced result.</typeparam>
      <param name="add">Delegate to invoke for an <see cref="T:System.Reactive.CollectionModification`1.Add" /> modification.</param>
      <param name="remove">Delegate to invoke for a <see cref="T:System.Reactive.CollectionModification`1.Remove" /> modification.</param>
      <param name="clear">Delegate to invoke for a <see cref="T:System.Reactive.CollectionModification`1.Clear" /> modification.</param>
      <returns>Result produced by the observation.</returns>
      <requires>add != null</requires>
      <requires>remove != null</requires>
      <requires>clear != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.GetHashCode">
      <summary>
            Generates a hash code that is suitable for use when keying a dictionary.
            </summary>
      <returns>A hash code for the modification.</returns>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Equals(System.Reactive.CollectionModification{`0})">
      <summary>
            Compares the specified modification for <see cref="P:System.Reactive.CollectionModification`1.Kind" /> and <see cref="P:System.Reactive.CollectionModification`1.Value" /> equality.
            </summary>
      <param name="other">The other modification to compare.</param>
      <returns>
        <see langword="True" /> if the <see cref="P:System.Reactive.CollectionModification`1.Kind" /> and <see cref="P:System.Reactive.CollectionModification`1.Value" /> of each modification are equal;
            otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Equals(System.Object)">
      <summary>
            Compares the specified modification for <see cref="P:System.Reactive.CollectionModification`1.Kind" /> and <see cref="P:System.Reactive.CollectionModification`1.Value" /> equality.
            </summary>
      <param name="obj">The other modification to compare.</param>
      <returns>
        <see langword="True" /> if the specified object is an instance of <see cref="T:System.Reactive.CollectionModification`1" /> and if
            the <see cref="P:System.Reactive.CollectionModification`1.Kind" /> and <see cref="P:System.Reactive.CollectionModification`1.Value" /> of each modification are equal; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.op_Equality(System.Reactive.CollectionModification{`0},System.Reactive.CollectionModification{`0})">
      <summary>
            Compares the specified modifications for <see cref="P:System.Reactive.CollectionModification`1.Kind" /> and <see cref="P:System.Reactive.CollectionModification`1.Value" /> equality.
            </summary>
      <param name="first">The first modification.</param>
      <param name="second">The second modification.</param>
      <returns>
        <see langword="True" /> if the <see cref="P:System.Reactive.CollectionModification`1.Kind" /> and <see cref="P:System.Reactive.CollectionModification`1.Value" /> of each modification are equal;
            otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.op_Inequality(System.Reactive.CollectionModification{`0},System.Reactive.CollectionModification{`0})">
      <summary>
            Compares the specified modifications for <see cref="P:System.Reactive.CollectionModification`1.Kind" /> and <see cref="P:System.Reactive.CollectionModification`1.Value" /> inequality.
            </summary>
      <param name="first">The first modification.</param>
      <param name="second">The second modification.</param>
      <returns>
        <see langword="False" /> if the <see cref="P:System.Reactive.CollectionModification`1.Kind" /> and <see cref="P:System.Reactive.CollectionModification`1.Value" /> of each modification are equal;
            otherwise, <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Kind">
      <summary>
            Gets the kind of modification that is represented.
            </summary>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.HasValue">
      <summary>
            Gets a value indicating whether the modification has a value.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == (Kind != CollectionModificationKind.Clear)</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Value">
      <summary>
            Gets the value of an <see cref="F:System.Reactive.CollectionModificationKind.Add" /> or <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> 
            modification; otherwise, throws an exception.
            </summary>
      <getter>
        <requires>HasValue</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Add.#ctor(`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionModification`1.Add" /> class.
            </summary>
      <param name="value">The item to be added.</param>
      <ensures>Kind == CollectionModificationKind.Add</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Clear.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionModification`1.Clear" /> class.
            </summary>
      <ensures>Kind == CollectionModificationKind.Clear</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Remove.#ctor(`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionModification`1.Remove" /> class.
            </summary>
      <param name="value">The item to be removed.</param>
      <ensures>Kind == CollectionModificationKind.Remove</ensures>
    </member>
    <member name="T:System.Reactive.CollectionNotification">
      <summary>
            Provides <see langword="static" /> factory methods for creating <see cref="T:System.Reactive.CollectionNotification`1" /> objects.
            </summary>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateExists``1(``0)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.Exists" /> 
            notification for the specified <paramref name="value" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="value">The item that exists.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.Exists" /> 
            notification for the specified <paramref name="value" />.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;().Kind == CollectionNotificationKind.Exists</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateOnAdded``1(``0)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnAdded" /> 
            notification for the specified <paramref name="value" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="value">The item being added.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnAdded" /> 
            notification for the specified <paramref name="value" />.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;().Kind == CollectionNotificationKind.OnAdded</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateOnReplaced``1(``0,``0)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnReplaced" /> 
            notification for the specified values.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="oldValue">The item being replaced.</param>
      <param name="newValue">The item replacing the old item.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnReplaced" /> 
            notification for the specified values.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;().Kind == CollectionNotificationKind.OnReplaced</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateOnRemoved``1(``0)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnRemoved" /> 
            notification for the specified <paramref name="value" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="value">The item being removed.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnRemoved" /> 
            notification for the specified <paramref name="value" />.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;().Kind == CollectionNotificationKind.OnRemoved</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateOnCleared``1">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnCleared" /> 
            notification.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnCleared" /> 
            notification.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;T&gt;&gt;().Kind == CollectionNotificationKind.OnCleared</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateDictionaryExists``2(``0,``1)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.Exists" /> 
            notification for the specified <paramref name="key" /> and <paramref name="value" /> pair.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="key">The key of the existing item.</param>
      <param name="value">The item that exists.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.Exists" /> 
            notification for the specified <paramref name="key" /> and <paramref name="value" />.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;().Kind == CollectionNotificationKind.Exists</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateDictionaryOnAdded``2(``0,``1)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnAdded" /> 
            notification for the specified <paramref name="key" /> and <paramref name="value" /> pair.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="key">The key of the item being added.</param>
      <param name="value">The item being added.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnAdded" /> 
            notification for the specified <paramref name="key" /> and <paramref name="value" />.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;().Kind == CollectionNotificationKind.OnAdded</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateDictionaryOnReplaced``2(``0,``1,``1)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnReplaced" /> 
            notification for the specified <paramref name="key" /> and value pair.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="key">The key of the item being replaced.</param>
      <param name="oldValue">The item being replaced.</param>
      <param name="newValue">The item replacing the old item.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnReplaced" /> 
            notification for the specified <paramref name="key" /> and value.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;().Kind == CollectionNotificationKind.OnReplaced</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateDictionaryOnRemoved``2(``0)">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnRemoved" /> 
            notification for the specified <paramref name="key" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="key">The key of the item being removed.</param>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnRemoved" /> 
            notification for the specified <paramref name="key" />.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;().Kind == CollectionNotificationKind.OnRemoved</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification.CreateDictionaryOnCleared``2">
      <summary>
            Returns a new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnCleared" /> 
            notification.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <returns>A new <see cref="T:System.Reactive.CollectionNotification`1" /> object that is an <see cref="F:System.Reactive.CollectionNotificationKind.OnCleared" /> 
            notification.</returns>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;().Kind == CollectionNotificationKind.OnCleared</ensures>
    </member>
    <member name="T:System.Reactive.CollectionNotificationExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for <see cref="T:System.Reactive.CollectionNotification`1" /> objects.
            </summary>
    </member>
    <member name="M:System.Reactive.CollectionNotificationExtensions.ToModification``1(System.Reactive.CollectionNotification{``0})">
      <summary>
            Converts a <see cref="T:System.Reactive.CollectionNotification`1" /> to a <see cref="T:System.Reactive.CollectionModification`1" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="notification">The <see cref="T:System.Reactive.CollectionNotification`1" /> to be converted.</param>
      <returns>A <see cref="T:System.Reactive.CollectionModification`1" /> of <see cref="F:System.Reactive.CollectionModificationKind.Add" /> when the specified <paramref name="notification" />
            is <see cref="F:System.Reactive.CollectionNotificationKind.Exists" />, <see cref="F:System.Reactive.CollectionNotificationKind.OnAdded" /> or <see cref="F:System.Reactive.CollectionNotificationKind.OnReplaced" />, 
            a <see cref="T:System.Reactive.CollectionModification`1" /> of <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> when the specified <paramref name="notification" />
            is <see cref="F:System.Reactive.CollectionNotificationKind.OnRemoved" />, or a <see cref="T:System.Reactive.CollectionModification`1" /> of <see cref="F:System.Reactive.CollectionModificationKind.Clear" />
            when the specified <paramref name="notification" /> is <see cref="F:System.Reactive.CollectionNotificationKind.OnCleared" />.</returns>
      <requires>notification != null</requires>
      <ensures>Contract.Result&lt;CollectionModification&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.CollectionNotificationKind">
      <summary>
            Indicates the type of a collection notification.
            </summary>
    </member>
    <member name="F:System.Reactive.CollectionNotificationKind.Exists">
      <summary>
            Indicates that an item exists in the collection.
            </summary>
    </member>
    <member name="F:System.Reactive.CollectionNotificationKind.OnAdded">
      <summary>
            Indicates that an item was added to the collection.
            </summary>
    </member>
    <member name="F:System.Reactive.CollectionNotificationKind.OnReplaced">
      <summary>
            Indicates that an item was replaced in the collection.
            </summary>
    </member>
    <member name="F:System.Reactive.CollectionNotificationKind.OnRemoved">
      <summary>
            Indicates that an item was removed from the collection.
            </summary>
    </member>
    <member name="F:System.Reactive.CollectionNotificationKind.OnCleared">
      <summary>
            Indicates that all items were removed from the collection.
            </summary>
    </member>
    <member name="T:System.Reactive.CollectionNotification`1">
      <summary>
            Represents a collection-modifying notification to an observer.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionNotification`1" /> class for derived classes.
            </summary>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)">
      <summary>
            Invokes the delegate corresponding to the notification.
            </summary>
      <param name="exists">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.Exists" /> notification.</param>
      <param name="onAdded">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.OnAdded" /> notification.</param>
      <param name="onReplaced">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.OnReplaced" /> notification.</param>
      <param name="onRemoved">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.OnRemoved" /> notification.</param>
      <param name="onCleared">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.OnCleared" /> notification.</param>
      <requires>exists != null</requires>
      <requires>onAdded != null</requires>
      <requires>onReplaced != null</requires>
      <requires>onRemoved != null</requires>
      <requires>onCleared != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <summary>
            Invokes the delegate corresponding to the notification and returns the produced result.
            </summary>
      <typeparam name="TResult">Type of the produced result.</typeparam>
      <param name="exists">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.Exists" /> notification.</param>
      <param name="onAdded">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.OnAdded" /> notification.</param>
      <param name="onReplaced">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.OnReplaced" /> notification.</param>
      <param name="onRemoved">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.OnRemoved" /> notification.</param>
      <param name="onCleared">Delegate to invoke for an <see cref="T:System.Reactive.CollectionNotification`1.OnCleared" /> notification.</param>
      <returns>Result produced by the observation.</returns>
      <requires>exists != null</requires>
      <requires>onAdded != null</requires>
      <requires>onReplaced != null</requires>
      <requires>onRemoved != null</requires>
      <requires>onCleared != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.GetHashCode">
      <summary>
            Generates a hash code that is suitable for use when keying a dictionary.
            </summary>
      <returns>A hash code for the notification.</returns>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.Equals(System.Reactive.CollectionNotification{`0})">
      <summary>
            Compares the specified notification for <see cref="P:System.Reactive.CollectionNotification`1.Kind" /> and <see cref="P:System.Reactive.CollectionNotification`1.Value" /> equality.
            </summary>
      <param name="other">The other notification to compare.</param>
      <returns>
        <see langword="True" /> if the <see cref="P:System.Reactive.CollectionNotification`1.Kind" /> and <see cref="P:System.Reactive.CollectionNotification`1.Value" /> of each notification are equal;
            otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.Equals(System.Object)">
      <summary>
            Compares the specified notification for <see cref="P:System.Reactive.CollectionNotification`1.Kind" /> and <see cref="P:System.Reactive.CollectionNotification`1.Value" /> equality.
            </summary>
      <param name="obj">The other notification to compare.</param>
      <returns>
        <see langword="True" /> if the specified object is an instance of <see cref="T:System.Reactive.CollectionNotification`1" /> and if
            the <see cref="P:System.Reactive.CollectionNotification`1.Kind" /> and <see cref="P:System.Reactive.CollectionNotification`1.Value" /> of each notification are equal; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.op_Equality(System.Reactive.CollectionNotification{`0},System.Reactive.CollectionNotification{`0})">
      <summary>
            Compares the specified notifications for <see cref="P:System.Reactive.CollectionNotification`1.Kind" /> and <see cref="P:System.Reactive.CollectionNotification`1.Value" /> equality.
            </summary>
      <param name="first">The first notification.</param>
      <param name="second">The second notification.</param>
      <returns>
        <see langword="True" /> if the <see cref="P:System.Reactive.CollectionNotification`1.Kind" /> and <see cref="P:System.Reactive.CollectionNotification`1.Value" /> of each notification are equal;
            otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.op_Inequality(System.Reactive.CollectionNotification{`0},System.Reactive.CollectionNotification{`0})">
      <summary>
            Compares the specified notifications for <see cref="P:System.Reactive.CollectionNotification`1.Kind" /> and <see cref="P:System.Reactive.CollectionNotification`1.Value" /> inequality.
            </summary>
      <param name="first">The first notification.</param>
      <param name="second">The second notification.</param>
      <returns>
        <see langword="False" /> if the <see cref="P:System.Reactive.CollectionNotification`1.Kind" /> and <see cref="P:System.Reactive.CollectionNotification`1.Value" /> of each notification are equal;
            otherwise, <see langword="true" />.</returns>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.Kind">
      <summary>
            Gets the kind of notification that is represented.
            </summary>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.HasValue">
      <summary>
            Gets a value indicating whether the notification has a <see cref="P:System.Reactive.CollectionNotification`1.Value" />.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == (Kind != CollectionNotificationKind.OnCleared)</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.Value">
      <summary>
            Gets the value of an <see cref="F:System.Reactive.CollectionNotificationKind.OnAdded" />, <see cref="F:System.Reactive.CollectionNotificationKind.OnReplaced" />, 
            <see cref="F:System.Reactive.CollectionNotificationKind.OnRemoved" /> or <see cref="F:System.Reactive.CollectionNotificationKind.Exists" /> notification;
            otherwise, throws an exception.
            </summary>
      <getter>
        <requires>HasValue</requires>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.ReplacedValue">
      <summary>
            Gets the replaced value of an <see cref="F:System.Reactive.CollectionNotificationKind.OnReplaced" /> notification; otherwise, throws an exception.
            </summary>
      <getter>
        <requires>Kind == CollectionNotificationKind.OnReplaced</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.Exists.#ctor(`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionNotification`1.Exists" /> class.
            </summary>
      <param name="value">The item that exists.</param>
      <ensures>Kind == CollectionNotificationKind.Exists</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnAdded.#ctor(`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionNotification`1.OnAdded" /> class.
            </summary>
      <param name="value">The item being added.</param>
      <ensures>Kind == CollectionNotificationKind.OnAdded</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnCleared.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionNotification`1.OnCleared" /> class.
            </summary>
      <ensures>Kind == CollectionNotificationKind.OnCleared</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnRemoved.#ctor(`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionNotification`1.OnRemoved" /> class.
            </summary>
      <param name="value">The item being removed.</param>
      <ensures>Kind == CollectionNotificationKind.OnRemoved</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnReplaced.#ctor(`0,`0)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.CollectionNotification`1.OnReplaced" /> class.
            </summary>
      <param name="oldValue">The item being replaced.</param>
      <param name="newValue">The item replacing the current item.</param>
      <ensures>Kind == CollectionNotificationKind.OnReplaced</ensures>
    </member>
    <member name="T:System.Reactive.Disposables.SerialDisposableExtensions">
      <summary>
            Provides extension methods for <see cref="T:System.Reactive.Disposables.SerialDisposable" />.
            </summary>
    </member>
    <member name="M:System.Reactive.Disposables.SerialDisposableExtensions.SetDisposableIndirectly(System.Reactive.Disposables.SerialDisposable,System.Func{System.IDisposable})">
      <summary>
            Uses the double-indirection pattern to assign the disposable returned by the specified <paramref name="factory" />
            to the <see cref="P:System.Reactive.Disposables.SerialDisposable.Disposable" /> property of the specified <paramref name="disposable" />.
            </summary>
      <remarks>
            The double-indirection pattern avoids a race condition that can occur when the <paramref name="factory" /> 
            has a side-effect that causes the <see cref="P:System.Reactive.Disposables.SerialDisposable.Disposable" /> property of the specified 
            <paramref name="disposable" /> to be assigned before the <paramref name="factory" /> returns its disposable.
            This pattern ensures that the disposable returned by the <paramref name="factory" /> does not replace the 
            disposable that was assigned by the <paramref name="factory" />.
            </remarks>
      <param name="disposable">The object to which the disposable returned by the specified <paramref name="factory" /> is assigned.</param>
      <param name="factory">Returns an <see cref="T:System.IDisposable" /> that is assigned to the specified <paramref name="disposable" />.</param>
      <seealso href="http://social.msdn.microsoft.com/Forums/en-IE/rx/thread/4e15feae-9c4c-4962-af32-95dde1420dda#4d5fe8c8-e5e8-4ee7-93ca-b48b6a56b8af">
            Double indirection pattern example in Rx
            </seealso>
      <requires>disposable != null</requires>
      <requires>factory != null</requires>
    </member>
    <member name="T:System.Reactive.Linq.Observable2">
      <summary>
            Provides a set of <see langword="static" /> methods for query operations over observable sequences.
            </summary>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``1(System.IObservable{``0})">
      <summary>
            Adds the elements from the specified observable sequence into a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The sequence from which elements are collected.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequence.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``1(System.IObservable{System.Reactive.CollectionModification{``0}})">
      <summary>
            Adds the elements from the specified observable sequence into a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" />, or removes
            individual elements or clears all elements, depending upon the <see cref="T:System.Reactive.CollectionModificationKind" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="source">The sequence from which collection modifications are received.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequence.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``1(System.Collections.Generic.IEnumerable{``0},System.IObservable{System.Reactive.CollectionModification{``0}})">
      <summary>
            Concurrently populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the default equality comparer for 
            <typeparamref name="T" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> is initially populated.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> are received.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``1(System.Collections.Generic.IEnumerable{``0},System.IObservable{System.Reactive.CollectionModification{``0}},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Concurrently populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the specified equality comparer for 
            <typeparamref name="T" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> is initially populated.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> are received.</param>
      <param name="comparer">The object that compares two instances of <typeparamref name="T" /> for equality and generates a hash code 
            that is suitable for use when keying a dictionary.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``1(System.IObservable{``0},System.IObservable{System.Reactive.CollectionModification{``0}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the default equality comparer for 
            <typeparamref name="T" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> is initially populated.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> are received.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``1(System.IObservable{``0},System.IObservable{System.Reactive.CollectionModification{``0}},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the specified equality comparer for 
            <typeparamref name="T" />.
            </summary>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> is initially populated.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> are received.</param>
      <param name="comparer">The object that compares two instances of <typeparamref name="T" /> for equality and generates a hash code 
            that is suitable for keying a dictionary.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.Collections.Generic.IEnumerable{``0},System.IObservable{System.Reactive.CollectionModification{``0}},System.Func{System.IObservable{System.Reactive.CollectionNotification{``0}},System.IObservable{System.Reactive.CollectionModification{``1}}})">
      <summary>
            Concurrently populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the default equality comparer for 
            <typeparamref name="TSource" /> and projecting notifications using the specified <paramref name="selector" /> function.
            </summary>
      <typeparam name="TSource">The type of objects in the source sequences.</typeparam>
      <typeparam name="TResult">The type of objects to which reconciled elements are projected.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> is initially populated.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> are received.</param>
      <param name="selector">Projects a sequence of reconciled collection notifications, combining the <paramref name="existing" /> and 
            <paramref name="changes" /> sequences, into a sequence from which the list is populated.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.Collections.Generic.IEnumerable{``0},System.IObservable{System.Reactive.CollectionModification{``0}},System.Func{System.IObservable{System.Reactive.CollectionNotification{``0}},System.IObservable{System.Reactive.CollectionModification{``1}}},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Concurrently populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the specified equality comparer for 
            <typeparamref name="TSource" /> and projecting notifications using the specified <paramref name="selector" /> function.
            </summary>
      <typeparam name="TSource">The type of objects in the source sequences.</typeparam>
      <typeparam name="TResult">The type of objects to which reconciled elements are projected.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> is initially populated.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> are received.</param>
      <param name="selector">Projects a sequence of reconciled collection notifications, combining the <paramref name="existing" /> and 
            <paramref name="changes" /> sequences, into a sequence from which the list is populated.</param>
      <param name="comparer">The object that compares two instances of <typeparamref name="TSource" /> for equality and generates a hash code 
            that is suitable for use when keying a dictionary.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <requires>selector != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.IObservable{``0},System.IObservable{System.Reactive.CollectionModification{``0}},System.Func{System.IObservable{System.Reactive.CollectionNotification{``0}},System.IObservable{System.Reactive.CollectionModification{``1}}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the default equality comparer for 
            <typeparamref name="TSource" /> and projecting notifications using the specified <paramref name="selector" /> function.
            </summary>
      <typeparam name="TSource">The type of objects in the source sequences.</typeparam>
      <typeparam name="TResult">The type of objects to which reconciled elements are projected.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> is initially populated.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> are received.</param>
      <param name="selector">Projects a sequence of reconciled collection notifications, combining the <paramref name="existing" /> and 
            <paramref name="changes" /> sequences, into a sequence from which the list is populated.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.IObservable{``0},System.IObservable{System.Reactive.CollectionModification{``0}},System.Func{System.IObservable{System.Reactive.CollectionNotification{``0}},System.IObservable{System.Reactive.CollectionModification{``1}}},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the specified equality comparer for 
            <typeparamref name="TSource" /> and projecting notifications using the specified <paramref name="selector" /> function.
            </summary>
      <typeparam name="TSource">The type of objects in the source sequences.</typeparam>
      <typeparam name="TResult">The type of objects to which reconciled elements are projected.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> is initially populated.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> are received.</param>
      <param name="selector">Projects a sequence of reconciled collection notifications, combining the <paramref name="existing" /> and 
            <paramref name="changes" /> sequences, into a sequence from which the list is populated.</param>
      <param name="comparer">The object that compares two instances of <typeparamref name="TSource" /> for equality and generates a hash code 
            that is suitable for keying a dictionary.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <requires>selector != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyListSubject&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.CombineLatest``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
      <summary>
            Merges two or more observable sequences into one observable sequence of lists, each containing the latest values from all observable sequences
            whenever one of the sequences produces an element.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sources">An enumerable sequence containing two or more observable sequences to be merged.</param>
      <remarks>
        <para>
            All of the observable sequences must produce at least one element; otherwise, the generated sequence will be empty.  Furthermore, if an observable 
            sequence produces more than one element before each of the other observable sequences have produced their first elements, then all of the older 
            elements are discarded and will not be included in the generated sequence.  Only the latest elements from each sequence are included.
            </para>
        <para>
            The latest value of an observable sequence is always located in the generated lists at the same index in which that sequence is located in the outer sequence.
            For example, the values from the first observable sequence in the outer sequence will always be at index zero (0) in the lists that are generated.
            </para>
      </remarks>
      <returns>An observable sequence containing the result of combining the latest elements of all sources into lists.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IList&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.CombineLatest``1(System.IObservable{System.IObservable{``0}})">
      <summary>
            Merges two or more observable sequences into one observable sequence of lists, each containing the latest values from the latest consecutive 
            observable sequences whenever one of the sequences produces an element.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sources">An observable sequence containing two or more observable sequences to be merged.</param>
      <remarks>
        <para>
            At least two consecutive observable sequences from the beginning of the outer observable sequence must produce at least one element; otherwise, 
            the generated sequence will be empty.  Furthermore, if an observable sequence produces more than one element before each of the consecutive observable 
            sequences have produced their first elements, then all of the older elements are discarded and will not be included in the generated sequence.
            Only the latest elements from each of the consecutive sequences are included.  As new sequences arrive, the size of the generated lists are increased
            to accomodate them if they start producing values.
            </para>
        <para>
            The latest value of an observable sequence is always located in the generated lists at the same index in which that sequence is located in the outer sequence.
            For example, the values from the first observable sequence in the outer sequence will always be at index zero (0) in the lists that are generated.
            Furthermore, once a generated list contains the value for a particular observable sequence, all subsequent lists will also contain the latest value for that 
            sequence.  As a result, the number of items in the generated lists may stay the same or grow when new observable sequences arrive, but the size of the lists 
            will never shrink.
            </para>
      </remarks>
      <returns>An observable sequence containing the result of combining the latest elements of all sources into lists.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IList&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}})">
      <summary>
            Concurrently invokes the specified factory to create observables as fast and often as possible and subscribes to all of them
            up to the default maximum concurrency.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sourceFactory">A function that returns observables.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}})" /> is similar to <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}},System.Int32)" />
            except that it does not obey the serializability guarantee for <see cref="M:System.IObserver`1.OnNext(`0)" /> that is recommended in the 
            <strong>Rx Design Guidelines</strong>.  Its behavior is therefore more suitable for hosting environments that must service multiple
            requests concurrently without blocking during observations.  This comes with the loss of automatic synchronization and thread-safety 
            that is normally provided by Rx operators, thus consumers are responsible for ensuring the thread-safety of all observers themselves.
            </para>
      </remarks>
      <returns>A concurrent observable sequence.</returns>
      <requires>sourceFactory != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Func{System.Exception,System.Boolean})">
      <summary>
            Concurrently invokes the specified factory to create observables as fast and often as possible and subscribes to all of them
            up to the default maximum concurrency.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sourceFactory">A function that returns observables.</param>
      <param name="onError">Determines whether an error should fault the entire observable sequence.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Func{System.Exception,System.Boolean})" /> is similar to <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}},System.Int32)" />
            except that it does not obey the serializability guarantee for <see cref="M:System.IObserver`1.OnNext(`0)" /> that is recommended in the 
            <strong>Rx Design Guidelines</strong>.  Its behavior is therefore more suitable for hosting environments that must service multiple
            requests concurrently without blocking during observations.  This comes with the loss of automatic synchronization and thread-safety 
            that is normally provided by Rx operators, thus consumers are responsible for ensuring the thread-safety of all observers themselves.
            </para>
        <para>
            Furthermore, <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Func{System.Exception,System.Boolean})" /> provides an <paramref name="onError" /> parameter that 
            allows the caller to decide whether an <see cref="T:System.Exception" /> is fatal and should fault the entire sequence.  This function 
            should return <see langword="true" /> to indicate that an <see cref="T:System.Exception" /> has been handled, thus preventing the sequence
            from being faulted; otherwise, return <see langword="false" /> to fault the sequence and halt processing as soon as possible.
            In the latter case, the <see cref="T:System.Exception" /> is then passed to the observer of the sequence as is the normal behavior in Rx.
            </para>
      </remarks>
      <returns>A concurrent observable sequence.</returns>
      <requires>sourceFactory != null</requires>
      <requires>onError != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Int32)">
      <summary>
            Concurrently invokes the specified factory to create observables as fast and often as possible and subscribes to all of them
            up to the specified maximum concurrency.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sourceFactory">A function that returns observables.</param>
      <param name="maxConcurrent">The maximum number of observables to be subscribed simultaneously.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Int32)" /> is similar to <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}},System.Int32)" />
            except that it does not obey the serializability guarantee for <see cref="M:System.IObserver`1.OnNext(`0)" /> that is recommended in the 
            <strong>Rx Design Guidelines</strong>.  Its behavior is therefore more suitable for hosting environments that must service multiple
            requests concurrently without blocking during observations.  This comes with the loss of automatic synchronization and thread-safety 
            that is normally provided by Rx operators, thus consumers are responsible for ensuring the thread-safety of all observers themselves.
            </para>
      </remarks>
      <returns>A concurrent observable sequence.</returns>
      <requires>sourceFactory != null</requires>
      <requires>maxConcurrent &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Int32,System.Func{System.Exception,System.Boolean})">
      <summary>
            Concurrently invokes the specified factory to create observables as fast and often as possible and subscribes to all of them
            up to the specified maximum concurrency.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sourceFactory">A function that returns observables.</param>
      <param name="maxConcurrent">The maximum number of observables to be subscribed simultaneously.</param>
      <param name="onError">Determines whether an error should fault the entire observable sequence.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Int32,System.Func{System.Exception,System.Boolean})" /> is similar to <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}},System.Int32)" />
            except that it does not obey the serializability guarantee for <see cref="M:System.IObserver`1.OnNext(`0)" /> that is recommended in the 
            <strong>Rx Design Guidelines</strong>.  Its behavior is therefore more suitable for hosting environments that must service multiple
            requests concurrently without blocking during observations.  This comes with the loss of automatic synchronization and thread-safety 
            that is normally provided by Rx operators, thus consumers are responsible for ensuring the thread-safety of all observers themselves.
            </para>
        <para>
            Furthermore, <see cref="M:System.Reactive.Linq.Observable2.Serve``1(System.Func{System.IObservable{``0}},System.Int32,System.Func{System.Exception,System.Boolean})" /> provides an <paramref name="onError" /> parameter that 
            allows the caller to decide whether an <see cref="T:System.Exception" /> is fatal and should fault the entire sequence.  This function 
            should return <see langword="true" /> to indicate that an <see cref="T:System.Exception" /> has been handled, thus preventing the sequence
            from being faulted; otherwise, return <see langword="false" /> to fault the sequence and halt processing as soon as possible.
            In the latter case, the <see cref="T:System.Exception" /> is then passed to the observer of the sequence as is the normal behavior in Rx.
            </para>
      </remarks>
      <returns>A concurrent observable sequence.</returns>
      <requires>sourceFactory != null</requires>
      <requires>maxConcurrent &gt; 0</requires>
      <requires>onError != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.ToCursor``1(System.IObservable{``0})">
      <summary>
            Returns a cursor for the specified observable sequence.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence that the cursor moves over.</param>
      <remarks>
            The cursor's <see cref="P:System.Reactive.IObservableCursor`1.IsForwardOnly" /> property returns <see langword="false" />, 
            indicating that it can move forward and backward.
            </remarks>
      <returns>A cursor for the specified observable sequence.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.ToCursor``1(System.IObservable{``0},System.Boolean)">
      <summary>
            Returns a cursor for the specified observable sequence with the specified support for backward movement.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence that the cursor moves over.</param>
      <param name="forwardOnly">Specifies whether the cursor only moves forward.</param>
      <returns>A cursor for the specified observable sequence with the specified support for backward movement.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().IsForwardOnly == forwardOnly</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Synchronize``1(System.Reactive.IObservableCursor{``0})">
      <summary>
            Returns a thread-safe wrapper around the specified <paramref name="cursor" />.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="cursor">The observable cursor to be synchronized.</param>
      <remarks>
            Branches that are created before calling this method will not be synchronized; however, any new 
            branches that are created by the returned cursor will be synchronized with the cursor.
            </remarks>
      <returns>A thread-safe wrapper around the specified <paramref name="cursor" />.</returns>
      <requires>cursor != null</requires>
      <ensures>cursor.IsSynchronized == Contract.OldValue(cursor.IsSynchronized)</ensures>
      <ensures>cursor.IsForwardOnly == Contract.OldValue(cursor.IsForwardOnly)</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().IsSynchronized</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().IsForwardOnly == cursor.IsForwardOnly</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Synchronize``1(System.Reactive.IObservableCursor{``0},System.Object)">
      <summary>
            Returns a thread-safe wrapper around the specified <paramref name="cursor" />.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="cursor">The observable cursor to be synchronized.</param>
      <param name="gate">An object used to synchronize the specified <paramref name="cursor" />.</param>
      <remarks>
            Branches that are created before calling this method will not be synchronized; however, any new 
            branches that are created by the returned cursor will be synchronized with the cursor.
            </remarks>
      <returns>A thread-safe wrapper around the specified <paramref name="cursor" />.</returns>
      <requires>cursor != null</requires>
      <requires>gate != null</requires>
      <ensures>cursor.IsSynchronized == Contract.OldValue(cursor.IsSynchronized)</ensures>
      <ensures>cursor.IsForwardOnly == Contract.OldValue(cursor.IsForwardOnly)</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().IsSynchronized</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().IsForwardOnly == cursor.IsForwardOnly</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Remainder``1(System.Reactive.IObservableCursor{``0},System.Int32)">
      <summary>
            Branches from the specified <paramref name="cursor" /> and moves the branch forward the specified number of elements.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="cursor">The observable cursor from which to branch.</param>
      <param name="skip">The number of elements that the new branch must skip.</param>
      <returns>A new branch from the specified <paramref name="cursor" /> with its current index moved ahead the specified 
            number of elements.</returns>
      <requires>cursor != null</requires>
      <requires>skip &gt;= 0</requires>
      <ensures>cursor.IsSynchronized == Contract.OldValue(cursor.IsSynchronized)</ensures>
      <ensures>cursor.IsForwardOnly == Contract.OldValue(cursor.IsForwardOnly)</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;() != null</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().IsSynchronized == cursor.IsSynchronized</ensures>
      <ensures>Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().IsForwardOnly == cursor.IsForwardOnly</ensures>
      <ensures>cursor.IsSynchronized || Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().IsSequenceTerminated == cursor.IsSequenceTerminated</ensures>
      <ensures>cursor.IsSynchronized || Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().LatestIndex == cursor.LatestIndex</ensures>
      <ensures>cursor.IsSynchronized || Contract.Result&lt;IObservableCursor&lt;TSource&gt;&gt;().CurrentIndex ==
				(cursor.AtEndOfSequence
				? cursor.CurrentIndex
				: cursor.IsSequenceTerminated
					? Math.Min(cursor.CurrentIndex + skip, cursor.LatestIndex + 1)
					: cursor.CurrentIndex + skip)</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.IObservable{``1},System.Func{``1,``0})">
      <summary>
            Adds the elements from the specified observable sequence into a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="source">The sequence from which elements are collected.</param>
      <param name="keySelector">A function that maps values to keys.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequence.</returns>
      <requires>source != null</requires>
      <requires>keySelector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.IObservable{``1},System.Func{``1,``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Adds the elements from the specified observable sequence into a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="source">The sequence from which elements are collected.</param>
      <param name="keySelector">A function that maps values to keys.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequence.</returns>
      <requires>source != null</requires>
      <requires>keySelector != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``0,``1}}})">
      <summary>
            Adds the elements from the specified observable sequence into a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" />, or removes
            individual elements or clears all elements, depending upon the <see cref="T:System.Reactive.CollectionModificationKind" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="source">The sequence from which collection modifications are received.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequence.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``0,``1}}},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Adds the elements from the specified observable sequence into a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" />, or removes
            individual elements or clears all elements, depending upon the <see cref="T:System.Reactive.CollectionModificationKind" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="source">The sequence from which collection modifications are received.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</param>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequence.</returns>
      <requires>source != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``0,``1}}})">
      <summary>
            Concurrently populates a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the default equality comparer for 
            <typeparamref name="TKey" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> is initially populated.</param>
      <param name="keySelector">A function that maps values from the <paramref name="existing" /> sequence to keys.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> are received.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>keySelector != null</requires>
      <requires>changes != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``0,``1}}},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Concurrently populates a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the specified equality comparer for 
            <typeparamref name="TKey" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> is initially populated.</param>
      <param name="keySelector">A function that maps values from the <paramref name="existing" /> sequence to keys.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> are received.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>keySelector != null</requires>
      <requires>changes != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.IObservable{``1},System.Func{``1,``0},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``0,``1}}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the default equality comparer for 
            <typeparamref name="TKey" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> is initially populated.</param>
      <param name="keySelector">A function that maps values from the <paramref name="existing" /> sequence to keys.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> are received.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>keySelector != null</requires>
      <requires>changes != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``2(System.IObservable{``1},System.Func{``1,``0},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``0,``1}}},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the specified equality comparer for 
            <typeparamref name="TKey" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> is initially populated.</param>
      <param name="keySelector">A function that maps values from the <paramref name="existing" /> sequence to keys.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> are received.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>keySelector != null</requires>
      <requires>changes != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``1,``0}}},System.Func{System.IObservable{System.Reactive.CollectionNotification{System.Collections.Generic.KeyValuePair{``1,``0}}},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``1,``2}}}})">
      <summary>
            Concurrently populates a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the default equality comparer for 
            <typeparamref name="TKey" /> and projecting notifications using the specified <paramref name="selector" /> function.
            </summary>
      <typeparam name="TSource">The type of objects in the source sequences.</typeparam>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TResult">The type of objects to which reconciled elements are projected.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> is initially populated.</param>
      <param name="keySelector">A function that maps values from the <paramref name="existing" /> sequence to keys.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> are received.</param>
      <param name="selector">Projects a sequence of reconciled collection notifications, combining the <paramref name="existing" /> and 
            <paramref name="changes" /> sequences, into a sequence from which the dictionary is populated.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>keySelector != null</requires>
      <requires>changes != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``1,``0}}},System.Func{System.IObservable{System.Reactive.CollectionNotification{System.Collections.Generic.KeyValuePair{``1,``0}}},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``1,``2}}}},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Concurrently populates a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the specified equality comparer for 
            <typeparamref name="TKey" /> and projecting notifications using the specified <paramref name="selector" /> function.
            </summary>
      <typeparam name="TSource">The type of objects in the source sequences.</typeparam>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TResult">The type of objects to which reconciled elements are projected.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> is initially populated.</param>
      <param name="keySelector">A function that maps values from the <paramref name="existing" /> sequence to keys.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> are received.</param>
      <param name="selector">Projects a sequence of reconciled collection notifications, combining the <paramref name="existing" /> and 
            <paramref name="changes" /> sequences, into a sequence from which the dictionary is populated.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>keySelector != null</requires>
      <requires>changes != null</requires>
      <requires>selector != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``3(System.IObservable{``0},System.Func{``0,``1},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``1,``0}}},System.Func{System.IObservable{System.Reactive.CollectionNotification{System.Collections.Generic.KeyValuePair{``1,``0}}},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``1,``2}}}})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the default equality comparer for 
            <typeparamref name="TKey" /> and projecting notifications using the specified <paramref name="selector" /> function.
            </summary>
      <typeparam name="TSource">The type of objects in the source sequences.</typeparam>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TResult">The type of objects to which reconciled elements are projected.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> is initially populated.</param>
      <param name="keySelector">A function that maps values from the <paramref name="existing" /> sequence to keys.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> are received.</param>
      <param name="selector">Projects a sequence of reconciled collection notifications, combining the <paramref name="existing" /> and 
            <paramref name="changes" /> sequences, into a sequence from which the dictionary is populated.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>keySelector != null</requires>
      <requires>changes != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``3(System.IObservable{``0},System.Func{``0,``1},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``1,``0}}},System.Func{System.IObservable{System.Reactive.CollectionNotification{System.Collections.Generic.KeyValuePair{``1,``0}}},System.IObservable{System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{``1,``2}}}},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Populates a <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> with elements from the first sequence while also handling changes 
            from the second sequence of collection modifications, reconciling conflicts using the specified equality comparer for 
            <typeparamref name="TKey" /> and projecting notifications using the specified <paramref name="selector" /> function.
            </summary>
      <typeparam name="TSource">The type of objects in the source sequences.</typeparam>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TResult">The type of objects to which reconciled elements are projected.</typeparam>
      <param name="existing">The sequence from which the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> is initially populated.</param>
      <param name="keySelector">A function that maps values from the <paramref name="existing" /> sequence to keys.</param>
      <param name="changes">The sequence from which collection notifications that modify the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> are received.</param>
      <param name="selector">Projects a sequence of reconciled collection notifications, combining the <paramref name="existing" /> and 
            <paramref name="changes" /> sequences, into a sequence from which the dictionary is populated.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</param>
      <remarks>
        <para>
				The <paramref name="changes" /> sequence is subscribed to first, followed by the <paramref name="existing" /> sequence on
				another thread.  This order of subscription avoids a certain race condition that could otherwise allow an element that
				no longer exists to be added anyway, without receiving a corresponding <em>Remove</em> notification from the <paramref name="changes" />
				sequence.
			</para>
        <para>
				The <paramref name="existing" /> sequence is used to populate the initial state of the collection, under the assumption that the
				<paramref name="changes" /> sequence does not provide <see cref="F:System.Reactive.CollectionModificationKind.Add" /> notifications for
				elements that are considered to already exist; however, it may provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for existing elements after it provides corresponding <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notifications for those elements, thus the <paramref name="changes" /> sequence is processed concurrently while the collection is
				being populated by the <paramref name="existing" /> sequence.
			</para>
        <para>
				The <paramref name="changes" /> sequence is given precedence for all race conditions and conflicts while the collection is being
				populated by the <paramref name="existing" /> sequence.  This process is refered to as reconciliation.
			</para>
        <para>
				Reconciliation ends when either of the two sequences completes.  It also ends upon the first
				<see cref="F:System.Reactive.CollectionModificationKind.Clear" /> notification to be received, because this indicates that there are no
				more existing elements.  The remainder of the <paramref name="existing" /> sequence is therefore ignored.  If the
				<paramref name="existing" /> sequence is still producing elements, then those elements must have been created recently and
				simply picked up by the <paramref name="existing" /> sequence due to a race condition outside of the control of this method;
				however, the <paramref name="changes" /> sequence is still expected to provide <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notifications for these new elements, so they will not be missed.
			</para>
        <para>
				A well-behaving <paramref name="existing" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> provide a forward-only view of the source.
					</description>
          </item>
          <item>
            <description>
              <strong>MUST</strong> ensure that element positions within the sequence are unique and absolute.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> finish observing all existing items and call <em>OnCompleted</em>.
					</description>
          </item>
        </list>
        <para>
				Therefore, if an element is created after the <paramref name="existing" /> sequence has passed the element's absolute position,
				it will not be included in the <paramref name="existing" /> sequence; however, a well-behaving <paramref name="changes" />
				sequence will include it.  Furthermore, if an element is observed by the <paramref name="existing" /> sequence and then
				subsequently deleted and recreated, it will not be observed a second time.
			</para>
        <para>
				A well-behaving <paramref name="changes" /> sequence:
			</para>
        <list type="1">
          <item>
            <description>
              <strong>MUST</strong> generate notifications in a logical order.
					</description>
          </item>
          <item>
            <description>
              <strong>SHOULD</strong> provide a dynamic, real-time view that includes all changes to the source.
					</description>
          </item>
        </list>
        <para>
				An example of a logical order for the <paramref name="changes" /> sequence is to include an
				<see cref="F:System.Reactive.CollectionModificationKind.Add" /> notification followed by a <see cref="F:System.Reactive.CollectionModificationKind.Remove" />
				notification when an element has been added and subsequently removed.  An example of an illogical order for this scenario is
				to include a <see cref="F:System.Reactive.CollectionModificationKind.Remove" /> notification before an <see cref="F:System.Reactive.CollectionModificationKind.Add" />
				notification, which does not accurately reflect the state of changes to the source.
			</para>
        <alert type="warning">
				An illogical ordering of notifications in the <paramref name="changes" /> sequence voids all gaurantees that the
				reconciliation process makes about the state of the collection when the <paramref name="existing" /> sequence
				completes, and also voids all gaurantees about the active state of the collection thereafter.
			</alert>
      </remarks>
      <returns>A <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> that receives the elements from the specified sequences.</returns>
      <requires>existing != null</requires>
      <requires>keySelector != null</requires>
      <requires>changes != null</requires>
      <requires>selector != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;ReadOnlyDictionarySubject&lt;TKey, TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Catch``2(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception 
            until one of the observables successfully terminates.  The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Catch``2(System.Collections.Generic.IEnumerable{System.IObservable{``0}},System.Func{``1,System.TimeSpan})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception 
            using the specified back-off algorithm until one of the observables successfully terminates.
            The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="backOffSelector">Selects the amount of time to delay before moving to the next observable 
            when the current sequence has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Catch``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception 
            until one of the observables successfully terminates.  The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Catch``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}},System.Func{``1,System.Collections.Generic.IEnumerator{System.IObservable{``0}}})">
      <summary>
            Moves to the next observable sequence provided by the specified <paramref name="handler" /> when the current 
            sequence throws the specified type of exception until one of the observables successfully terminates.
            The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="handler">Selects the next enumerator when an observable from the current enumerator has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>handler != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Catch``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}},System.Func{``1,System.Collections.Generic.IEnumerator{System.IObservable{``0}}},System.Func{``1,System.TimeSpan})">
      <summary>
            Moves to the next observable sequence provided by the specified <paramref name="handler" /> when the current 
            sequence throws the specified type of exception using the specified back-off algorithm until one of the observables 
            successfully terminates.  The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="handler">Selects the next enumerator when an observable from the current enumerator has faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before moving to the next observable 
            when the current sequence has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>handler != null</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.OnErrorResumeNext``2(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception.
            The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.OnErrorResumeNext``2(System.Collections.Generic.IEnumerable{System.IObservable{``0}},System.Func{``1,System.TimeSpan})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception 
            using the specified back-off algorithm.  The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="backOffSelector">Selects the amount of time to delay before moving to the next observable 
            when the current sequence has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.OnErrorResumeNext``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}})">
      <summary>
            Moves to the next observable sequence when the current sequence throws the specified type of exception.
            The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.OnErrorResumeNext``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}},System.Func{``1,System.Collections.Generic.IEnumerator{System.IObservable{``0}}})">
      <summary>
            Moves to the next observable sequence provided by the specified <paramref name="handler" /> when the current 
            sequence throws the specified type of exception.  The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="handler">Selects the next enumerator when an observable from the current enumerator has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>handler != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.OnErrorResumeNext``2(System.Collections.Generic.IEnumerator{System.IObservable{``0}},System.Func{``1,System.Collections.Generic.IEnumerator{System.IObservable{``0}}},System.Func{``1,System.TimeSpan})">
      <summary>
            Moves to the next observable sequence provided by the specified <paramref name="handler" /> when the current 
            sequence throws the specified type of exception using the specified back-off algorithm.
            The output is paired with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="sources">The observables to be enumerated.</param>
      <param name="handler">Selects the next enumerator when an observable from the current enumerator has faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before moving to the next observable 
            when the current sequence has faulted.</param>
      <returns>An observable sequence with an error channel.</returns>
      <requires>sources != null</requires>
      <requires>handler != null</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Retry``2(System.IObservable{``0},System.Int32)">
      <summary>
            Repeats the source observable sequence when it throws the specified type of exception 
            until it successfully terminates or the specified count has been reached and pairs it
            with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="retryCount">The maximum number of times to retry the sequence when it's faulted.</param>
      <returns>The specified observable sequence with an error channel.</returns>
      <requires>source != null</requires>
      <requires>retryCount &gt;= 0</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Retry``1(System.IObservable{``0},System.Int32,System.Func{System.Exception,System.Int32,System.TimeSpan})">
      <summary>
            Repeats the source observable sequence using the specified back-off algorithm until it 
            successfully terminates or the specified count has been reached and pairs it with an 
            error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="retryCount">The maximum number of times to retry the sequence when it's faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before repeating when the sequence has faulted.</param>
      <returns>The specified observable sequence with an error channel.</returns>
      <requires>source != null</requires>
      <requires>retryCount &gt;= 0</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, Exception&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Retry``2(System.IObservable{``0},System.Int32,System.Func{``1,System.Int32,System.TimeSpan})">
      <summary>
            Repeats the source observable sequence when it throws the specified type of exception
            using the specified back-off algorithm until it successfully terminates or the specified 
            count has been reached and pairs it with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="retryCount">The maximum number of times to retry the sequence when it's faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before repeating when the sequence has faulted.</param>
      <returns>The specified observable sequence with an error channel.</returns>
      <requires>source != null</requires>
      <requires>retryCount &gt;= 0</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.RetryConsecutive``1(System.IObservable{``0},System.Int32)">
      <summary>
            Repeats the source observable sequence when it throws consecutively 
            until it produces a value, successfully terminates or the specified count 
            has been reached and pairs it with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="consecutiveRetryCount">The maximum number of times to retry the sequence consecutively 
            when it's faulted.</param>
      <remarks>
        <see cref="M:System.Reactive.Linq.Observable2.RetryConsecutive``1(System.IObservable{``0},System.Int32)" /> is appropriate when permanent recovery is required for sequences 
            that experience ephemeral consecutive errors at unpredictable intervals, such as those originating 
            from network streams.  For example, it can produce a sequence that automatically reconnects upon 
            consecutive network failures up to the specified <paramref name="consecutiveRetryCount" /> number of 
            times; furthermore, if the sequence is able to successfully generate a value after an error, then 
            the retry count is reset for subsequent consecutive failures.
            </remarks>
      <returns>The specified observable sequence with an error channel.</returns>
      <requires>source != null</requires>
      <requires>consecutiveRetryCount &gt;= 0</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, Exception&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.RetryConsecutive``2(System.IObservable{``0},System.Int32)">
      <summary>
            Repeats the source observable sequence when it throws the specified type of exception 
            consecutively until it produces a value, successfully terminates or the specified count 
            has been reached and pairs it with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="consecutiveRetryCount">The maximum number of times to retry the sequence consecutively 
            when it's faulted.</param>
      <remarks>
        <see cref="M:System.Reactive.Linq.Observable2.RetryConsecutive``2(System.IObservable{``0},System.Int32)" /> is appropriate when permanent recovery is required for sequences 
            that experience ephemeral consecutive errors at unpredictable intervals, such as those originating 
            from network streams.  For example, it can produce a sequence that automatically reconnects upon 
            consecutive network failures up to the specified <paramref name="consecutiveRetryCount" /> number of 
            times; furthermore, if the sequence is able to successfully generate a value after an error, then 
            the retry count is reset for subsequent consecutive failures.
            </remarks>
      <returns>The specified observable sequence with an error channel.</returns>
      <requires>source != null</requires>
      <requires>consecutiveRetryCount &gt;= 0</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.RetryConsecutive``1(System.IObservable{``0},System.Int32,System.Func{System.Exception,System.Int32,System.TimeSpan})">
      <summary>
            Repeats the source observable sequence when it throws consecutively 
            using the specified back-off algorithm until it produces a value, successfully terminates or 
            the specified count has been reached and pairs it with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="consecutiveRetryCount">The maximum number of times to retry the sequence consecutively 
            when it's faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before repeating when the sequence has faulted.</param>
      <remarks>
        <see cref="M:System.Reactive.Linq.Observable2.RetryConsecutive``1(System.IObservable{``0},System.Int32,System.Func{System.Exception,System.Int32,System.TimeSpan})" /> is appropriate when permanent recovery is required for sequences 
            that experience ephemeral consecutive errors at unpredictable intervals, such as those originating 
            from network streams.  For example, it can produce a sequence that automatically reconnects upon 
            consecutive network failures up to the specified <paramref name="consecutiveRetryCount" /> number of 
            times; furthermore, if the sequence is able to successfully generate a value after an error, then 
            the retry count is reset for subsequent consecutive failures.
            </remarks>
      <returns>The specified observable sequence with an error channel.</returns>
      <seealso href="http://en.wikipedia.org/wiki/Exponential_backoff">
            Exponential backoff
            </seealso>
      <requires>source != null</requires>
      <requires>consecutiveRetryCount &gt;= 0</requires>
      <requires>backOffSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TSource, Exception&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.RetryConsecutive``2(System.IObservable{``0},System.Int32,System.Func{``1,System.Int32,System.TimeSpan})">
      <summary>
            Repeats the source observable sequence when it throws the specified type of exception 
            consecutively using the specified back-off algorithm until it produces a value, successfully terminates 
            or the specified count has been reached and pairs it with an error channel.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TException">The type of exception to catch.</typeparam>
      <param name="source">The observable to be repeated.</param>
      <param name="consecutiveRetryCount">The maximum number of times to retry the sequence consecutively 
            when it's faulted.</param>
      <param name="backOffSelector">Selects the amount of time to delay before repeating when the sequence has faulted.</param>s
            <remarks><see cref="M:System.Reactive.Linq.Observable2.RetryConsecutive``2(System.IObservable{``0},System.Int32,System.Func{``1,System.Int32,System.TimeSpan})" /> is appropriate when permanent recovery is required for sequences 
            that experience ephemeral consecutive errors at unpredictable intervals, such as those originating 
            from network streams.  For example, it can produce a sequence that automatically reconnects upon 
            consecutive network failures up to the specified <paramref name="consecutiveRetryCount" /> number of 
            times; furthermore, if the sequence is able to successfully generate a value after an error, then 
            the retry count is reset for subsequent consecutive failures.
            </remarks><returns>The specified observable sequence with an error channel.</returns><seealso href="http://en.wikipedia.org/wiki/Exponential_backoff">
            Exponential backoff
            </seealso><requires>source != null</requires><requires>consecutiveRetryCount &gt;= 0</requires><requires>backOffSelector != null</requires><ensures>Contract.Result&lt;IPairedObservable&lt;TSource, TException&gt;&gt;() != null</ensures></member>
    <member name="M:System.Reactive.Linq.Observable2.FromEventBasedAsyncPattern``1(System.Func{System.EventHandler{System.ComponentModel.AsyncCompletedEventArgs},``0},System.Action{``0},System.Action{``0},System.Action{System.Object},System.Action)">
      <summary>
            Creates an observable sequence that contains the cached result from an 
            Event-based Asynchronous Pattern (EBAP) implementation.
            </summary>
      <typeparam name="TDelegate">Type of the event's delegate.</typeparam>
      <param name="conversion">A function used to convert the given event handler to a delegate compatible
            with the underlying .NET event. The resulting delegate is used in calls to the 
            <paramref name="addHandler" /> and <paramref name="removeHandler" /> action parameters.</param>
      <param name="addHandler">Action that attaches the given event handler to the underlying .NET event.</param>
      <param name="removeHandler">Action that detaches the given event handler from the underlying .NET event.</param>
      <param name="start">An action that receives the user token object and begins the asynchronous process.</param>
      <param name="cancel">An action that cancels the asynchronous process when any subscription to the returned 
            observable is disposed.</param>
      <returns>An observable sequence that contains the cached result of the asynchronous operation.</returns>
      <seealso href="http://msdn.microsoft.com/en-us/library/wewwczdw.aspx">
            Event-based Asynchronous Pattern Overview
            </seealso>
      <requires>conversion != null</requires>
      <requires>addHandler != null</requires>
      <requires>removeHandler != null</requires>
      <requires>start != null</requires>
      <requires>cancel != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;AsyncCompletedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromEventBasedAsyncPattern``2(System.Func{System.EventHandler{``1},``0},System.Action{``0},System.Action{``0},System.Action{System.Object},System.Action)">
      <summary>
            Creates an observable sequence that contains the cached result from an 
            Event-based Asynchronous Pattern (EBAP) implementation.
            </summary>
      <typeparam name="TDelegate">Type of the event's delegate.</typeparam>
      <typeparam name="TEventArgs">Type of the event's arguments.</typeparam>
      <param name="conversion">A function used to convert the given event handler to a delegate compatible
            with the underlying .NET event. The resulting delegate is used in calls to the 
            <paramref name="addHandler" /> and <paramref name="removeHandler" /> action parameters.</param>
      <param name="addHandler">Action that attaches the given event handler to the underlying .NET event.</param>
      <param name="removeHandler">Action that detaches the given event handler from the underlying .NET event.</param>
      <param name="start">An action that receives the user token object and begins the asynchronous process.</param>
      <param name="cancel">An action that cancels the asynchronous process when any subscription to the returned 
            observable is disposed.</param>
      <returns>An observable sequence that contains the cached result of the asynchronous operation.</returns>
      <seealso href="http://msdn.microsoft.com/en-us/library/wewwczdw.aspx">
            Event-based Asynchronous Pattern Overview
            </seealso>
      <requires>conversion != null</requires>
      <requires>addHandler != null</requires>
      <requires>removeHandler != null</requires>
      <requires>start != null</requires>
      <requires>cancel != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;TEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromEventBasedAsyncPattern``3(System.Func{System.EventHandler{System.ComponentModel.AsyncCompletedEventArgs},``0},System.Action{``0},System.Action{``0},System.Func{System.EventHandler{``2},``1},System.Action{``1},System.Action{``1},System.Action{System.Object},System.Action)">
      <summary>
            Creates a paired observable sequence of progress notifications along with the cached result from an 
            Event-based Asynchronous Pattern (EBAP) implementation.
            </summary>
      <typeparam name="TDelegate">Type of the event's delegate.</typeparam>
      <typeparam name="TProgressDelegate">Type of the progress event's delegate.</typeparam>
      <typeparam name="TProgressEventArgs">Type of the progress event's arguments.</typeparam>
      <param name="conversion">A function used to convert the given event handler to a delegate compatible
            with the underlying .NET event. The resulting delegate is used in calls to the 
            <paramref name="addHandler" /> and <paramref name="removeHandler" /> action parameters.</param>
      <param name="addHandler">Action that attaches the given event handler to the underlying .NET event.</param>
      <param name="removeHandler">Action that detaches the given event handler from the underlying .NET event.</param>
      <param name="progressConversion">A function used to convert the given progress event handler to a delegate compatible
            with the underlying .NET progress event. The resulting delegate is used in calls to the 
            <paramref name="addProgressHandler" /> and <paramref name="removeProgressHandler" />  action parameters.</param>
      <param name="addProgressHandler">Action that attaches the given progress event handler to the underlying .NET progress event.</param>
      <param name="removeProgressHandler">Action that detaches the given progress event handler from the underlying .NET progress event.</param>
      <param name="start">An action that receives the user token object and begins the asynchronous process.</param>
      <param name="cancel">An action that cancels the asynchronous process when any subscription to the returned 
            observable is disposed.</param>
      <returns>A paired observable sequence of progress notifications on the left and the cached result on the right.</returns>
      <seealso href="http://msdn.microsoft.com/en-us/library/wewwczdw.aspx">
            Event-based Asynchronous Pattern Overview
            </seealso>
      <requires>conversion != null</requires>
      <requires>addHandler != null</requires>
      <requires>removeHandler != null</requires>
      <requires>progressConversion != null</requires>
      <requires>addProgressHandler != null</requires>
      <requires>removeProgressHandler != null</requires>
      <requires>start != null</requires>
      <requires>cancel != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;EventPattern&lt;TProgressEventArgs&gt;, EventPattern&lt;AsyncCompletedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromEventBasedAsyncPattern``4(System.Func{System.EventHandler{``1},``0},System.Action{``0},System.Action{``0},System.Func{System.EventHandler{``3},``2},System.Action{``2},System.Action{``2},System.Action{System.Object},System.Action)">
      <summary>
            Creates a paired observable sequence of progress notifications along with the cached result from an 
            Event-based Asynchronous Pattern (EBAP) implementation.
            </summary>
      <typeparam name="TDelegate">Type of the event's delegate.</typeparam>
      <typeparam name="TEventArgs">Type of the event's arguments.</typeparam>
      <typeparam name="TProgressDelegate">Type of the progress event's delegate.</typeparam>
      <typeparam name="TProgressEventArgs">Type of the progress event's arguments.</typeparam>
      <param name="conversion">A function used to convert the given event handler to a delegate compatible
            with the underlying .NET event. The resulting delegate is used in calls to the 
            <paramref name="addHandler" /> and <paramref name="removeHandler" /> action parameters.</param>
      <param name="addHandler">Action that attaches the given event handler to the underlying .NET event.</param>
      <param name="removeHandler">Action that detaches the given event handler from the underlying .NET event.</param>
      <param name="progressConversion">A function used to convert the given progress event handler to a delegate compatible
            with the underlying .NET progress event. The resulting delegate is used in calls to the 
            <paramref name="addProgressHandler" /> and <paramref name="removeProgressHandler" />  action parameters.</param>
      <param name="addProgressHandler">Action that attaches the given progress event handler to the underlying .NET progress event.</param>
      <param name="removeProgressHandler">Action that detaches the given progress event handler from the underlying .NET progress event.</param>
      <param name="start">An action that receives the user token object and begins the asynchronous process.</param>
      <param name="cancel">An action that cancels the asynchronous process when any subscription to the returned 
            observable is disposed.</param>
      <returns>A paired observable sequence of progress notifications on the left and the cached result on the right.</returns>
      <seealso href="http://msdn.microsoft.com/en-us/library/wewwczdw.aspx">
            Event-based Asynchronous Pattern Overview
            </seealso>
      <requires>conversion != null</requires>
      <requires>addHandler != null</requires>
      <requires>removeHandler != null</requires>
      <requires>progressConversion != null</requires>
      <requires>addProgressHandler != null</requires>
      <requires>removeProgressHandler != null</requires>
      <requires>start != null</requires>
      <requires>cancel != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;EventPattern&lt;TProgressEventArgs&gt;, EventPattern&lt;TEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromPropertyChangedPattern``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>
            Creates an observable sequence of property changed notifications for the specified 
            <paramref name="property" /> on the specified <paramref name="source" />.
            </summary>
      <typeparam name="TSource">Type of the object that defines the specified <paramref name="property" />.</typeparam>
      <typeparam name="TValue">Type of the property's value.</typeparam>
      <param name="source">The object that defines the specified <paramref name="property" />.</param>
      <param name="property">The property on the specified <paramref name="source" /> from which to generate property changed notifications.</param>
      <remarks>
            The following property changed notification patterns are supported: 
            <list type="bullet"><item><see cref="T:System.ComponentModel.INotifyPropertyChanged" /> implementations.</item><item>[Property]Changed event pattern.</item><item>WPF dependency properties.</item></list></remarks>
      <returns>An observable sequence of property changed notifications.</returns>
      <requires>source != null</requires>
      <requires>property != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Introspect``1(System.IObservable{``0})">
      <summary>
            Pairs the specified observable sequence with an observable for each value that indicates 
            the duration of the observation of that value.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence to introspect.</param>
      <returns>A paired observable with the left channel providing introspection windows and the 
            right channel providing values from the specified observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;IObservable&lt;TSource&gt;, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Introspect``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Pairs the specified observable sequence with an observable for each value that indicates 
            the duration of the observation of that value.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence to introspect.</param>
      <param name="scheduler">Schedules the observations of values in the right notification channel.</param>
      <returns>A paired observable with the left channel providing introspection windows and the 
            right channel providing values from the specified observable.</returns>
      <requires>source != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;IObservable&lt;TSource&gt;, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.WindowIntrospective``1(System.IObservable{``0})">
      <summary>
            Generates a sequence of windows where each window contains all values that were observed from 
            the <paramref name="source" /> while the values in the previous window were being observed.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence from which to create introspection windows.</param>
      <returns>The source observable sequence buffered into introspection windows.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IObservable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.WindowIntrospective``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Generates a sequence of windows where each window contains all values that were observed from 
            the <paramref name="source" /> while the values in the previous window were being observed.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence from which to create introspection windows.</param>
      <param name="scheduler">Schedules when windows are observed as well as the values in each window.</param>
      <returns>The source observable sequence buffered into introspection windows.</returns>
      <requires>source != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IObservable&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.BufferIntrospective``1(System.IObservable{``0})">
      <summary>
            Generates a sequence of lists where each list contains all values that were observed from 
            the <paramref name="source" /> while the previous list was being observed.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence from which to create introspection lists.</param>
      <returns>The source observable sequence buffered into introspection lists.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IList&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.BufferIntrospective``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Generates a sequence of lists where each list contains all values that were observed from 
            the <paramref name="source" /> while the previous list was being observed.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable sequence from which to create introspection lists.</param>
      <param name="scheduler">Schedules when lists are observed.</param>
      <returns>The source observable sequence buffered into introspection lists.</returns>
      <requires>source != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IList&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Maybe``1(System.IObservable{``0})">
      <summary>
            Returns the elements of the specified sequence as a sequence of <see cref="T:System.Maybe`1" />, 
            starting with <see cref="M:System.Maybe.Empty``1" />.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be projected into <see cref="T:System.Maybe`1" /> values.</param>
      <returns>A sequence m <see cref="T:System.Maybe`1" /> values that contain the values from the specified
            observable, starting with <see cref="M:System.Maybe.Empty``1" />.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Maybe&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Multicast``2(System.IObservable{``0},System.Func{System.Reactive.Subjects.ISubject{``0,``1}})">
      <summary>
            Returns a connectable observable sequence that upon connection causes the <paramref name="source" /> sequence to 
            push results into a new fresh subject, which is created by invoking the specified <paramref name="factory" /> function 
            each time that a connection is disposed and a new connection is made.
            </summary>
      <typeparam name="TSource">The type of the source.</typeparam>
      <typeparam name="TResult">The type of the result.</typeparam>
      <param name="source">The source sequence whose elements will be pushed into the specified subject.</param>
      <param name="factory">The factory function used to create the subject that notifications will be pushed into.</param>
      <returns>A connectable observable sequence that upon connection causes the source sequence to push results into a new subject.</returns>
      <requires>source != null</requires>
      <requires>factory != null</requires>
      <ensures>Contract.Result&lt;IConnectableObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.AsPairedObservable``2(System.IObservable{System.Either{``0,``1}})">
      <summary>
            Converts the specified observable sequence of <see cref="T:System.Either`2" /> into
            an <see cref="T:System.Reactive.IPairedObservable`2" />.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable sequence to convert.</param>
      <returns>The specified observable sequence as a paired observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pair``2(System.IObservable{``0},System.Func{``0,``1})">
      <summary>
            Creates a paired observable from the specified observable sequence and selector function.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="leftSource">The observable sequence that provides notifications for the left channel.</param>
      <param name="rightSelector">Selects a value for the right channel from each value in the specified observable sequence.</param>
      <returns>The specified observable sequence paired with the values produced by the selector.</returns>
      <requires>leftSource != null</requires>
      <requires>rightSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pair``2(System.IObservable{``0},System.IObservable{``1})">
      <summary>
            Creates a paired observable by combining the latest values of the specified observable sequences.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="leftSource">The observable sequence that provides notifications for the left channel.</param>
      <param name="rightSource">The observable sequence that provides notifications for the right channel.</param>
      <returns>The latest vlaues of both observable sequences paired together.</returns>
      <requires>leftSource != null</requires>
      <requires>rightSource != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pair``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,``1,System.Reactive.Linq.PairDirection})">
      <summary>
            Creates a paired observable by combining the latest values of the specified observable sequences
            and choosing which channels will receive values based on the specified selector.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="leftSource">The observable sequence that provides notifications for the left channel.</param>
      <param name="rightSource">The observable sequence that provides notifications for the right channel.</param>
      <param name="directionSelector">Selects the channels that will receive notifications for every pair.</param>
      <returns>The specified observable sequences paired together and modified by the specified selector.</returns>
      <requires>leftSource != null</requires>
      <requires>rightSource != null</requires>
      <requires>directionSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pair``1(System.IObservable{``0},System.Func{``0,System.Reactive.Linq.PairDirection})">
      <summary>
            Creates a paired observable from the specified observable sequence by choosing which channels 
            will receive each value based on the specified selector function.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable from which values will be paired based on the specified selector function.</param>
      <param name="directionSelector">Selects the channels that will receive notifications for every value in the <paramref name="source" />.</param>
      <returns>A paired observable sequence projected from the specified observable sequence based on the specified selector function.</returns>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Prime``1(System.Reactive.Subjects.IConnectableObservable{``0})">
      <summary>
            Connects the specified connectable observable sequence upon the first subscription and never disconnects.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The connectable observable sequence to be connected upon the first subscription.</param>
      <remarks>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>The specified observable sequence primed for use.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Prime``1(System.Reactive.Subjects.IConnectableObservable{``0},System.Action{System.IDisposable})">
      <summary>
            Connects the specified connectable observable sequence upon the first subscription and provides 
            the ability to disconnect to a callback.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The connectable observable sequence to be connected upon the first subscription.</param>
      <param name="whenConnected">Receives the subscription each time the observable is connected.</param>
      <remarks>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>The specified observable sequence primed for use.</returns>
      <requires>source != null</requires>
      <requires>whenConnected != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.StartPrimed(System.Action)">
      <summary>
            Invokes the specified <paramref name="action" /> asynchronously upon the first subscription to the returned observable.
            </summary>
      <param name="action">The action to be invoked upon the first subscription.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.StartPrimed(System.Action)" /> differs from <see cref="M:System.Reactive.Linq.Observable.Start(System.Action)" /> in that the former
            does not call the action until the first subscription, although the observable remains hot for subsequent 
            subscriptions.
            </para>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>An observable sequence primed to call the specified <paramref name="action" /> upon the first subscription.</returns>
      <requires>action != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.StartPrimed(System.Action,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Invokes the specified <paramref name="action" /> asynchronously upon the first subscription to the returned observable.
            </summary>
      <param name="action">The action to be invoked upon the first subscription.</param>
      <param name="scheduler">Schedules the call to the action.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.StartPrimed(System.Action)" /> differs from <see cref="M:System.Reactive.Linq.Observable.Start(System.Action)" /> in that the former
            does not call the action until the first subscription, although the observable remains hot for subsequent 
            subscriptions.
            </para>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>An observable sequence primed to call the specified <paramref name="action" /> upon the first subscription.</returns>
      <requires>action != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.StartPrimed``1(System.Func{``0})">
      <summary>
            Invokes the specified <paramref name="function" /> asynchronously upon the first subscription to the returned observable.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="function">The function to be invoked upon the first subscription.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.StartPrimed``1(System.Func{``0})" /> differs from <see cref="M:System.Reactive.Linq.Observable.Start``1(System.Func{``0})" /> in that the former
            does not call the function until the first subscription, although the observable remains hot for subsequent 
            subscriptions.
            </para>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>An observable sequence primed to call the specified <paramref name="function" /> upon the first subscription.</returns>
      <requires>function != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;Unit&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.StartPrimed``1(System.Func{``0},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Invokes the specified <paramref name="function" /> asynchronously upon the first subscription to the returned observable.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="function">The function to be invoked upon the first subscription.</param>
      <param name="scheduler">Schedules the call to the function.</param>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.StartPrimed``1(System.Func{``0})" /> differs from <see cref="M:System.Reactive.Linq.Observable.Start``1(System.Func{``0})" /> in that the former
            does not call the function until the first subscription, although the observable remains hot for subsequent 
            subscriptions.
            </para>
        <para>
            It may be easier to think of priming as creating a warm observable, instead of a cold or hot observable.
            A cold observable allows subscription side-effects to occur each time, whereas a hot observable does not.
            A hot observable is already active before the first subscription, whereas a warm observable is not.
            </para>
      </remarks>
      <returns>An observable sequence primed to call the specified <paramref name="function" /> upon the first subscription.</returns>
      <requires>function != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Consume``2(System.IObservable{``0},System.Func{``0,System.Maybe{``1}})">
      <summary>
            Generates a sequence using the producer/consumer pattern by iteratively calling a consumer function when data is available.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TResult">The type of the data in the generated sequence.</typeparam>
      <param name="source">Indicates when data becomes available from one or more producers.</param>
      <param name="consumeNext">A function that is called iteratively to generate values from out-of-band data.</param>
      <remarks>
        <para>
            The purpose of the <paramref name="source" /> sequence is simply to notify the consumer when data becomes available in
            out-of-band storage.  The data in the <paramref name="source" /> sequence provides additional information to the consumer, 
            but it does not have to be the actual data produced for the consumer.
            </para>
        <para>
            The <paramref name="consumeNext" /> function is called iteratively when data becomes available, until it returns 
            <see cref="M:System.Maybe.Empty``1" />.  All non-empty values that are returned are concatenated into the generated sequence.
            </para>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Consume``2(System.IObservable{``0},System.Func{``0,System.Maybe{``1}})" /> ensures that there 
            is always one active iterator over the <paramref name="consumeNext" /> function when the <paramref name="source" /> sequence notifies
            that data is available; however, it's not necessarily called for every value in the <paramref name="source" /> sequence.
            It is only called if the previous iteration has completed; otherwise, the current notification is ignored.  This ensures that
            only one consumer is active at any given time, but it also means that the <paramref name="consumeNext" /> function is not guaranteed
            to receive every value in the <paramref name="source" /> sequence; therefore, the <paramref name="consumeNext" /> function must read
            data from out-of-band storage instead; e.g., from a shared stream or queue.
            </para>
        <para>
            The <paramref name="consumeNext" /> function may also be called when data is not available.  For example, if the current consuming 
            iterator completes and additional notifications from the <paramref name="source" /> were received, then <paramref name="consumeNext" />
            is called again to check whether new data was missed.  This avoids a race condition between the <paramref name="source" /> sequence 
            and <paramref name="consumeNext" /> reading shared data.  If no data is available when <paramref name="consumeNext" /> is called, then 
            <see cref="M:System.Maybe.Empty``1" /> should be returned and <paramref name="consumeNext" /> will not be called again until another 
            notification is observed from the <paramref name="source" />.
            </para>
        <alert type="tip">
            Producers and the single active consumer are intended to access shared objects concurrently, yet it remains their responsibility
            to ensure thread-safety.  The <strong>Consume</strong> operator cannot do so without breaking concurrency.  For example, a producer/consumer
            implementation that uses an in-memory queue must manually ensure that reads and writes to the queue are thread-safe.
            </alert>
        <para>
            Multiple producers are supported.  Simply create an observable sequence for each producer that notifies when data is generated, 
            merge them together using the <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}})" /> operator, and use the merged
            observable as the <paramref name="source" /> argument in the <strong>Consume</strong> operator.
            </para>
        <para>
            Multiple consumers are supported by calling <strong>Consume</strong> once and then calling <see cref="M:System.IObservable`1.Subscribe(System.IObserver{`0})" />
            multiple times on the <em>cold</em> observable that is returned.  Just be sure that the <paramref name="source" /> sequence is 
            <em>hot</em> so that each subscription will consume based on the same producers' notifications.
            </para>
      </remarks>
      <returns>An observable sequence that is the concatenation of the values returned by the <paramref name="consumeNext" /> function.</returns>
      <requires>source != null</requires>
      <requires>consumeNext != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Consume``2(System.IObservable{``0},System.Func{``0,System.Maybe{``1}},System.Reactive.Concurrency.IScheduler)">
      <summary>
            Generates a sequence using the producer/consumer pattern by iteratively calling a consumer function on the specified 
            <paramref name="scheduler" /> when data is available.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TResult">The type of the data in the generated sequence.</typeparam>
      <param name="source">Indicates when data becomes available from one or more producers.</param>
      <param name="consumeNext">A function that is called iteratively to generate values from out-of-band data.</param>
      <param name="scheduler">An object that schedules iteration over the <paramref name="consumeNext" /> function.</param>
      <remarks>
        <para>
            The purpose of the <paramref name="source" /> sequence is simply to notify the consumer when data becomes available in
            out-of-band storage.  The data in the <paramref name="source" /> sequence provides additional information to the consumer, 
            but it does not have to be the actual data produced for the consumer.
            </para>
        <para>
            The <paramref name="consumeNext" /> function is called iteratively when data becomes available, until it returns 
            <see cref="M:System.Maybe.Empty``1" />.  All non-empty values that are returned are concatenated into the generated sequence.
            </para>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Consume``2(System.IObservable{``0},System.Func{``0,System.Maybe{``1}},System.Reactive.Concurrency.IScheduler)" /> ensures that there 
            is always one active iterator over the <paramref name="consumeNext" /> function when the <paramref name="source" /> sequence notifies
            that data is available; however, it's not necessarily called for every value in the <paramref name="source" /> sequence.
            It is only called if the previous iteration has completed; otherwise, the current notification is ignored.  This ensures that
            only one consumer is active at any given time, but it also means that the <paramref name="consumeNext" /> function is not guaranteed
            to receive every value in the <paramref name="source" /> sequence; therefore, the <paramref name="consumeNext" /> function must read
            data from out-of-band storage instead; e.g., from a shared stream or queue.
            </para>
        <para>
            The <paramref name="consumeNext" /> function may also be called when data is not available.  For example, if the current consuming 
            iterator completes and additional notifications from the <paramref name="source" /> were received, then <paramref name="consumeNext" />
            is called again to check whether new data was missed.  This avoids a race condition between the <paramref name="source" /> sequence 
            and <paramref name="consumeNext" /> reading shared data.  If no data is available when <paramref name="consumeNext" /> is called, then 
            <see cref="M:System.Maybe.Empty``1" /> should be returned and <paramref name="consumeNext" /> will not be called again until another 
            notification is observed from the <paramref name="source" />.
            </para>
        <alert type="tip">
            Producers and the single active consumer are intended to access shared objects concurrently, yet it remains their responsibility
            to ensure thread-safety.  The <strong>Consume</strong> operator cannot do so without breaking concurrency.  For example, a producer/consumer
            implementation that uses an in-memory queue must manually ensure that reads and writes to the queue are thread-safe.
            </alert>
        <para>
            Multiple producers are supported.  Simply create an observable sequence for each producer that notifies when data is generated, 
            merge them together using the <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}})" /> operator, and use the merged
            observable as the <paramref name="source" /> argument in the <strong>Consume</strong> operator.
            </para>
        <para>
            Multiple consumers are supported by calling <strong>Consume</strong> once and then calling <see cref="M:System.IObservable`1.Subscribe(System.IObserver{`0})" />
            multiple times on the <em>cold</em> observable that is returned.  Just be sure that the <paramref name="source" /> sequence is 
            <em>hot</em> so that each subscription will consume based on the same producers' notifications.
            </para>
      </remarks>
      <returns>An observable sequence that is the concatenation of the values returned by the <paramref name="consumeNext" /> function.</returns>
      <requires>source != null</requires>
      <requires>consumeNext != null</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Consume``2(System.IObservable{``0},System.IObservable{``1})">
      <summary>
            Generates a sequence using the producer/consumer pattern.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TResult">The type of the data in the generated sequence.</typeparam>
      <param name="source">Indicates when data becomes available from one or more producers.</param>
      <param name="consumer">An observable that is generated from out-of-band data.</param>
      <remarks>
        <para>
            The purpose of the <paramref name="source" /> sequence is simply to notify when data becomes available in out-of-band storage.
            The data in the <paramref name="source" /> sequence is ignored.
            </para>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Consume``2(System.IObservable{``0},System.IObservable{``1})" /> ensures that there is always an active 
            subscription to the <paramref name="consumer" /> sequence when the <paramref name="source" /> sequence notifies that data is
            available; however, a new subscription is not necessarily created for every value in the <paramref name="source" /> sequence.
            <see cref="M:System.IObservable`1.Subscribe(System.IObserver{`0})" /> is only called if the previous subscription has completed; otherwise, the current 
            notification is ignored.  This ensures that only one consumer is active at any given time and that all available data has a 
            chance to be read.
            </para>
        <para>
            A new subscription may also be created when data is not available.  For example, if the current subscription completes and 
            additional notifications from the <paramref name="source" /> were received, then another subscription is created to check whether
            new data was missed.  This avoids a race condition between the <paramref name="source" /> sequence and the consumer's completion 
            notification.  If no data is available for the new subscription, then an empty sequence should be generated and a new subscription
            will not be created again until another notification is observed from the <paramref name="source" />.
            </para>
        <alert type="tip">
            Producers and the single active consumer are intended to access shared objects concurrently, yet it remains their responsibility
            to ensure thread-safety.  The <strong>Consume</strong> operator cannot do so without breaking concurrency.  For example, a producer/consumer
            implementation that uses an in-memory queue must manually ensure that reads and writes to the queue are thread-safe.
            </alert>
        <para>
            Multiple producers are supported.  Simply create an observable sequence for each producer that notifies when data is generated, 
            merge them together using the <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}})" /> operator, and use the merged
            observable as the <paramref name="source" /> argument in the <strong>Consume</strong> operator.
            </para>
        <para>
            Multiple consumers are supported by calling <strong>Consume</strong> once and then calling <see cref="M:System.IObservable`1.Subscribe(System.IObserver{`0})" />
            multiple times on the <em>cold</em> observable that is returned.  Just be sure that the <paramref name="source" /> sequence is 
            <em>hot</em> so that each subscription will consume based on the same producers' notifications.
            </para>
      </remarks>
      <returns>An observable sequence that is the concatenation of all subscriptions to the <paramref name="consumer" /> observable.</returns>
      <requires>source != null</requires>
      <requires>consumer != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Consume``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}})">
      <summary>
            Generates a sequence using the producer/consumer pattern.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TResult">The type of the data in the generated sequence.</typeparam>
      <param name="source">Indicates when data becomes available from one or more producers.</param>
      <param name="consumerSelector">A function that generates an observable sequence from out-of-band data.</param>
      <remarks>
        <para>
            The purpose of the <paramref name="source" /> sequence is simply to notify the consumer when out-of-band data becomes available.
            The data in the <paramref name="source" /> sequence provides additional information to the <paramref name="consumerSelector" /> function, 
            but it does not have to be the actual data being produced.
            </para>
        <para>
            The <paramref name="consumerSelector" /> function is not necessarily called for every value in the <paramref name="source" /> sequence.
            It is only called if the previous consumer's observable has completed; otherwise, the current notification is ignored.  This ensures 
            that only one consumer is active at any given time, but it also means that the <paramref name="consumerSelector" /> function is not guaranteed
            to receive every value in the <paramref name="source" /> sequence; therefore, the <paramref name="consumerSelector" /> function must read
            data from out-of-band storage instead; e.g., from a shared stream or queue.
            </para>
        <para>
            The <paramref name="consumerSelector" /> function may also be called when data is not available.  For example, if the current consuming 
            observable completes and additional notifications from the <paramref name="source" /> were received, then <paramref name="consumerSelector" />
            is called again to check whether new data was missed.  This avoids a race condition between the <paramref name="source" /> sequence 
            and the consuming observable's completion notification.  If no data is available when <paramref name="consumerSelector" /> is called, then 
            an empty sequence should be returned and <paramref name="consumerSelector" /> will not be called again until another notification is observed 
            from the <paramref name="source" />.
            </para>
        <alert type="tip">
            Producers and the single active consumer are intended to access shared objects concurrently, yet it remains their responsibility
            to ensure thread-safety.  The <strong>Consume</strong> operator cannot do so without breaking concurrency.  For example, 
            a producer/consumer implementation that uses an in-memory queue must manually ensure that reads and writes to the queue are thread-safe.
            </alert>
        <para>
            Multiple producers are supported.  Simply create an observable sequence for each producer that notifies when data is generated, 
            merge them together using the <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}})" /> operator, and use the merged
            observable as the <paramref name="source" /> argument in the <strong>Consume</strong> operator.
            </para>
        <para>
            Multiple consumers are supported by calling <strong>Consume</strong> once and then calling <see cref="M:System.IObservable`1.Subscribe(System.IObserver{`0})" />
            multiple times on the <em>cold</em> observable that is returned.  Just be sure that the <paramref name="source" /> sequence is 
            <em>hot</em> so that each subscription will consume based on the same producers' notifications.
            </para>
      </remarks>
      <returns>An observable sequence that is the concatenation of the sequences returned by <paramref name="consumerSelector" />.</returns>
      <requires>source != null</requires>
      <requires>consumerSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.AsInterval``1(System.IObservable{``0},System.TimeSpan)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="minimumPeriod">The minimum amount of time to delay before the first element 
            and between elements.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.</returns>
      <requires>source != null</requires>
      <requires>minimumPeriod &gt;= TimeSpan.Zero</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.AsInterval``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="minimumPeriod">The minimum amount of time to delay before the first element 
            and between elements.</param>
      <param name="scheduler">An object used to schedule notifications.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.</returns>
      <requires>source != null</requires>
      <requires>minimumPeriod &gt;= TimeSpan.Zero</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.AsTimer``1(System.IObservable{``0},System.TimeSpan)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified minimum period
            between elements.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="minimumPeriod">The minimum amount of time to delay between elements.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements.</returns>
      <requires>source != null</requires>
      <requires>minimumPeriod &gt;= TimeSpan.Zero</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.AsTimer``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified minimum period
            between elements.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="minimumPeriod">The minimum amount of time to delay between elements.</param>
      <param name="scheduler">An object used to schedule notifications.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements.</returns>
      <requires>source != null</requires>
      <requires>minimumPeriod &gt;= TimeSpan.Zero</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pulse``1(System.IObservable{``0},System.TimeSpan)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified <paramref name="period" />, 
            with the latest value repeated when the specified sequence is silent for longer than the specified 
            <paramref name="period" />.
            </summary>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Pulse``1(System.IObservable{``0},System.TimeSpan)" /> is similar to <see cref="M:System.Reactive.Linq.Observable2.AsTimer``1(System.IObservable{``0},System.TimeSpan)" />
            in that it begins without delaying as soon as the first value is observed; however, it differs in that the 
            <paramref name="period" /> between notifications is constant and the last value is repeated at the specified interval 
            while the observable is silent.
            </para>
        <alert type="tip">
            To achieve a pulse without duplicate values, pass the returned observable to Observable.DistinctUntilChanged.
            </alert>
      </remarks>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="period">The exact amount of time to delay between elements.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.</returns>
      <requires>source != null</requires>
      <requires>period &gt;= TimeSpan.Zero</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Pulse``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
      <summary>
            Returns the elements of the specified sequence time-shifted to the specified <paramref name="period" />, 
            with the latest value repeated when the specified sequence is silent for longer than the specified 
            <paramref name="period" />.
            </summary>
      <remarks>
        <para>
          <see cref="M:System.Reactive.Linq.Observable2.Pulse``1(System.IObservable{``0},System.TimeSpan)" /> is similar to <see cref="M:System.Reactive.Linq.Observable2.AsTimer``1(System.IObservable{``0},System.TimeSpan)" />
            in that it begins without delaying as soon as the first value is observed; however, it differs in that the 
            <paramref name="period" /> between notifications is constant and the last value is repeated at the specified interval 
            while the observable is silent.
            </para>
        <alert type="tip">
            To achieve a pulse without duplicate values, pass the returned observable to Observable.DistinctUntilChanged.
            </alert>
      </remarks>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="source">The observable to be time-shifted.</param>
      <param name="period">The exact amount of time to delay between elements.</param>
      <param name="scheduler">An object used to schedule notifications.</param>
      <returns>The specified observable sequence time-shifted to the specified minimum period
            between elements, starting with the specified minimum period.</returns>
      <requires>source != null</requires>
      <requires>period &gt;= TimeSpan.Zero</requires>
      <requires>scheduler != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.TimeShift``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}})">
      <summary>
            Time-shifts each value in the specified observable sequence to a sequence returned by the specified selector
            and concatenates the timer sequences returned by the selector.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TTimer">Type of the timer notifications.</typeparam>
      <param name="source">The observable sequence to be time-shifted.</param>
      <param name="timeSelector">Selects an observable sequence that indicates when the current value should be pushed.</param>
      <returns>The specified observable sequence time-shifted to the concatenated timer sequences returned by the selector.</returns>
      <requires>source != null</requires>
      <requires>timeSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.TimeShift``2(System.IObservable{``0},System.IObservable{``1})">
      <summary>
            Time-shifts each value in the specified observable sequence to the specified <paramref name="timer" />.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TTimer">Type of the timer notifications.</typeparam>
      <param name="source">The observable sequence to be time-shifted.</param>
      <param name="timer">The observable sequence to which the values from the source sequence are time-shifted.</param>
      <returns>The specified observable sequence time-shifted to the specified <paramref name="timer" /> sequence.</returns>
      <requires>source != null</requires>
      <requires>timer != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Zip``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
      <summary>
            Merges two or more observable sequences into one observable sequence of lists by combining their elements in a pairwise fashion.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sources">An enumerable sequence containing two or more observable sequences to be merged.</param>
      <remarks>
        <para>
            All of the observable sequences must produce at least one element; otherwise, the generated sequence will be empty.  Furthermore, if an observable 
            sequence produces more than one element before each of the other observable sequences have produced their first elements, then all of the elements 
            will be enqueued for future pairing.  No elements are discarded.
            </para>
        <para>
            The latest value of an observable sequence is always located in the generated lists at the same index in which that sequence is located in the outer sequence.
            For example, the values from the first observable sequence in the outer sequence will always be at index zero (0) in the lists that are generated.
            </para>
      </remarks>
      <returns>An observable sequence containing the result of pairwise combining the elements of all sources into lists.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IList&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Zip``1(System.IObservable{System.IObservable{``0}})">
      <summary>
            Merges two or more observable sequences into one observable sequence of lists by combining their elements in a pairwise fashion.
            </summary>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <param name="sources">An observable sequence containing two or more observable sequences to be merged.</param>
      <remarks>
        <para>
            All of the observable sequences must produce at least one element; otherwise, the generated sequence will be empty.  Furthermore, if an observable 
            sequence produces more than one element before each of the other observable sequences have produced their first elements, then all of the elements 
            will be enqueued for future pairing.  No elements are discarded.
            </para>
        <para>
            The latest value of an observable sequence is always located in the generated lists at the same index in which that sequence is located in the outer sequence.
            For example, the values from the first observable sequence in the outer sequence will always be at index zero (0) in the lists that are generated.
            </para>
      </remarks>
      <returns>An observable sequence containing the result of pairwise combining the elements of all sources into lists.</returns>
      <requires>sources != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IList&lt;TSource&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Cast``2(System.IObservable{``0})">
      <summary>
            Converts the elements of an observable sequence to the specified type.
            </summary>
      <remarks>
            The existing <see cref="M:System.Reactive.Linq.Observable.Cast``1(System.IObservable{System.Object})" /> operator only works on observable sequences of <see cref="T:System.Object" />.
            In Windows Phone, since <see cref="T:System.IObservable`1" /> isn't covariant on <em>T</em>, sometimes casting is required between 
            strongly-typed sequences of data to work correctly with certain operators.  <see cref="M:System.Reactive.Linq.Observable2.Cast``2(System.IObservable{``0})" /> facilitates 
            this need.
            </remarks>
      <typeparam name="TSource">The object that provides notification information.</typeparam>
      <typeparam name="TResult">The type to which each object in the observable sequence is cast.</typeparam>
      <param name="source">The observable containing the values to be cast.</param>
      <returns>An observable sequence containing the elements of the source observable cast to the specified type.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.Linq.OperationalObservable">
      <summary>
            Provides extension methods that convert an <see cref="T:System.IObservable`1" /> into an <see cref="T:System.Reactive.OperationalObservable`2" />.
            </summary>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.SByte})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.SByte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.SByte},System.Func{System.IObservable{System.SByte},System.IObservable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.SByte},System.Func{System.IObservable{System.SByte},System.IObservable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.SByte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Reactive.OperationalObservable`2" />.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Byte})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Byte},System.Func{System.IObservable{System.Byte},System.IObservable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Byte},System.Func{System.IObservable{System.Byte},System.IObservable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Byte" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Reactive.OperationalObservable`2" />.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Char})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Char},System.Func{System.IObservable{System.Char},System.IObservable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Char},System.Func{System.IObservable{System.Char},System.IObservable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Char" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Reactive.OperationalObservable`2" />.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int16})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int16},System.Func{System.IObservable{System.Int16},System.IObservable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int16},System.Func{System.IObservable{System.Int16},System.IObservable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Reactive.OperationalObservable`2" />.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt16})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt16},System.Func{System.IObservable{System.UInt16},System.IObservable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt16},System.Func{System.IObservable{System.UInt16},System.IObservable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt16" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="resultBinaryOperation">The join behavior for binary operations on the resulting <see cref="T:System.Reactive.OperationalObservable`2" />.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <requires>resultBinaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int32" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int32" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt32})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt32" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt32},System.Func{System.IObservable{System.UInt32},System.IObservable{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32},System.IObservable{System.UInt32}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt32" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int64})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int64" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int64},System.Func{System.IObservable{System.Int64},System.IObservable{System.Int64},System.Func{System.Int64,System.Int64,System.Int64},System.IObservable{System.Int64}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Int64" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt64})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt64" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.UInt64},System.Func{System.IObservable{System.UInt64},System.IObservable{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64},System.IObservable{System.UInt64}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.UInt64" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Single})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Single" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Single},System.Func{System.IObservable{System.Single},System.IObservable{System.Single},System.Func{System.Single,System.Single,System.Single},System.IObservable{System.Single}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Single" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Double})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Double" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Double},System.Func{System.IObservable{System.Double},System.IObservable{System.Double},System.Func{System.Double,System.Double,System.Double},System.IObservable{System.Double}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Double" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Decimal})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Decimal" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Decimal},System.Func{System.IObservable{System.Decimal},System.IObservable{System.Decimal},System.Func{System.Decimal,System.Decimal,System.Decimal},System.IObservable{System.Decimal}})">
      <summary>
            Creates a standard <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <see cref="T:System.Decimal" /><paramref name="source" />.
            </summary>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>binaryOperation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational``1(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``0},System.Func{``0,``0,``0},System.IObservable{``0}},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0,``0},System.Func{``0,``0},System.Func{``0,``0})">
      <summary>
            Creates an <see cref="T:System.Reactive.OperationalObservable`1" /> for the specified <paramref name="source" /> from the specified operators.
            </summary>
      <typeparam name="T">The type of objects to observe.</typeparam>
      <param name="source">The observable to be converted.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="add">The addition operator.</param>
      <param name="subtract">The subtraction operator.</param>
      <param name="multiply">The multiplication operator.</param>
      <param name="divide">The division operator.</param>
      <param name="positive">The plus operator.</param>
      <param name="negative">The negation operator.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`1" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;T&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperational``2(System.IObservable{``0},System.Func{System.IObservable{``1},System.Reactive.OperationalObservable{``1}},System.Func{System.IObservable{``0},System.IObservable{``0},System.Func{``0,``0,``1},System.IObservable{``1}},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``0,``1},System.Func{``0,``1},System.Func{``0,``1})">
      <summary>
            Creates an <see cref="T:System.Reactive.OperationalObservable`2" /> for the specified <paramref name="source" /> from the specified operators.
            </summary>
      <typeparam name="TIn">The type of input to observe.</typeparam>
      <typeparam name="TOut">The type of output that each operation generates.</typeparam>
      <param name="source">The observable to be converted.</param>
      <param name="resultSelector">Projects the result sequence into an <see cref="T:System.Reactive.OperationalObservable`1" />.</param>
      <param name="binaryOperation">The join behavior for binary operations.</param>
      <param name="add">The addition operator.</param>
      <param name="subtract">The subtraction operator.</param>
      <param name="multiply">The multiplication operator.</param>
      <param name="divide">The division operator.</param>
      <param name="positive">The plus operator.</param>
      <param name="negative">The negation operator.</param>
      <returns>An <see cref="T:System.Reactive.OperationalObservable`2" /> that applies the specified operations to the specified <paramref name="source" /> 
            when combined with another observable.</returns>
      <requires>source != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TIn, TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.Linq.PairDirection">
      <summary>
            Indicates whether an observed value being projected into an <see cref="T:System.Reactive.IPairedObservable`2" /> is a
            left value, right value, neither or both.
            </summary>
    </member>
    <member name="F:System.Reactive.Linq.PairDirection.Neither">
      <summary>
            The value is excluded.
            </summary>
    </member>
    <member name="F:System.Reactive.Linq.PairDirection.Left">
      <summary>
            The value is for the left channel.
            </summary>
    </member>
    <member name="F:System.Reactive.Linq.PairDirection.Right">
      <summary>
            The value is for the right channel.
            </summary>
    </member>
    <member name="F:System.Reactive.Linq.PairDirection.Both">
      <summary>
            Ths value is for both the left and right channels.
            </summary>
    </member>
    <member name="T:System.Reactive.Linq.PairedObservable">
      <summary>
            Provides extension and factory methods for <see cref="T:System.Reactive.IPairedObservable`2" />.
            </summary>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.Combine``3(System.IObservable{System.Either{``0,``1}},System.Func{``0,``1,``2})">
      <summary>
            Combines the latest values from both notification channels and projects the results into a new sequence.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <typeparam name="TResult">Type of the result.</typeparam>
      <param name="source">The observable from which values are combined.</param>
      <param name="selector">Combines values from both notification channels.</param>
      <remarks>
        <see cref="M:System.Reactive.Linq.PairedObservable.Combine``3(System.IObservable{System.Either{``0,``1}},System.Func{``0,``1,``2})" /> is similar to <see cref="M:System.Reactive.Linq.Observable.CombineLatest``3(System.IObservable{``0},System.IObservable{``1},System.Func{``0,``1,``2})" />.
            </remarks>
      <returns>An observable of results from the combination of the latest values in both notification channels.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.Create``2(System.Func{System.Reactive.IPairedObserver{``0,``1},System.Action})">
      <summary>
            Creates a paired observable sequence from the <paramref name="subscribe" /> implementation.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="subscribe">Subscribes observers to the paired observable.</param>
      <returns>A paired observable that calls the specified <paramref name="subscribe" /> function when an observer subscribes.</returns>
      <requires>subscribe != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.Create``2(System.Func{System.Reactive.IPairedObserver{``0,``1},System.IDisposable})">
      <summary>
            Creates a paired observable sequence from the <paramref name="subscribe" /> implementation.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="subscribe">Subscribes observers to the paired observable.</param>
      <returns>A paired observable that calls the specified <paramref name="subscribe" /> function when an observer subscribes.</returns>
      <requires>subscribe != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.ForEachPair``2(System.IObservable{System.Either{``0,``1}},System.Action{``0},System.Action{``1})">
      <summary>
            Invokes the actions for their side-effects on each value in the observable sequence and blocks till the sequence is terminated.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable for which a subscription is created.</param>
      <param name="onNextLeft">The handler of notifications in the left channel.</param>
      <param name="onNextRight">The handler of notifications in the right channel.</param>
      <requires>source != null</requires>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.Select``4(System.IObservable{System.Either{``0,``1}},System.Func{``0,``2},System.Func{``1,``3})">
      <summary>
            Projects the values from both notification channels into a new sequence.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <typeparam name="TLeftResult">Result type of the left notification channel.</typeparam>
      <typeparam name="TRightResult">Result type of the right notification channel.</typeparam>
      <param name="source">The observable from which values are projected.</param>
      <param name="leftSelector">Projects values from the left notification channel.</param>
      <param name="rightSelector">Projects value from the right notification channel.</param>
      <returns>A paired observable of results from the projection of values in both notification channels.</returns>
      <requires>source != null</requires>
      <requires>leftSelector != null</requires>
      <requires>rightSelector != null</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeftResult, TRightResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.SelectLeft``3(System.IObservable{System.Either{``0,``1}},System.Func{``0,``2})">
      <summary>
            Projects the values from the left notification channel into a new sequence.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <typeparam name="TResult">Type of the result.</typeparam>
      <param name="source">The observable from which values are projected.</param>
      <param name="selector">Projects values from the left notification channel.</param>
      <returns>An observable of results from the projection of values in the left notification channel.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.SelectRight``3(System.IObservable{System.Either{``0,``1}},System.Func{``1,``2})">
      <summary>
            Projects the values from the right notification channel into a new sequence.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <typeparam name="TResult">Type of the result.</typeparam>
      <param name="source">The observable from which values are projected.</param>
      <param name="selector">Projects values from the right notification channel.</param>
      <returns>An observable of results from the projection of values in the right notification channel.</returns>
      <requires>source != null</requires>
      <requires>selector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.TakeLeft``2(System.IObservable{System.Either{``0,``1}})">
      <summary>
            Returns an observable that contains only the values from the left notification channel.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable from which values are taken.</param>
      <returns>An observable of values from the left notification channel.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TLeft&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.TakeRight``2(System.IObservable{System.Either{``0,``1}})">
      <summary>
            Returns an observable that contains only the values from the right notification channel.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable from which values are taken.</param>
      <returns>An observable of values from the right notification channel.</returns>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.TakeLeft``2(System.IObservable{System.Either{``0,``1}},System.Int32)">
      <summary>
            Returns an observable that contains only the values from the left notification channel
            up to the specified <paramref name="count" />.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable from which values are taken.</param>
      <param name="count">The number of values to take.</param>
      <returns>An observable of values from the left notification channel.</returns>
      <requires>source != null</requires>
      <requires>count &gt;= 0</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.PairedObservable.TakeRight``2(System.IObservable{System.Either{``0,``1}},System.Int32)">
      <summary>
            Returns an observable that contains only the values from the right notification channel
            up to the specified <paramref name="count" />.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable from which values are taken.</param>
      <param name="count">The number of values to take.</param>
      <returns>An observable of values from the right notification channel.</returns>
      <requires>source != null</requires>
      <requires>count &gt;= 0</requires>
      <ensures>Contract.Result&lt;IPairedObservable&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="F:System.Reactive.ObservableCursor`1.firstElementIndex">
      <summary>
            Stores the index offset, relative to the source sequence, of the first value in the <see cref="F:System.Reactive.ObservableCursor`1.elements" /> list.
            </summary>
      <remarks>
            This field is used as part of a memory optimization in a forward-only cursor that allows elements to be removed
            when the cursor and all dependent branches have moved passed them, consequently offsetting the indexes in the 
            <see cref="F:System.Reactive.ObservableCursor`1.elements" /> list with respect to the actual source sequence.
            </remarks>
    </member>
    <member name="T:System.Reactive.OperationalObservable`2">
      <summary>
            Represents an observable that uses its unary and binary operator overloads as observable query operators.
            </summary>
      <typeparam name="TIn">Input type.</typeparam>
      <typeparam name="TOut">Output type.</typeparam>
      <invariant>source != null</invariant>
      <invariant>resultSelector != null</invariant>
      <invariant>binaryOperation != null</invariant>
      <invariant>add != null</invariant>
      <invariant>subtract != null</invariant>
      <invariant>multiply != null</invariant>
      <invariant>divide != null</invariant>
      <invariant>positive != null</invariant>
      <invariant>negative != null</invariant>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Subscribe(System.IObserver{`0})">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <param name="observer">The object that is to receive notifications.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Addition(System.Reactive.OperationalObservable{`0,`1},System.IObservable{`0})">
      <summary>
            Creates a new operational observable that adds the values in the specified observables 
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first observable.</param>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Add(System.IObservable{`0})">
      <summary>
            Creates a new operational observable that adds the values in this observable to the values in the specified observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Addition(System.Reactive.OperationalObservable{`0,`1},`0)">
      <summary>
            Creates a new operational observable that adds the values in the specified observable to the specified value
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The observable.</param>
      <param name="second">A value that is added to each value in the <paramref name="first" /> observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Add(`0)">
      <summary>
            Creates a new operational observable that adds the values in this observable to the specified <paramref name="value" />.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is added to each value in this observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Subtraction(System.Reactive.OperationalObservable{`0,`1},System.IObservable{`0})">
      <summary>
            Creates a new operational observable that subtracts the values in the specified observables 
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first observable.</param>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Subtract(System.IObservable{`0})">
      <summary>
            Creates a new operational observable that subtracts the values in the specified observable from the values in this observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Subtraction(System.Reactive.OperationalObservable{`0,`1},`0)">
      <summary>
            Creates a new operational observable that subtracts the specified value from the values in the specified observable
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The observable.</param>
      <param name="second">A value that is subtracted from each value in the <paramref name="first" /> observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Subtract(`0)">
      <summary>
            Creates a new operational observable that subtracts the specified value from the values in this observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is subtracted from each value in this observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Multiply(System.Reactive.OperationalObservable{`0,`1},System.IObservable{`0})">
      <summary>
            Creates a new operational observable that multiplies the values in the specified observables 
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first observable.</param>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Multiply(System.IObservable{`0})">
      <summary>
            Creates a new operational observable that multiplies the values in this observable with the values in the specified observable.
            </summary>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Multiply(System.Reactive.OperationalObservable{`0,`1},`0)">
      <summary>
            Creates a new operational observable that multiplies the values in the specified observable by the specified value
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The observable.</param>
      <param name="second">A value that is multiplied against each value in the <paramref name="first" /> observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Multiply(`0)">
      <summary>
            Creates a new operational observable that multiplies the values in the specified observable by the specified <paramref name="value" />.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that is multiplied against each value in this observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Division(System.Reactive.OperationalObservable{`0,`1},System.IObservable{`0})">
      <summary>
            Creates a new operational observable that divides the values in the specified observables 
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The first observable.</param>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Divide(System.IObservable{`0})">
      <summary>
            Creates a new operational observable that divides the values in this observable with the values in the specified observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="second">The second observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>second != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_Division(System.Reactive.OperationalObservable{`0,`1},`0)">
      <summary>
            Creates a new operational observable that divides the values in the specified observable by the specified value
            based on the binary operation logic of the <paramref name="first" /> observable.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="first">The observable.</param>
      <param name="second">A value that divides each value in the <paramref name="first" /> observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>first != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Divide(`0)">
      <summary>
            Creates a new operational observable that divides the values in this observable by the specified <paramref name="value" />.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="value">A value that divides each value in this observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_UnaryPlus(System.Reactive.OperationalObservable{`0,`1})">
      <summary>
            Creates a new operational observable that ensures the sign of the specified observable's values are positive.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="observable">The observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>observable != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Plus">
      <summary>
            Creates a new operational observable that ensures the sign of this observable's values are positive.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.op_UnaryNegation(System.Reactive.OperationalObservable{`0,`1})">
      <summary>
            Creates a new operational observable that ensures the sign of the specified observable's values are negative.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <param name="observable">The observable.</param>
      <returns>An operational observable that generates the output of the operation.</returns>
      <requires>observable != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.Negate">
      <summary>
            Creates a new operational observable that ensures the sign of this observable's values are negative.
            </summary>
      <remarks>
        <alert type="note">
            The actual behavior of this operator is determined by <see cref="M:System.Reactive.Linq.OperationalObservable.AsOperational(System.IObservable{System.Int32})" />.
            </alert>
      </remarks>
      <returns>An operational observable that generates the output of the operation.</returns>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.OperationalObservable`1">
      <summary>
            Represents an observable that uses its unary and binary operator overloads as observable query operators.
            </summary>
      <typeparam name="T">Input and output type.</typeparam>
    </member>
    <member name="T:System.Reactive.PairedObservableExtensions">
      <summary>
            Provides extension methods for <see cref="T:System.Reactive.IPairedObservable`2" />.
            </summary>
    </member>
    <member name="M:System.Reactive.PairedObservableExtensions.SubscribePair``2(System.IObservable{System.Either{``0,``1}},System.Action{``0},System.Action{``1})">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable for which a subscription is created.</param>
      <param name="onNextLeft">The handler of notifications in the left channel.</param>
      <param name="onNextRight">The handler of notifications in the right channel.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>source != null</requires>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObservableExtensions.SubscribePair``2(System.IObservable{System.Either{``0,``1}},System.Action{``0},System.Action{``1},System.Action{System.Exception})">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable for which a subscription is created.</param>
      <param name="onNextLeft">The handler of notifications in the left channel.</param>
      <param name="onNextRight">The handler of notifications in the right channel.</param>
      <param name="onError">The handler of an error notification.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>source != null</requires>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onError != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObservableExtensions.SubscribePair``2(System.IObservable{System.Either{``0,``1}},System.Action{``0},System.Action{``1},System.Action)">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable for which a subscription is created.</param>
      <param name="onNextLeft">The handler of notifications in the left channel.</param>
      <param name="onNextRight">The handler of notifications in the right channel.</param>
      <param name="onCompleted">The handler of a completion notification.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>source != null</requires>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onCompleted != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObservableExtensions.SubscribePair``2(System.IObservable{System.Either{``0,``1}},System.Action{``0},System.Action{``1},System.Action{System.Exception},System.Action)">
      <summary>
            Notifies the observable that an observer is to receive notifications.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="source">The observable for which a subscription is created.</param>
      <param name="onNextLeft">The handler of notifications in the left channel.</param>
      <param name="onNextRight">The handler of notifications in the right channel.</param>
      <param name="onError">The handler of an error notification.</param>
      <param name="onCompleted">The handler of a completion notification.</param>
      <returns>The observer's interface that enables cancelation of the subscription so that it stops receiving notifications.</returns>
      <requires>source != null</requires>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onError != null</requires>
      <requires>onCompleted != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.PairedObserver">
      <summary>
            Provides extension and factory methods for <see cref="T:System.Reactive.IPairedObserver`2" />.
            </summary>
    </member>
    <member name="M:System.Reactive.PairedObserver.Create``2(System.Action{``0},System.Action{``1})">
      <summary>
            Creates an observer that is capable of observing paired observables using the specified actions.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="onNextLeft">Handler for notifications from the left channel.</param>
      <param name="onNextRight">Handler for notifications from the right channel.</param>
      <returns>An observer capable of observing paired observables.</returns>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <ensures>Contract.Result&lt;IPairedObserver&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObserver.Create``2(System.Action{``0},System.Action{``1},System.Action{System.Exception})">
      <summary>
            Creates an observer that is capable of observing paired observables using the specified actions.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="onNextLeft">Handler for notifications from the left channel.</param>
      <param name="onNextRight">Handler for notifications from the right channel.</param>
      <param name="onError">Handler for an error notification.</param>
      <returns>An observer capable of observing paired observables.</returns>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onError != null</requires>
      <ensures>Contract.Result&lt;IPairedObserver&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObserver.Create``2(System.Action{``0},System.Action{``1},System.Action)">
      <summary>
            Creates an observer that is capable of observing paired observables using the specified actions.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="onNextLeft">Handler for notifications from the left channel.</param>
      <param name="onNextRight">Handler for notifications from the right channel.</param>
      <param name="onCompleted">Handler for a completed notification.</param>
      <returns>An observer capable of observing paired observables.</returns>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onCompleted != null</requires>
      <ensures>Contract.Result&lt;IPairedObserver&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.PairedObserver.Create``2(System.Action{``0},System.Action{``1},System.Action{System.Exception},System.Action)">
      <summary>
            Creates an observer that is capable of observing paired observables using the specified actions.
            </summary>
      <typeparam name="TLeft">Type of the left notification channel.</typeparam>
      <typeparam name="TRight">Type of the right notification channel.</typeparam>
      <param name="onNextLeft">Handler for notifications from the left channel.</param>
      <param name="onNextRight">Handler for notifications from the right channel.</param>
      <param name="onError">Handler for an error notification.</param>
      <param name="onCompleted">Handler for a completed notification.</param>
      <returns>An observer capable of observing paired observables.</returns>
      <requires>onNextLeft != null</requires>
      <requires>onNextRight != null</requires>
      <requires>onError != null</requires>
      <requires>onCompleted != null</requires>
      <ensures>Contract.Result&lt;IPairedObserver&lt;TLeft, TRight&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.Subjects.CommandSubject">
      <summary>
            Represents an object that is an <see cref="T:System.Windows.Input.ICommand" />, an observable sequence of execution parameters and 
            an observer of values indicating whether the command can be executed.
            </summary>
      <threadsafety instance="true" />
      <invariant>subject != null</invariant>
      <invariant>canExecuteAnyParameter.HasValue == (canExecute == null)</invariant>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.CommandSubject" /> class that observes notifications indicating 
            whether the command can be executed.  By default, <see cref="M:System.Reactive.Subjects.CommandSubject.CanExecute(System.Object)" /> returns <see langord="true" /> until 
            a notification is observed that sets it to <see langword="false" />.
            </summary>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.#ctor(System.Boolean)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.CommandSubject" /> class that observes notifications indicating 
            whether the command can be executed.
            </summary>
      <param name="defaultCanExecute">The default value to be returned by the <see cref="M:System.Reactive.Subjects.CommandSubject.CanExecute(System.Object)" /> method.</param>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.#ctor(System.Func{System.Object,System.Boolean})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.CommandSubject" /> class that observes notifications indicating 
            whether the specified function should be invoked to determine whether the command can be executed.
            </summary>
      <remarks>
            The actual values of the notifications are ignored.  Essentially, they are treated like <see cref="T:System.Reactive.Unit" />.
            </remarks>
      <param name="canExecute">A function that receives arbitrary data or <see langword="null" /> and returns whether 
            the command can be executed for that data.</param>
      <requires>canExecute != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.AsCommand">
      <summary>
            Returns an <see cref="T:System.Windows.Input.ICommand" /> wrapper for this subject that prevents callers from using it as a subject.
            </summary>
      <returns>An <see cref="T:System.Windows.Input.ICommand" /> wrapper for this subject.</returns>
      <ensures>Contract.Result&lt;ICommand&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.CanExecute(System.Object)">
      <summary>
            Determines whether the command can execute in its current state.
            </summary>
      <param name="parameter">Data used by the command.  If the command does not require data to be passed, this object 
            can be set to <see langword="null" />.</param>
      <returns>
        <see langword="True" /> if this command can be executed; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.Execute(System.Object)">
      <summary>
            Invokes the command.
            </summary>
      <param name="parameter">Data used by the command.  If the command does not require data to be passed, this object 
            can be set to <see langword="null" />.</param>
      <exception cref="T:System.Exception">Throws the exception that was passed to <see cref="M:System.Reactive.Subjects.CommandSubject.OnError(System.Exception)" />.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.Subscribe(System.IObserver{System.Object})">
      <summary>
            Notifies the subject that an observer is to receive notifications when <see cref="M:System.Reactive.Subjects.CommandSubject.Execute(System.Object)" /> is called.
            </summary>
      <param name="observer">The object that is to receive notifications.</param>
      <returns>The observer's interface that enables resources to be disposed.</returns>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.OnNext(System.Boolean)">
      <summary>
            Notifies the command to reevaluate whether it can execute.
            </summary>
      <remarks>
            The behavior of <see cref="M:System.Reactive.Subjects.CommandSubject.OnNext(System.Boolean)" /> differs based on how the <see cref="T:System.Reactive.Subjects.CommandSubject" /> was constructed.
            The <see cref="M:System.Reactive.Subjects.CommandSubject.#ctor(System.Func{System.Object,System.Boolean})" /> constructor causes <see cref="M:System.Reactive.Subjects.CommandSubject.OnNext(System.Boolean)" /> to do nothing but
            raise the <see cref="E:System.Reactive.Subjects.CommandSubject.CanExecuteChanged" /> event, regardless of the specified <paramref name="value" />.
            All other constructors cause <see cref="M:System.Reactive.Subjects.CommandSubject.OnNext(System.Boolean)" /> to set the return value of <see cref="M:System.Reactive.Subjects.CommandSubject.CanExecute(System.Object)" /> to the
            specified <paramref name="value" /> and then it raises the <see cref="E:System.Reactive.Subjects.CommandSubject.CanExecuteChanged" /> event, but only if the
            value has actually changed.
            </remarks>
      <param name="value">If the <see cref="T:System.Reactive.Subjects.CommandSubject" /> was not created by the <see cref="M:System.Reactive.Subjects.CommandSubject.#ctor(System.Func{System.Object,System.Boolean})" />
            constructor, then <see langword="true" /> if the command can be executed or <see langword="false" /> if it cannot; 
            otherwise, this value is ignored.</param>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.OnError(System.Exception)">
      <summary>
            Notifies the subject that the provider has experienced an error condition.
            </summary>
      <param name="exception">An object that provides additional information about the error.</param>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.OnCompleted">
      <summary>
            Notifies the observer that the provider has finished sending push-based notifications.
            </summary>
    </member>
    <member name="M:System.Reactive.Subjects.CommandSubject.Dispose">
      <summary>
            Releases all resources used by an instance of the <see cref="T:System.Reactive.Subjects.CommandSubject" /> class.
            </summary>
    </member>
    <member name="E:System.Reactive.Subjects.CommandSubject.CanExecuteChanged">
      <summary>
            Occurs when changes occur that affect whether or not the command should execute.
            </summary>
      <remarks>
        <see cref="E:System.Reactive.Subjects.CommandSubject.CanExecuteChanged" /> is raised when <see cref="M:System.Reactive.Subjects.CommandSubject.OnNext(System.Boolean)" /> is called and the return value 
            of <see cref="M:System.Reactive.Subjects.CommandSubject.CanExecute(System.Object)" /> may have changed.
            </remarks>
    </member>
    <member name="T:System.Reactive.Subjects.CursorSubject`1">
      <summary>
            Represents an observer and a replaying observable sequence with a current index that can be moved.
            </summary>
      <remarks>
        <para>
            A cursor is a moveable pointer over an immutable sequence.  This differs from the concept of a <see cref="T:System.IO.Stream" />, 
            which is a moveable pointer over a mutable buffer.  Mutability is a key difference; it means that moving the position of a
            stream backward allows you to overwrite the data from that position to the end of the stream, while moving the position of a 
            cursor backward only changes the index in the sequence from which data is replayed to new subscribers.  In other words, data 
            written to a stream is always inserted at the current position, but data observed by a cursor is always appended to the end 
            of the buffered sequence.
            </para>
        <para>
            Furthermore, the position of a stream is shared between reads and writes, but the position of a cursor is not.  A cursor's 
            position is only used by reads (subscribers) and is entirely independent of writes.  Subscribing to a cursor replays the data 
            in the sequence from the current index to the end; however, the current index is not moved at all.  Changing the index later
            has no effect on existing subscriptions, but changing the position of a stream would certainly effect existing readers.
            </para>
        <para>
          <see cref="T:System.Reactive.Subjects.CursorSubject`1" /> provides a superset of the functionality that is provided by <see cref="T:System.Reactive.Subjects.Subject`1" />, 
            <see cref="T:System.Reactive.Subjects.BehaviorSubject`1" /> and <see cref="T:System.Reactive.Subjects.ReplaySubject`1" />.  Each of these subjects could be implemented in terms
            of <see cref="T:System.Reactive.Subjects.CursorSubject`1" /> by moving the <see cref="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex" /> after calling <see cref="M:System.Reactive.Subjects.CursorSubject`1.OnNext(`0)" />, as necessary.
            </para>
      </remarks>
      <typeparam name="T">The object that provides notification information.</typeparam>
      <invariant>gate != null</invariant>
      <invariant>cursor != null</invariant>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.CursorSubject`1" /> class with bidirectional behavior.
            </summary>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.#ctor(System.Boolean)">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.CursorSubject`1" /> class.
            </summary>
      <param name="isForwardOnly">
        <see langword="True" /> if the cursor can only be moved forward; 
            otherwise, <see langword="false" />.</param>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.Subscribe(System.IObserver{`0})">
      <summary>
            Notifies the cursor that an observer is to receive notifications.
            </summary>
      <param name="observer">The object that is to receive notifications.</param>
      <returns>The observer's interface that enables resources to be disposed.</returns>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.Subscribe(System.IObserver{`0},System.Int32)">
      <summary>
            Notifies the provider that an observer is to receive the specified maximum number of <strong>OnNext</strong> notifications.
            </summary>
      <remarks>
        <para>
            This overload to <see cref="M:System.IObservable`1.Subscribe(System.IObserver{`0})" /> behaves similarly except that it has a 
            <paramref name="count" /> parameter that specifies the maximum number of elements that may be pushed to the
            <paramref name="observer" />.  Essentially, it provides an optimized alternative to <see cref="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)" />.
            </para>
        <para>
            The <paramref name="count" /> parameter applies to cursors because they typically will buffer data from the source 
            sequence and replay it to subscribers, starting from the current index and continuing to the latest value that has 
            been buffered.  When a subscriber only wants to view a range of data, then <see cref="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)" /> is often 
            added to the query to specify the number of notifications that are desired; however, the <see cref="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)" /> 
            operator cannot cancel the notifications that are being replayed from the cursor, so it simply drops any additional 
            notifications that exceed the specified limit.  The specified <paramref name="observer" /> will not observe the 
            additional notifications, although the overhead of replaying an entire buffered sequence to the 
            <see cref="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)" /> operator could have a noticeable impact on the performance of your code.  By implementing
            <see cref="M:System.Reactive.Subjects.CursorSubject`1.Subscribe(System.IObserver{`0},System.Int32)" />, replayed notifications can be stopped  when the specified <paramref name="count" />
            is reached.
            </para>
      </remarks>
      <param name="observer">The object that is to receive notifications.</param>
      <param name="count">The maximum number of elements to be observed.</param>
      <returns>The observer's interface that enables resources to be disposed.</returns>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">observer != null</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">count &gt;= 0</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.Connect">
      <summary>
            Not supported.
            </summary>
      <returns>Throws <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">This method is not supported.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.OnNext(`0)">
      <summary>
            Provides the cursor with new data.
            </summary>
      <param name="value">The current notification information.</param>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.OnError(System.Exception)">
      <summary>
            Notifies the cursor that the provider has experienced an error condition.
            </summary>
      <param name="error">An object that provides additional information about the error.</param>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.OnCompleted">
      <summary>
            Notifies the cursor that the provider has finished sending push-based notifications.
            </summary>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.Move(System.Int32)">
      <summary>
            Changes the current index of the cursor to the element at the specified number of elements forward or backward.
            </summary>
      <param name="count">The number of elements to move after the current index if the specified count is positive
            or before the current index if the specified count is negative.</param>
      <remarks>
        <para>
            The specified <paramref name="count" /> may be a negative number only if <see cref="P:System.Reactive.Subjects.CursorSubject`1.IsForwardOnly" /> is <see langword="false" />.
            </para>
      </remarks>
      <seealso cref="P:System.Reactive.Subjects.CursorSubject`1.IsForwardOnly" />
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.Branch">
      <summary>
            Returns a new cursor that starts at the current position of this cursor and is tied to the lifetime of this cursor.
            </summary>
      <remarks>
        <alert type="implementors">
          <see cref="M:System.Reactive.Subjects.CursorSubject`1.Branch" /> provides a means for cursor authors to optimize branches so that they can share the same state.
            </alert>
      </remarks>
      <returns>A new cursor that starts at the current position of this cursor.</returns>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSynchronized == IsSynchronized</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.ToString">
      <summary>
            Returns a string representation of the cursor.
            </summary>
      <returns>A string representation of the cursor.</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.CursorSubject`1.Dispose">
      <summary>
            Permanently releases all observers and buffered elements.
            </summary>
    </member>
    <member name="P:System.Reactive.Subjects.CursorSubject`1.IsSynchronized">
      <summary>
            Gets a value indicating whether the cursor's methods and properties can be used concurrently by multiple threads.
            </summary>
      <value>Always returns <see langword="true" />.</value>
      <getter>
        <ensures>Contract.Result&lt;bool&gt;()</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.CursorSubject`1.IsForwardOnly">
      <summary>
            Gets a value indicating whether the cursor only moves forward.
            </summary>
      <value>
        <see langword="True" /> if the cursor only moves forward; otherwise, <see langword="false" />.</value>
      <seealso cref="M:System.Reactive.Subjects.CursorSubject`1.Move(System.Int32)" />
    </member>
    <member name="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex">
      <summary>
            Gets the zero-based index of the element in the sequence at which the cursor is positioned after 
            <see cref="M:System.Reactive.Subjects.CursorSubject`1.Move(System.Int32)" /> is called.
            </summary>
      <remarks>
        <para>
          <see cref="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex" /> starts and remains at 0 until it is changed by the <see cref="M:System.Reactive.Subjects.CursorSubject`1.Move(System.Int32)" /> method.  A value of 0 indicates
            that the cursor is positioned at the end of an empty sequence.  If the sequence generates one or more values, then 0 indicates
            that the cursor is positioned at the beginning of the sequence.  Subscribing to a cursor that has not moved replays all values in 
            the sequence, if any.
            </para>
        <para>
            The valid range of values for <see cref="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex" /> changes depending upon whether the sequence has terminated.
            If the sequence has not terminated, then <see cref="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex" /> can be any value that is greater than or equal to zero, 
            even if that value is greater than <see cref="P:System.Reactive.Subjects.CursorSubject`1.LatestIndex" />; however, once the sequence has terminated, 
            <see cref="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex" /> cannot be moved past one more than the <see cref="P:System.Reactive.Subjects.CursorSubject`1.LatestIndex" />.  This final position 
            indicates that the cursor is at the end of the sequence.  Calling <strog>Subscribe</strog> on a cursor that is 
            positioned at the end of the sequence causes only the termination notification to be pushed, without replaying any values.
            </para>
        <para>
            If <see cref="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex" /> is moved past the latest element in the sequence, as indicated by the value of 
            <see cref="P:System.Reactive.Subjects.CursorSubject`1.LatestIndex" />, then the existing values in the sequence will not be replayed to new subscriptions; 
            furthermore, any new values with indices that are less than <see cref="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex" /> will also be excluded from
            new subscriptions.
            </para>
        <para>
            If the current index is positioned ahead of the latest element in the sequence and the sequence 
            subsequently ends, then the current index is automatically changed to <see cref="P:System.Reactive.Subjects.CursorSubject`1.LatestIndex" /> + 1 to indicate 
            that the current index is at the end of the sequence.  Consumers can check whether <see cref="P:System.Reactive.Subjects.CursorSubject`1.CurrentIndex" /> has changed 
            during the <strong>OnCompleted</strong> notification.
            </para>
      </remarks>
      <value>The zero-based index of the element in the sequence on which the cursor is positioned after 
            <see cref="M:System.Reactive.Subjects.CursorSubject`1.Move(System.Int32)" /> is called; otherwise, -1.</value>
      <getter>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.CursorSubject`1.LatestIndex">
      <summary>
            Gets the zero-based index of the last known element in the sequence.
            </summary>
      <value>The zero-based index of the last known element in the sequence; -1 until the sequence produces an element, if any.
            If the sequence has terminated, then the value is the index of the last element in the sequence.</value>
      <getter>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_LatestIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.CursorSubject`1.AtEndOfSequence">
      <summary>
            Gets a value indicating whether the cursor is positioned at the end of the sequence.
            </summary>
      <remarks>
        <alert type="note">
            When <see cref="P:System.Reactive.Subjects.CursorSubject`1.AtEndOfSequence" /> returns <see langword="false" /> it does not indicate that the sequence has 
            not terminated.  It only indicates that the cursor is not currently positioned at the end of the sequence,
            regardless of whether the sequence has actually terminated or not.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the sequence has terminated and the cursor is currently positioned at the end of the sequence;
            otherwise, <see langword="false" />.</value>
      <seealso cref="P:System.Reactive.Subjects.CursorSubject`1.IsSequenceTerminated" />
      <getter>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">!Contract.Result&lt;bool&gt;() || IsSequenceTerminated</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.CursorSubject`1.IsSequenceTerminated">
      <summary>
            Gets a value indicating whether the sequence has terminated.
            </summary>
      <remarks>
        <alert type="note">
            When <see cref="P:System.Reactive.Subjects.CursorSubject`1.IsSequenceTerminated" /> returns <see langword="true" /> it does not indicate that the cursor is at the
            end of the sequence.  It only indicates that the sequence has terminated, regardless of whether the 
            cursor is actually positioned at the end of the sequence or not.
            </alert>
      </remarks>
      <value>
        <see langword="True" /> if the sequence has terminated; otherwise, <see langword="false" />.</value>
      <seealso cref="P:System.Reactive.Subjects.CursorSubject`1.AtEndOfSequence" />
    </member>
    <member name="P:System.Reactive.Subjects.CursorSubject`1.IsDisposed">
      <summary>
            Gets a value indicating whether the subject is disposed.
            </summary>
      <value>
        <see langword="True" /> if the subject is disposed; otherwise, <see langword="false" />.</value>
    </member>
    <member name="T:System.Reactive.Subjects.DictionarySubject`2">
      <summary>
            Represents an object that is a dictionary as well as an observable sequence of collection notifications and observer of collection modifications.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <remarks>
        <para>
          <see cref="T:System.Reactive.Subjects.DictionarySubject`2" /> implements <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" /> and behaves similar to <see cref="T:System.Collections.ObjectModel.ObservableCollection`1" />, 
            so it can be bound directly to an <strong>ItemsPresenter</strong> or a derived type in WPF, Silverlight and Windows Phone.
            </para>
        <alert type="tip">
            The enumerator that is returned by <see cref="M:System.Reactive.Subjects.DictionarySubject`2.GetEnumerator" /> blocks all methods on the <see cref="T:System.Reactive.Subjects.DictionarySubject`2" />
            until the enumeration has completed.  For a snapshot behavior instead, simply call <see cref="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
            or <see cref="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" /> to collect the items as fast as possible and then enumerate the new collection.
            </alert>
      </remarks>
      <threadsafety instance="true" />
      <invariant>gate != null</invariant>
      <invariant>subject != null</invariant>
      <invariant>dictionary != null</invariant>
    </member>
    <member name="T:System.Reactive.Subjects.IDictionarySubject`2">
      <summary>
            Represents an object that is a dictionary as well as an observable sequence of collection notifications and observer of collection modifications.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
    </member>
    <member name="M:System.Reactive.Subjects.IDictionarySubject`2.View">
      <summary>
            Returns an observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </summary>
      <remarks>
        <alert type="tip">
            To create a synchronized clone or projection of this dictionary, simply call <c>dictionary.View().Collect(...)</c>.
            </alert>
      </remarks>
      <returns>
            An observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </returns>
      <ensures>Contract.Result&lt;IObservable&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.IDictionarySubject`2.View(`0)">
      <summary>
            Returns an observable sequence of collection notifications for the specified <paramref name="key" />, starting with the current value if the dictionary 
            already contains the <paramref name="key" />.
            </summary>
      <param name="key">The key for which changes are to be observed.</param>
      <returns>
            An observable sequence of collection notifications for the specified <paramref name="key" />, starting with the current value if the dictionary 
            already contains the <paramref name="key" />.
            </returns>
      <ensures>Contract.Result&lt;IObservable&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.DictionarySubject`2" /> class.
            </summary>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.DictionarySubject`2" /> class.
            </summary>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, 
            or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the key.</param>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.DictionarySubject`2" /> class.
            </summary>
      <param name="dictionary">The dictionary from which elements are copied to the new dictionary.</param>
      <requires>dictionary != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.DictionarySubject`2" /> class.
            </summary>
      <param name="dictionary">The dictionary from which elements are copied to the new dictionary.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, 
            or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the key.</param>
      <requires>dictionary != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.View">
      <summary>
            Returns an observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </summary>
      <remarks>
        <alert type="tip">
            To create a synchronized clone or projection of this dictionary, simply call <c>dictionary.View().Collect(...)</c>.
            </alert>
      </remarks>
      <returns>
            An observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </returns>
      <ensures>Contract.Result&lt;IObservable&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Reactive.Subjects.IDictionarySubject`2.View" inheritedFromTypeName="IDictionarySubject">Contract.Result&lt;IObservable&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.View(`0)">
      <summary>
            Returns an observable sequence of collection notifications for the specified <paramref name="key" />, starting with the current value if the dictionary 
            already contains the <paramref name="key" />.
            </summary>
      <param name="key">The key for which changes are to be observed.</param>
      <returns>
            An observable sequence of collection notifications for the specified <paramref name="key" />, starting with the current value if the dictionary 
            already contains the <paramref name="key" />.
            </returns>
      <ensures>Contract.Result&lt;IObservable&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Reactive.Subjects.IDictionarySubject`2.View(`0)" inheritedFromTypeName="IDictionarySubject">Contract.Result&lt;IObservable&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.Subscribe(System.IObserver{System.Reactive.CollectionNotification{System.Collections.Generic.KeyValuePair{`0,`1}}})">
      <summary>
            Notifies the subject that an observer is to receive collection notifications.
            </summary>
      <param name="observer">The object that is to receive collection notifications.</param>
      <returns>The observer's interface that enables resources to be disposed.</returns>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.OnNext(System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
            Changes the dictionary according to the specified collection modification.
            </summary>
      <param name="value">A modification that indicates how the dictionary must be changed.</param>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.OnError(System.Exception)">
      <summary>
            Terminates the subject with an error condition.
            </summary>
      <param name="error">An object that provides additional information about the error.</param>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.OnCompleted">
      <summary>
            Notifies the subject to stop accepting collection modifications.
            </summary>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.TryGetValue(`0,`1@)">
      <summary>
            Gets the value associated with the specified <paramref name="key" />.
            </summary>
      <param name="key">The key whose value to get.</param>
      <param name="value">When this method returns, the value associated with the specified <paramref name="key" />, 
            if the key is found; otherwise, the default value for the type of the value parameter.</param>
      <returns>
        <see langword="True" /> if the dictionary contains an element with the specified <paramref name="key" />; otherwise, <see langword="false" />.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" inheritedFromTypeName="IDictionary">Contract.Result&lt;bool&gt;() == @this.ContainsKey(key)</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.ContainsKey(`0)">
      <summary>
            Determines whether the dictionary contains an element with the specified <paramref name="key" />.
            </summary>
      <param name="key">The key to locate in the dictionary.</param>
      <returns>
        <see langword="True" /> if the dictionary contains an element with the <paramref name="key" />; otherwise, <see langword="false" />.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" inheritedFromTypeName="IDictionary">!Contract.Result&lt;bool&gt;() || @this.Count &gt; 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.ContainsValue(`1)">
      <summary>
            Determines whether the dictionary contains a specific <paramref name="value" />.
            </summary>
      <param name="value">The value to locate in the dictionary.  The value can be <see langword="null" /> for reference types.</param>
      <returns>
        <see langword="True" /> if the dictionary contains an element with the specified <paramref name="value" />; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.Add(`0,`1)">
      <summary>
            Adds an element with the provided <paramref name="key" /> and <paramref name="value" /> to the dictionary.
            </summary>
      <param name="key">The object to use as the key of the element to add.</param>
      <param name="value">The object to use as the value of the element to add.</param>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.Remove(`0)">
      <summary>
            Removes the element with the specified <paramref name="key" /> from the dictionary.
            </summary>
      <param name="key">The key of the element to remove.</param>
      <returns>
        <see langword="True" /> if the element is successfully removed; otherwise, <see langword="false" />.
            This method also returns <see langword="false" /> if <paramref name="key" /> was not found in the dictionary.</returns>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.Clear">
      <summary>
            Removes all key/value pairs from the dictionary.
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection">this.Count == 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the key/value pairs in the dictionary.
            </summary>
      <remarks>
            The dictionary is locked for the entire duration while enumerating.  Any collection modifications that are received 
            during the enumeration will be blocked.  When the enumeration has completed, all previous modifications will be 
            allowed to acquire the lock and mutate the dictionary.  For this reason it is best to enumerate quickly.  For example, 
            you could call the <see cref="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" /> or <see cref="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" /> 
            extension method to take a snapshot of the dictionary, then perform work by enumerating the snapshot while the subject 
            is free to accept collection modifications.
            </remarks>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the dictionary.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.Dispose">
      <summary>
            Unsubscribes all observers and releases resources. 
            </summary>
    </member>
    <member name="P:System.Reactive.Subjects.DictionarySubject`2.Comparer">
      <summary>
            Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> that is used to determine equality of keys for the dictionary.
            </summary>
      <returns>The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> generic interface implementation that is used to determine 
            equality of keys for the current dictionary and to provide hash values for the keys.</returns>
      <getter>
        <ensures>Contract.Result&lt;IEqualityComparer&lt;TKey&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.DictionarySubject`2.Keys">
      <summary>
            Gets a collection containing a snapshot of the keys in the dictionary.
            </summary>
      <returns>A collection containing a snapshot of the keys in the dictionary.</returns>
      <getter>
        <ensures>Contract.Result&lt;ICollection&lt;TKey&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Keys" inheritedFromTypeName="IDictionary">Contract.Result&lt;ICollection&lt;TKey&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.DictionarySubject`2.Values">
      <summary>
            Gets a collection containing a snapshot of the values in the dictionary.
            </summary>
      <returns>A collection containing a snapshot of the values in the dictionary.</returns>
      <getter>
        <ensures>Contract.Result&lt;ICollection&lt;TValue&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Values" inheritedFromTypeName="IDictionary">Contract.Result&lt;ICollection&lt;TValue&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.DictionarySubject`2.Count">
      <summary>
            Gets the number of key/value pairs currently contained in the dictionary.
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.DictionarySubject`2.Item(`0)">
      <summary>
            Gets or sets the value associated with the specified <paramref name="key" />.
            </summary>
      <param name="key">The key of the value to get or set.</param>
      <returns>The value with the specified <paramref name="key" />.</returns>
    </member>
    <member name="E:System.Reactive.Subjects.DictionarySubject`2.CollectionChanged">
      <summary>
            Occurs when a value is added, removed, changed, moved, or the entire dictionary is refreshed.
            </summary>
    </member>
    <member name="T:System.Reactive.Subjects.IListSubject`1">
      <summary>
            Represents an object that is a list as well as an observable sequence of collection notifications and observer of collection modifications.
            </summary>
      <typeparam name="T">The type of the elements in the collection.</typeparam>
    </member>
    <member name="M:System.Reactive.Subjects.IListSubject`1.View">
      <summary>
            Returns an observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </summary>
      <remarks>
        <alert type="tip">
            To create a synchronized clone or projection of this list, simply call <c>list.View().Collect(...)</c>.
            </alert>
      </remarks>
      <returns>
            An observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </returns>
      <ensures>Contract.Result&lt;IObservable&lt;CollectionNotification&lt;T&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.Subjects.ListSubject`1">
      <summary>
            Represents an object that is a list as well as an observable sequence of collection notifications and observer of collection modifications.
            </summary>
      <typeparam name="T">The type of the elements in the collection.</typeparam>
      <remarks>
        <para>
          <see cref="T:System.Reactive.Subjects.ListSubject`1" /> implements <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" /> and behaves similar to <see cref="T:System.Collections.ObjectModel.ObservableCollection`1" />, 
            so it can be bound directly to an <strong>ItemsPresenter</strong> or a derived type in WPF, Silverlight and Windows Phone.
            </para>
        <alert type="tip">
            The enumerator that is returned by <see cref="M:System.Reactive.Subjects.ListSubject`1.GetEnumerator" /> blocks all methods on the <see cref="T:System.Reactive.Subjects.ListSubject`1" />
            until the enumeration has completed.  For a snapshot behavior instead, simply call <see cref="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" />
            to collect the items as fast as possible and then enumerate the new list.
            </alert>
      </remarks>
      <threadsafety instance="true" />
      <invariant>gate != null</invariant>
      <invariant>subject != null</invariant>
      <invariant>list != null</invariant>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.ListSubject`1" /> class.
            </summary>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.View">
      <summary>
            Returns an observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </summary>
      <remarks>
        <alert type="tip">
            To create a synchronized clone or projection of this list, simply call <c>list.View().Collect(...)</c>.
            </alert>
      </remarks>
      <returns>
            An observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </returns>
      <ensures inheritedFrom="M:System.Reactive.Subjects.IListSubject`1.View" inheritedFromTypeName="IListSubject">Contract.Result&lt;IObservable&lt;CollectionNotification&lt;T&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.Subscribe(System.IObserver{System.Reactive.CollectionNotification{`0}})">
      <summary>
            Notifies the subject that an observer is to receive collection notifications.
            </summary>
      <param name="observer">The object that is to receive collection notifications.</param>
      <returns>The observer's interface that enables resources to be disposed.</returns>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.OnNext(System.Reactive.CollectionModification{`0})">
      <summary>
            Changes the list according to the specified collection notification.
            </summary>
      <param name="value">A modification that indicates how the list must be changed.</param>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.OnError(System.Exception)">
      <summary>
            Terminates the subject with an error condition.
            </summary>
      <param name="error">An object that provides additional information about the error.</param>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.OnCompleted">
      <summary>
            Notifies the subject to stop accepting collection modifications.
            </summary>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.Contains(`0)">
      <summary>
            Determines whether the list contains a specific value.
            </summary>
      <param name="item">The object to locate in the list.</param>
      <returns>
        <see langword="True" /> if <paramref name="item" /> is found in the list; otherwise, <see langword="false" /></returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection">!Contract.Result&lt;bool&gt;() || this.Count &gt; 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.IndexOf(`0)">
      <summary>
            Determines the index of a specific item in the list.
            </summary>
      <param name="item">The object to locate in the list.</param>
      <returns>The index of <paramref name="item" /> if found in the list; otherwise, -1.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList">Contract.Result&lt;int&gt;() &lt; @this.Count</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.Add(`0)">
      <summary>
            Adds an item to the list.
            </summary>
      <param name="item">The object to add to the list.</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection">this.Count &gt;= Contract.OldValue(this.Count)</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.Insert(System.Int32,`0)">
      <summary>
            Inserts an item to the list at the specified index.
            </summary>
      <param name="index">The zero-based index at which item should be inserted.</param>
      <param name="item">The object to insert into the list.</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList">index &lt;= @this.Count</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.Remove(`0)">
      <summary>
            Removes the first occurrence of a specific object from the list.
            </summary>
      <param name="item">The object to remove from the list.</param>
      <returns>
        <see langword="True" /> if <paramref name="item" /> was successfully removed from the list; otherwise, <see langword="false" />.
            This method also returns <see langword="false" /> if <paramref name="item" /> is not found in the list.</returns>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.RemoveAt(System.Int32)">
      <summary>
            Removes the list item at the specified index.
            </summary>
      <param name="index">The zero-based index of the item to remove.</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList">index &lt; @this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList">@this.Count == Contract.OldValue(@this.Count) - 1</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.Clear">
      <summary>
            Removes all items from the list.
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection">this.Count == 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the elements of the list to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from 
            the list. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
      <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex + this.Count  &lt;= array.Length</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the list.
            </summary>
      <remarks>
            The list is locked for the entire duration while enumerating.  Any collection modifications that are received 
            during the enumeration will be blocked.  When the enumeration has completed, all previous modifications will be 
            allowed to acquire the lock and mutate the list.  For this reason it is best to enumerate quickly.  For example, 
            you could call the <see cref="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" /> extension method to take a snapshot of the list, 
            then perform work by enumerating the snapshot while the subject is free to accept collection modifications.
            </remarks>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.Dispose">
      <summary>
            Unsubscribes all observers and releases resources. 
            </summary>
    </member>
    <member name="P:System.Reactive.Subjects.ListSubject`1.Count">
      <summary>
            Gets the number of elements currently contained in the list.
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.ListSubject`1.IsReadOnly">
      <summary>
            Gets a value indicating whether the list is read-only.
            </summary>
      <value>Always returns <see langword="false" />.</value>
    </member>
    <member name="P:System.Reactive.Subjects.ListSubject`1.Item(System.Int32)">
      <summary>
            Gets or sets the element at the specified index.
            </summary>
      <param name="index">The zero-based index of the element to get or set.</param>
      <returns>The element at the specified index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the list.</exception>
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList">index &lt; @this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList">index &lt; @this.Count</requires>
      </setter>
    </member>
    <member name="E:System.Reactive.Subjects.ListSubject`1.CollectionChanged">
      <summary>
            Occurs when an item is added, removed, changed, moved, or the entire list is refreshed.
            </summary>
    </member>
    <member name="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2">
      <summary>
            Provides a read-only wrapper around an <see cref="T:System.Reactive.Subjects.IDictionarySubject`2" />.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <threadsafety instance="true" />
      <invariant>subject != null</invariant>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.#ctor(System.Reactive.Subjects.IDictionarySubject{`0,`1})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.ReadOnlyDictionarySubject`2" /> class.
            </summary>
      <param name="subject">The subject to be decorated with a read-only wrapper.</param>
      <requires>subject != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.View">
      <summary>
            Returns an observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </summary>
      <remarks>
        <alert type="tip">
            To create a synchronized clone or projection of this dictionary, simply call <c>dictionary.View().Collect(...)</c>.
            </alert>
      </remarks>
      <returns>
            An observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </returns>
      <ensures inheritedFrom="M:System.Reactive.Subjects.IDictionarySubject`2.View" inheritedFromTypeName="IDictionarySubject">Contract.Result&lt;IObservable&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.View(`0)">
      <summary>
            Returns an observable sequence of collection notifications for the specified <paramref name="key" />, starting with the current value if the dictionary 
            already contains the <paramref name="key" />.
            </summary>
      <param name="key">The key for which changes are to be observed.</param>
      <returns>
            An observable sequence of collection notifications for the specified <paramref name="key" />, starting with the current value if the dictionary 
            already contains the <paramref name="key" />.
            </returns>
      <ensures inheritedFrom="M:System.Reactive.Subjects.IDictionarySubject`2.View(`0)" inheritedFromTypeName="IDictionarySubject">Contract.Result&lt;IObservable&lt;CollectionNotification&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Subscribe(System.IObserver{System.Reactive.CollectionNotification{System.Collections.Generic.KeyValuePair{`0,`1}}})">
      <summary>
            Notifies the subject that an observer is to receive collection notifications.
            </summary>
      <param name="observer">The object that is to receive collection notifications.</param>
      <returns>The observer's interface that enables resources to be disposed.</returns>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.OnNext(System.Reactive.CollectionModification{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
            Changes the dictionary according to the specified collection modification.  This method is not supported.
            </summary>
      <param name="value">A modification that indicates how the dictionary must be changed.</param>
      <exception cref="T:System.NotSupportedException">Attempted to set an item in a read-only dictionary.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.OnError(System.Exception)">
      <summary>
            Terminates the subject with an error condition.  This method is not supported.
            </summary>
      <param name="error">An object that provides additional information about the error.</param>
      <exception cref="T:System.NotSupportedException">Attempted to set an item in a read-only dictionary.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.OnCompleted">
      <summary>
            Notifies the subject to stop accepting collection modifications.  This method is not supported.
            </summary>
      <exception cref="T:System.NotSupportedException">Attempted to set an item in a read-only dictionary.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.TryGetValue(`0,`1@)">
      <summary>
            Gets the value associated with the specified <paramref name="key" />.
            </summary>
      <param name="key">The key whose value to get.</param>
      <param name="value">When this method returns, the value associated with the specified <paramref name="key" />, 
            if the key is found; otherwise, the default value for the type of the value parameter.</param>
      <returns>
        <see langword="True" /> if the dictionary contains an element with the specified <paramref name="key" />; otherwise, <see langword="false" />.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" inheritedFromTypeName="IDictionary">Contract.Result&lt;bool&gt;() == @this.ContainsKey(key)</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.ContainsKey(`0)">
      <summary>
            Determines whether the dictionary contains an element with the specified <paramref name="key" />.
            </summary>
      <param name="key">The key to locate in the dictionary.</param>
      <returns>
        <see langword="True" /> if the dictionary contains an element with the <paramref name="key" />; otherwise, <see langword="false" />.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" inheritedFromTypeName="IDictionary">!Contract.Result&lt;bool&gt;() || @this.Count &gt; 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Add(`0,`1)">
      <summary>
            Adds an element with the provided <paramref name="key" /> and <paramref name="value" /> to the dictionary.  This method is not supported.
            </summary>
      <param name="key">The object to use as the key of the element to add.</param>
      <param name="value">The object to use as the value of the element to add.</param>
      <exception cref="T:System.NotSupportedException">Attempted to set an item in a read-only dictionary.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Remove(`0)">
      <summary>
            Removes the element with the specified <paramref name="key" /> from the dictionary.  This method is not supported.
            </summary>
      <param name="key">The key of the element to remove.</param>
      <returns>
        <see langword="True" /> if the element is successfully removed; otherwise, <see langword="false" />.
            This method also returns <see langword="false" /> if <paramref name="key" /> was not found in the dictionary.</returns>
      <exception cref="T:System.NotSupportedException">Attempted to set an item in a read-only dictionary.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Clear">
      <summary>
            Removes all key/value pairs from the dictionary.  This method is not supported.
            </summary>
      <exception cref="T:System.NotSupportedException">Attempted to set an item in a read-only dictionary.</exception>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection">this.Count == 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the key/value pairs in the dictionary.
            </summary>
      <remarks>
            The dictionary is locked for the entire duration while enumerating.  Any collection modifications that are received 
            during the enumeration will be blocked.  When the enumeration has completed, all previous modifications will be 
            allowed to acquire the lock and mutate the dictionary.  For this reason it is best to enumerate quickly.  For example, 
            you could call the <see cref="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" /> or <see cref="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" /> 
            extension method to take a snapshot of the dictionary, then perform work by enumerating the snapshot while the subject 
            is free to accept collection modifications.
            </remarks>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the dictionary.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Dispose">
      <summary>
            Unsubscribes all observers and releases resources. 
            </summary>
    </member>
    <member name="P:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Keys">
      <summary>
            Gets a collection containing a snapshot of the keys in the dictionary.
            </summary>
      <returns>A collection containing a snapshot of the keys in the dictionary.</returns>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Keys" inheritedFromTypeName="IDictionary">Contract.Result&lt;ICollection&lt;TKey&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Values">
      <summary>
            Gets a collection containing a snapshot of the values in the dictionary.
            </summary>
      <returns>A collection containing a snapshot of the values in the dictionary.</returns>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Values" inheritedFromTypeName="IDictionary">Contract.Result&lt;ICollection&lt;TValue&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Count">
      <summary>
            Gets the number of key/value pairs currently contained in the dictionary.
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.Item(`0)">
      <summary>
            Gets the value associated with the specified <paramref name="key" />.  Setting this property is not supported.
            </summary>
      <param name="key">The key of the value to get or set.</param>
      <returns>The value with the specified <paramref name="key" />.</returns>
      <exception cref="T:System.NotSupportedException">Attempted to set an item in a read-only dictionary.</exception>
    </member>
    <member name="E:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.CollectionChanged">
      <summary>
            Occurs when a value is added, removed, changed, moved, or the entire dictionary is refreshed.
            </summary>
    </member>
    <member name="T:System.Reactive.Subjects.ReadOnlyListSubject`1">
      <summary>
            Provides a read-only wrapper around an <see cref="T:System.Reactive.Subjects.IListSubject`1" />.
            </summary>
      <typeparam name="T">The type of the elements in the collection.</typeparam>
      <threadsafety instance="true" />
      <invariant>subject != null</invariant>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.#ctor(System.Reactive.Subjects.IListSubject{`0})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Reactive.Subjects.ReadOnlyListSubject`1" /> class.
            </summary>
      <param name="subject">The subject to be decorated with a read-only wrapper.</param>
      <requires>subject != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.View">
      <summary>
            Returns an observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </summary>
      <remarks>
        <alert type="tip">
            To create a synchronized clone or projection of this list, simply call <c>list.View().Collect(...)</c>.
            </alert>
      </remarks>
      <returns>
            An observable sequence of collection notifications that includes a snapshot of all existing elements at the time of subscription, 
            followed by any subsequent changes.
            </returns>
      <ensures inheritedFrom="M:System.Reactive.Subjects.IListSubject`1.View" inheritedFromTypeName="IListSubject">Contract.Result&lt;IObservable&lt;CollectionNotification&lt;T&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.Subscribe(System.IObserver{System.Reactive.CollectionNotification{`0}})">
      <summary>
            Notifies the subject that an observer is to receive collection notifications.
            </summary>
      <param name="observer">The object that is to receive collection notifications.</param>
      <returns>The observer's interface that enables resources to be disposed.</returns>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.OnNext(System.Reactive.CollectionModification{`0})">
      <summary>
            Changes the list according to the specified collection modification.  This method is not supported.
            </summary>
      <param name="value">A modification that indicates how the list must be changed.</param>
      <exception cref="T:System.NotSupportedException">Attempted to modify a read-only list.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.OnError(System.Exception)">
      <summary>
            Terminates the subject with an error condition.  This method is not supported.
            </summary>
      <param name="error">An object that provides additional information about the error.</param>
      <exception cref="T:System.NotSupportedException">Attempted to modify a read-only list.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.OnCompleted">
      <summary>
            Notifies the subject to stop accepting collection modifications.  This method is not supported.
            </summary>
      <exception cref="T:System.NotSupportedException">Attempted to modify a read-only list.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.Contains(`0)">
      <summary>
            Determines whether the list contains a specific value.
            </summary>
      <param name="item">The object to locate in the list.</param>
      <returns>
        <see langword="True" /> if <paramref name="item" /> is found in the list; otherwise, <see langword="false" /></returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection">!Contract.Result&lt;bool&gt;() || this.Count &gt; 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.IndexOf(`0)">
      <summary>
            Determines the index of a specific item in the list.
            </summary>
      <param name="item">The object to locate in the list.</param>
      <returns>The index of <paramref name="item" /> if found in the list; otherwise, -1.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList">Contract.Result&lt;int&gt;() &lt; @this.Count</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.Add(`0)">
      <summary>
            Adds an item to the list.  This method is not supported.
            </summary>
      <param name="item">The object to add to the list.</param>
      <exception cref="T:System.NotSupportedException">Attempted to modify a read-only list.</exception>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection">this.Count &gt;= Contract.OldValue(this.Count)</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.Insert(System.Int32,`0)">
      <summary>
            Inserts an item to the list at the specified index.  This method is not supported.
            </summary>
      <param name="index">The zero-based index at which item should be inserted.</param>
      <param name="item">The object to insert into the list.</param>
      <exception cref="T:System.NotSupportedException">Attempted to modify a read-only list.</exception>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList">index &lt;= @this.Count</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.Remove(`0)">
      <summary>
            Removes the first occurrence of a specific object from the list.  This method is not supported.
            </summary>
      <param name="item">The object to remove from the list.</param>
      <returns>
        <see langword="True" /> if <paramref name="item" /> was successfully removed from the list; otherwise, <see langword="false" />.
            This method also returns <see langword="false" /> if <paramref name="item" /> is not found in the list.</returns>
      <exception cref="T:System.NotSupportedException">Attempted to modify a read-only list.</exception>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.RemoveAt(System.Int32)">
      <summary>
            Removes the list item at the specified index.  This method is not supported.
            </summary>
      <param name="index">The zero-based index of the item to remove.</param>
      <exception cref="T:System.NotSupportedException">Attempted to modify a read-only list.</exception>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList">index &lt; @this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList">@this.Count == Contract.OldValue(@this.Count) - 1</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.Clear">
      <summary>
            Removes all items from the list.  This method is not supported.
            </summary>
      <exception cref="T:System.NotSupportedException">Attempted to modify a read-only list.</exception>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection">this.Count == 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the elements of the list to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from 
            the list. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
      <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex + this.Count  &lt;= array.Length</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the list.
            </summary>
      <remarks>
            The list is locked for the entire duration while enumerating.  Any collection modifications that are received 
            during the enumeration will be blocked.  When the enumeration has completed, all previous modifications will be 
            allowed to acquire the lock and mutate the list.  For this reason it is best to enumerate quickly.  For example, 
            you could call the <see cref="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" /> extension method to take a snapshot of the list, 
            then perform work by enumerating the snapshot while the subject is free to accept collection modifications.
            </remarks>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.Dispose">
      <summary>
            Unsubscribes all observers and releases resources. 
            </summary>
    </member>
    <member name="P:System.Reactive.Subjects.ReadOnlyListSubject`1.Count">
      <summary>
            Gets the number of elements currently contained in the list.
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.Subjects.ReadOnlyListSubject`1.IsReadOnly">
      <summary>
            Gets a value indicating whether the list is read-only.
            </summary>
      <value>Always returns <see langword="true" />.</value>
    </member>
    <member name="P:System.Reactive.Subjects.ReadOnlyListSubject`1.Item(System.Int32)">
      <summary>
            Gets the element at the specified index.  Setting this property is not supported.
            </summary>
      <param name="index">The zero-based index of the element to get.</param>
      <returns>The element at the specified index.</returns>
      <exception cref="T:System.NotSupportedException">Attempted to set an item in a read-only list.</exception>
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList">index &lt; @this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList">index &lt; @this.Count</requires>
      </setter>
    </member>
    <member name="E:System.Reactive.Subjects.ReadOnlyListSubject`1.CollectionChanged">
      <summary>
            Occurs when an item is added, removed, changed, moved, or the entire list is refreshed.
            </summary>
    </member>
    <member name="T:System.ServiceModel.Syndication.ObservableSyndication">
      <summary>
            Provides <see langword="static" /> methods for downloading syndication feeds.
            </summary>
    </member>
    <member name="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadRss(System.Uri[])">
      <summary>
            Downloads the specified RSS 2.0 syndication <paramref name="feeds" /> and merges them into an observable sequence.
            </summary>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadRss(System.Collections.Generic.IEnumerable{System.Uri})">
      <summary>
            Downloads the specified RSS 2.0 syndication <paramref name="feeds" /> and merges them into an observable sequence.
            </summary>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadRss(System.TimeSpan,System.Uri[])">
      <summary>
            Downloads all of the specified RSS 2.0 syndication <paramref name="feeds" /> at the specified <paramref name="interval" /> and merges them into an observable sequence.
            </summary>
      <param name="interval">The duration between downloads.</param>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <para>
          <see cref="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadRss(System.TimeSpan,System.Uri[])" /> downloads all of the feeds upon subscription and then repeats the process at each <paramref name="interval" />.
            All of the <paramref name="feeds" /> are downloaded at each interval and merged into the observable sequence.
            </para>
        <para>
            To avoid duplicate items, consider calling the <strong>Distinct</strong> method on the sequence.  Alternatively, use the 
            <strong>Collect</strong> method to create an <see cref="T:System.Reactive.Subjects.IDictionarySubject`2" />.
            </para>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>interval &gt;= TimeSpan.Zero</requires>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadRss(System.TimeSpan,System.Collections.Generic.IEnumerable{System.Uri})">
      <summary>
            Downloads all of the specified RSS 2.0 syndication <paramref name="feeds" /> at the specified <paramref name="interval" /> and merges them into an observable sequence.
            </summary>
      <param name="interval">The duration between downloads.</param>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <para>
          <see cref="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadRss(System.TimeSpan,System.Collections.Generic.IEnumerable{System.Uri})" /> downloads all of the feeds upon subscription and then repeats the process at each <paramref name="interval" />.
            All of the <paramref name="feeds" /> are downloaded at each interval and merged into the observable sequence.
            </para>
        <para>
            To avoid duplicate items, consider calling the <strong>Distinct</strong> method on the sequence.  Alternatively, use the 
            <strong>Collect</strong> method to create an <see cref="T:System.Reactive.Subjects.IDictionarySubject`2" />.
            </para>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>interval &gt;= TimeSpan.Zero</requires>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadAtom(System.Uri[])">
      <summary>
            Downloads the specified Atom 1.0 syndication <paramref name="feeds" /> and merges them into an observable sequence.
            </summary>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadAtom(System.Collections.Generic.IEnumerable{System.Uri})">
      <summary>
            Downloads the specified Atom 1.0 syndication <paramref name="feeds" /> and merges them into an observable sequence.
            </summary>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadAtom(System.TimeSpan,System.Uri[])">
      <summary>
            Downloads all of the specified Atom 1.0 syndication <paramref name="feeds" /> at the specified <paramref name="interval" /> and merges them into an observable sequence.
            </summary>
      <param name="interval">The duration between downloads.</param>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <para>
          <see cref="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadAtom(System.TimeSpan,System.Uri[])" /> downloads all of the feeds upon subscription and then repeats the process at each <paramref name="interval" />.
            All of the <paramref name="feeds" /> are downloaded at each interval and merged into the observable sequence.
            </para>
        <para>
            To avoid duplicate items, consider calling the <strong>Distinct</strong> method on the sequence.  Alternatively, use the 
            <strong>Collect</strong> method to create an <see cref="T:System.Reactive.Subjects.IDictionarySubject`2" />.
            </para>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>interval &gt;= TimeSpan.Zero</requires>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadAtom(System.TimeSpan,System.Collections.Generic.IEnumerable{System.Uri})">
      <summary>
            Downloads all of the specified Atom 1.0 syndication <paramref name="feeds" /> at the specified <paramref name="interval" /> and merges them into an observable sequence.
            </summary>
      <param name="interval">The duration between downloads.</param>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <para>
          <see cref="M:System.ServiceModel.Syndication.ObservableSyndication.DownloadAtom(System.TimeSpan,System.Collections.Generic.IEnumerable{System.Uri})" /> downloads all of the feeds upon subscription and then repeats the process at each <paramref name="interval" />.
            All of the <paramref name="feeds" /> are downloaded at each interval and merged into the observable sequence.
            </para>
        <para>
            To avoid duplicate items, consider calling the <strong>Distinct</strong> method on the sequence.  Alternatively, use the 
            <strong>Collect</strong> method to create an <see cref="T:System.Reactive.Subjects.IDictionarySubject`2" />.
            </para>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>interval &gt;= TimeSpan.Zero</requires>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.ServiceModel.Syndication.SyndicationFeedFormatterExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for <see cref="T:System.ServiceModel.Syndication.SyndicationFeedFormatter" /> objects.
            </summary>
    </member>
    <member name="M:System.ServiceModel.Syndication.SyndicationFeedFormatterExtensions.DownloadObservable(System.ServiceModel.Syndication.SyndicationFeedFormatter,System.Uri[])">
      <summary>
            Downloads the specified syndication <paramref name="feeds" /> and merges them into an observable sequence.
            </summary>
      <param name="formatter">The object that reads each feed.</param>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>formatter != null</requires>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.SyndicationFeedFormatterExtensions.DownloadObservable(System.ServiceModel.Syndication.SyndicationFeedFormatter,System.Collections.Generic.IEnumerable{System.Uri})">
      <summary>
            Downloads the specified syndication <paramref name="feeds" /> and merges them into an observable sequence.
            </summary>
      <param name="formatter">The object that reads each feed.</param>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>formatter != null</requires>
      <requires>feeds != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.SyndicationFeedFormatterExtensions.DownloadObservable(System.ServiceModel.Syndication.SyndicationFeedFormatter,System.TimeSpan,System.Uri[])">
      <summary>
            Downloads all of the specified syndication <paramref name="feeds" /> at the specified <paramref name="interval" /> and merges them into an observable sequence.
            </summary>
      <param name="formatter">The object that reads each feed.</param>
      <param name="interval">The duration between downloads.</param>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <para>
          <see cref="M:System.ServiceModel.Syndication.SyndicationFeedFormatterExtensions.DownloadObservable(System.ServiceModel.Syndication.SyndicationFeedFormatter,System.TimeSpan,System.Uri[])" /> downloads all of the feeds upon subscription and then repeats the process at each <paramref name="interval" />.
            All of the <paramref name="feeds" /> are downloaded at each interval and merged into the observable sequence.
            </para>
        <para>
            To avoid duplicate items, consider calling the <strong>Distinct</strong> method on the sequence.  Alternatively, use the 
            <strong>Collect</strong> method to create an <see cref="T:System.Reactive.Subjects.IDictionarySubject`2" />.
            </para>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>formatter != null</requires>
      <requires>feeds != null</requires>
      <requires>interval &gt;= TimeSpan.Zero</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.SyndicationFeedFormatterExtensions.DownloadObservable(System.ServiceModel.Syndication.SyndicationFeedFormatter,System.TimeSpan,System.Collections.Generic.IEnumerable{System.Uri})">
      <summary>
            Downloads all of the specified syndication <paramref name="feeds" /> at the specified <paramref name="interval" /> and merges them into an observable sequence.
            </summary>
      <param name="formatter">The object that reads each feed.</param>
      <param name="interval">The duration between downloads.</param>
      <param name="feeds">The <see cref="T:System.Uri" /> objects identifying the feeds to be downloaded.</param>
      <remarks>
        <para>
          <see cref="M:System.ServiceModel.Syndication.SyndicationFeedFormatterExtensions.DownloadObservable(System.ServiceModel.Syndication.SyndicationFeedFormatter,System.TimeSpan,System.Collections.Generic.IEnumerable{System.Uri})" /> downloads all of the feeds upon subscription and then repeats the process at each <paramref name="interval" />.
            All of the <paramref name="feeds" /> are downloaded at each interval and merged into the observable sequence.
            </para>
        <para>
            To avoid duplicate items, consider calling the <strong>Distinct</strong> method on the sequence.  Alternatively, use the 
            <strong>Collect</strong> method to create an <see cref="T:System.Reactive.Subjects.IDictionarySubject`2" />.
            </para>
        <alert type="tip">
            To get the original <see cref="T:System.ServiceModel.Syndication.SyndicationFeed" /> for each <see cref="T:System.ServiceModel.Syndication.SyndicationItem" />, use the <see cref="P:System.ServiceModel.Syndication.SyndicationItem.SourceFeed" /> property.
            </alert>
      </remarks>
      <returns>An observable sequence of items from all of the feeds merged together.</returns>
      <requires>formatter != null</requires>
      <requires>feeds != null</requires>
      <requires>interval &gt;= TimeSpan.Zero</requires>
      <ensures>Contract.Result&lt;IObservable&lt;SyndicationItem&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Windows.FrameworkElementExtensions">
      <summary>
            Provides <see langword="static" /> methods for attaching view models to <see cref="T:System.Windows.FrameworkElement" /> objects.
            </summary>
    </member>
    <member name="M:System.Windows.FrameworkElementExtensions.GetViewModel(System.Windows.FrameworkElement)">
      <summary>
            Gets the object that is currently attached to the specified <paramref name="element" />.
            </summary>
      <remarks>
        <see cref="M:System.Windows.FrameworkElementExtensions.GetViewModel(System.Windows.FrameworkElement)" /> actually returns the value of the <see cref="P:System.Windows.FrameworkElement.DataContext" /> property of the 
            specified <paramref name="element" />, whether or not it represents a view model object.  This may change in a future version.
            </remarks>
      <param name="element">The <see cref="T:System.Windows.FrameworkElement" /> from which the attachment will be returned.</param>
      <returns>The object that is currently attached to the specified <paramref name="element" />.</returns>
      <requires>element != null</requires>
    </member>
    <member name="M:System.Windows.FrameworkElementExtensions.SetViewModel(System.Windows.FrameworkElement,System.Func{System.Object})">
      <summary>
            Attaches a view model returned by the specified function to the <see cref="P:System.Windows.FrameworkElement.DataContext" /> of the 
            specified <paramref name="element" /> each time that the <paramref name="element" /> is loaded, and detaches the current 
            view model each time that the <paramref name="element" /> is unloaded.
            </summary>
      <remarks>
        <para>
          <see cref="M:System.Windows.FrameworkElementExtensions.SetViewModel(System.Windows.FrameworkElement,System.Func{System.Object})" /> allows the element's <see cref="P:System.Windows.FrameworkElement.DataContext" /> 
            to be assigned to different objects or view models after a view model is attached.  When a different object or view 
            model is assigned, the current view model is permanently detached and the element's events are no longer tracked for 
            the specified <paramref name="viewModelFactory" />.  To reassign the factory to the <paramref name="element" />, call 
            <see cref="M:System.Windows.FrameworkElementExtensions.SetViewModel(System.Windows.FrameworkElement,System.Func{System.Object})" /> again.
            </para>
        <para>
            The factory can return the same view model instance every time that it's called or it can create new view models.
            The factory can also return <see langword="null" />.
            </para>
        <alert type="warning">
            Do not return the same view model instance more than once if it implements <see cref="T:System.IDisposable" />; otherwise, the
            view model will be disposed the first time that it's detached, which may cause problems if it's reattached.
            </alert>
        <para>
            The objects returned by the factory do not have to derive from any particular base class or implement any particular 
            interfaces; however, a couple of special interfaces are supported to provide additional functionality.  If an object
            implements <see cref="T:System.IDisposable" />, then its <see cref="M:System.IDisposable.Dispose" /> method is called when the object is 
            detached from the <paramref name="element" />.  If an object implements <see cref="T:System.Windows.Reactive.IViewModel" />, then its 
            <see cref="M:System.Windows.Reactive.IViewModel.Attach(System.Windows.FrameworkElement)" /> and <see cref="M:System.Windows.Reactive.IViewModel.Detach" /> methods are called when appropriate.  Implementations
            for both of these interfaces is provided by the base <see cref="T:Rxx.ViewModel" /> class.
            </para>
      </remarks>
      <param name="element">The <see cref="T:System.Windows.FrameworkElement" /> to which a view model will be attached.</param>
      <param name="viewModelFactory">A function that returns view model objects or <see langword="null" />.</param>
      <requires>element != null</requires>
      <requires>viewModelFactory != null</requires>
    </member>
    <member name="T:System.Windows.Input.AnonymousCommand">
      <summary>
            Represents a functional implementation of <see cref="T:System.Windows.Input.ICommand" />.
            </summary>
      <invariant>canExecute != null</invariant>
      <invariant>execute != null</invariant>
      <invariant>addCanExecuteChanged != null</invariant>
      <invariant>removeCanExecuteChanged != null</invariant>
    </member>
    <member name="M:System.Windows.Input.AnonymousCommand.#ctor(System.Action{System.Object})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Windows.Input.AnonymousCommand" /> class that always returns <see langword="true" />
            from its <see cref="M:System.Windows.Input.AnonymousCommand.CanExecute(System.Object)" /> method.
            </summary>
      <param name="execute">An action that is invoked when <see cref="M:System.Windows.Input.AnonymousCommand.Execute(System.Object)" /> is called.</param>
      <requires>execute != null</requires>
    </member>
    <member name="M:System.Windows.Input.AnonymousCommand.#ctor(System.Func{System.Object,System.Boolean},System.Action{System.Object},System.Action{System.EventHandler},System.Action{System.EventHandler})">
      <summary>
            Constructs a new instance of the <see cref="T:System.Windows.Input.AnonymousCommand" /> class.
            </summary>
      <param name="canExecute">A function that is invoked when <see cref="M:System.Windows.Input.AnonymousCommand.CanExecute(System.Object)" /> is called.</param>
      <param name="execute">An action that is invoked when <see cref="M:System.Windows.Input.AnonymousCommand.Execute(System.Object)" /> is called.</param>
      <param name="addCanExecuteChanged">An action that is called when an event handler is added to <see cref="E:System.Windows.Input.AnonymousCommand.CanExecuteChanged" />.</param>
      <param name="removeCanExecuteChanged">An action that is called when an event handler is removed from <see cref="E:System.Windows.Input.AnonymousCommand.CanExecuteChanged" />.</param>
      <requires>canExecute != null</requires>
      <requires>execute != null</requires>
      <requires>addCanExecuteChanged != null</requires>
      <requires>removeCanExecuteChanged != null</requires>
    </member>
    <member name="M:System.Windows.Input.AnonymousCommand.CanExecute(System.Object)">
      <summary>
            Determines whether the command can execute in its current state.
            </summary>
      <param name="parameter">Data used by the command.  If the command does not require data to be passed, 
            this object can be set to <see langword="null" />.</param>
      <returns>
        <see langword="True" /> if this command can be executed; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Windows.Input.AnonymousCommand.Execute(System.Object)">
      <summary>
            Invokes the command.
            </summary>
      <param name="parameter">Data used by the command.  If the command does not require data to be passed, 
            this object can be set to <see langword="null" />.</param>
    </member>
    <member name="E:System.Windows.Input.AnonymousCommand.CanExecuteChanged">
      <summary>
            Occurs when changes occur that affect whether or not the command should execute.
            </summary>
    </member>
    <member name="T:System.Windows.Input.CommandExtensions">
      <summary>
            Provides <see langword="static" /> extension methods for <see cref="T:System.Windows.Input.ICommand" /> objects.
            </summary>
    </member>
    <member name="M:System.Windows.Input.CommandExtensions.CanExecuteObservable(System.Windows.Input.ICommand)">
      <summary>
            Returns an observable sequence that indicates when the <paramref name="command" /> can be executed, 
            starting with the current state of the <paramref name="command" />.
            </summary>
      <remarks>
            The observable is a sequence of values returned by <see cref="M:System.Windows.Input.ICommand.CanExecute(System.Object)" /> 
            whenever the <paramref name="command" /> raises its <see cref="E:System.Windows.Input.ICommand.CanExecuteChanged" /> event.
            </remarks>
      <param name="command">The <see cref="T:System.Windows.Input.ICommand" /> to be observed.</param>
      <returns>An observable sequence that indicates when the <paramref name="command" /> can be executed, 
            starting with the current state of the <paramref name="command" />.</returns>
      <requires>command != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;bool&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.Input.CommandExtensions.CanExecuteObservable(System.Windows.Input.ICommand,System.Object)">
      <summary>
            Returns an observable sequence that indicates when the <paramref name="command" /> can be executed, 
            starting with the current state of the <paramref name="command" />.
            </summary>
      <remarks>
            The observable is a sequence of values returned by <see cref="M:System.Windows.Input.ICommand.CanExecute(System.Object)" /> 
            whenever the <paramref name="command" /> raises its <see cref="E:System.Windows.Input.ICommand.CanExecuteChanged" /> event.
            </remarks>
      <param name="command">The <see cref="T:System.Windows.Input.ICommand" /> to be observed.</param>
      <param name="parameter">The object that is passed to the <see cref="M:System.Windows.Input.ICommand.CanExecute(System.Object)" /> method.
            This value can be <see langword="null" /> if the <paramref name="command" /> supports it.</param>
      <returns>An observable sequence that indicates when the <paramref name="command" /> can be executed, 
            starting with the current state of the <paramref name="command" />.</returns>
      <requires>command != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;bool&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Windows.Reactive.IViewModel">
      <summary>
            When implemented, represents a <see cref="T:System.Windows.FrameworkElement" /> attachment that may provide binding targets for properties and events.
            </summary>
    </member>
    <member name="M:System.Windows.Reactive.IViewModel.Attach(System.Windows.FrameworkElement)">
      <summary>
            Attaches this view model to the specified <paramref name="element" />.
            </summary>
      <param name="element">The <see cref="T:System.Windows.FrameworkElement" /> to which this view model must be attached.</param>
      <requires>element != null</requires>
      <requires>!IsAttached</requires>
      <ensures>IsAttached</ensures>
    </member>
    <member name="M:System.Windows.Reactive.IViewModel.Detach">
      <summary>
            Detaches this view model if it's currently attached; otherwise, performs no action.
            </summary>
      <requires>IsAttached</requires>
      <ensures>!IsAttached</ensures>
    </member>
    <member name="P:System.Windows.Reactive.IViewModel.IsAttached">
      <summary>
            Gets a value indicating whether the view model is currently attached to a <see cref="T:System.Windows.FrameworkElement" />.
            </summary>
      <value>
        <see langword="True" /> if the view model is attached; otherwise, <see langword="false" />.</value>
    </member>
    <member name="T:System.Windows.UIElementExtensions">
      <summary>
            Provides <see langword="static" /> methods for creating observables from <see cref="T:System.Windows.UIElement" /> objects.
            </summary>
    </member>
    <member name="M:System.Windows.UIElementExtensions.RoutedEventRaised(System.Windows.UIElement,System.Windows.RoutedEvent)">
      <summary>
            Gets an observable sequence of event notifications for the specified <see cref="T:System.Windows.RoutedEvent" />, 
            raised by the specified <see cref="T:System.Windows.UIElement" />.
            </summary>
      <param name="element">The <see cref="T:System.Windows.UIElement" /> on which to listen for the specified <paramref name="event" />.</param>
      <param name="event">The <see cref="T:System.Windows.RoutedEvent" /> that is raised.</param>
      <returns>An observable sequence of event notifications for the specified <see cref="T:System.Windows.RoutedEvent" />, 
            raised by the specified <see cref="T:System.Windows.UIElement" />.</returns>
      <requires>element != null</requires>
      <requires>@event != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;RoutedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.UIElementExtensions.RoutedEventRaised(System.Windows.UIElement,System.Windows.RoutedEvent,System.Boolean)">
      <summary>
            Gets an observable sequence of event notifications for the specified <see cref="T:System.Windows.RoutedEvent" />, 
            raised by the specified <see cref="T:System.Windows.UIElement" />.
            </summary>
      <param name="element">The <see cref="T:System.Windows.UIElement" /> on which to listen for the specified <paramref name="event" />.</param>
      <param name="event">The <see cref="T:System.Windows.RoutedEvent" /> that is raised.</param>
      <param name="handledEventsToo">
        <see langword="true" /> to include events marked handled in their event data; 
            <see langword="false" /> to exclude routed events that are already marked handled.</param>
      <returns>An observable sequence of event notifications for the specified <see cref="T:System.Windows.RoutedEvent" />, 
            raised by the specified <see cref="T:System.Windows.UIElement" />.</returns>
      <requires>element != null</requires>
      <requires>@event != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;RoutedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.UIElementExtensions.RoutedEventRaised``2(System.Windows.UIElement,System.Windows.RoutedEvent)">
      <summary>
            Gets an observable sequence of event notifications for the specified <see cref="T:System.Windows.RoutedEvent" />, 
            raised by the specified <see cref="T:System.Windows.UIElement" />.
            </summary>
      <typeparam name="TDelegate">Type of the delegate used by the routed event.</typeparam>
      <typeparam name="TEventArgs">Type of the object containing the routed event's arguments.</typeparam>
      <param name="element">The <see cref="T:System.Windows.UIElement" /> on which to listen for the specified <paramref name="event" />.</param>
      <param name="event">The <see cref="T:System.Windows.RoutedEvent" /> that is raised.</param>
      <returns>An observable sequence of event notifications for the specified <see cref="T:System.Windows.RoutedEvent" />, 
            raised by the specified <see cref="T:System.Windows.UIElement" />.</returns>
      <requires>element != null</requires>
      <requires>@event != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;TEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.UIElementExtensions.RoutedEventRaised``2(System.Windows.UIElement,System.Windows.RoutedEvent,System.Boolean)">
      <summary>
            Gets an observable sequence of event notifications for the specified <see cref="T:System.Windows.RoutedEvent" />, 
            raised by the specified <see cref="T:System.Windows.UIElement" />.
            </summary>
      <typeparam name="TDelegate">Type of the delegate used by the routed event.</typeparam>
      <typeparam name="TEventArgs">Type of the object containing the routed event's arguments.</typeparam>
      <param name="element">The <see cref="T:System.Windows.UIElement" /> on which to listen for the specified <paramref name="event" />.</param>
      <param name="event">The <see cref="T:System.Windows.RoutedEvent" /> that is raised.</param>
      <param name="handledEventsToo">
        <see langword="true" /> to include events marked handled in their event data; 
            <see langword="false" /> to exclude routed events that are already marked handled.</param>
      <returns>An observable sequence of event notifications for the specified <see cref="T:System.Windows.RoutedEvent" />, 
            raised by the specified <see cref="T:System.Windows.UIElement" />.</returns>
      <requires>element != null</requires>
      <requires>@event != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;TEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.ViewModel">
      <summary>
            Represents a <see cref="T:System.Windows.FrameworkElement" /> attachment that may provide binding targets for properties and events, and controls the 
            lifetime of its composited resources by permanently disposing of them when the <see cref="T:System.Windows.FrameworkElement" /> is unloaded.
            </summary>
      <remarks name="Phone">
        <para>
			A view model provides a decoupled container for the state and behaviors on which a user interface (UI) depends.  State and
			behaviors are typically represented in view models as targets for property and event bindings in the UI, without specific knowledge
			of the type or layout of the UI to which they're bound.
		</para>
        <para>
			Classic view model base classes aren't designed specifically for reactive programming with <see cref="T:System.IObservable`1" />, making them
			somewhat awkward to use in conjunction with observables.  Property bindings with <see cref="T:System.Windows.DependencyProperty" />,
			<see cref="T:System.ComponentModel.INotifyPropertyChanged" /> and event bindings with <see cref="T:System.Windows.Input.ICommand" /> are quite
			useful for decoupling a UI from its reusable state and behaviors, but they make reactive programming difficult because we must first convert
			them into observable sequences to take advantage of the capabilities of the <strong>Rx</strong> declarative programming model and LINQ.
		</para>
        <para>
          <see cref="T:Rxx.ViewModel" /> does not implement <see cref="T:System.ComponentModel.INotifyPropertyChanged" /> because it targets a reactive
			programming model instead.  To bind to a reactive property, define a <strong>DependencyProperty</strong> or implement
			<see cref="T:System.ComponentModel.INotifyPropertyChanged" /> yourself.  To create a reactive
			command, simply return an instance of <see cref="T:System.Reactive.Subjects.CommandSubject" />, then use a UI binding as you normally
			would to an <see cref="T:System.Windows.Input.ICommand" />.
		</para>
        <para>
			All of the aforementioned solutions use types that implement <see cref="T:System.IObservable`1" />, which makes it possible to define
			complex reactive queries among the different states and behaviors that are encapsulated by the view model.
		</para>
        <para>
			Furthermore, subscribing to an observable sequence yields an <see cref="T:System.IDisposable" /> artifact that represents the subscription.  It
			has a logical lifetime that is the lifetime of the UI to which the view model is attached.  Since the cancelation and disposal model of
			<strong>Rx</strong> is explicit to support fire-and-forget scenarios, often it's required to composite a view model's subscriptions
			and dispose of them when the UI is no longer needed, such as when it's unloaded.  Take a dialog window for example, which may create
			subscriptions to observable sequences that must be canceled and released when the dialog is closed.
		</para>
        <para>
          <see cref="T:Rxx.ViewModel" /> supports this by offering a composited collection of disposables that have the same lifetime as the
			<see cref="T:System.Windows.FrameworkElement" /> to which the view model is attached.  When the <see cref="E:System.Windows.FrameworkElement.Unloaded" /> event is raised,
			all of the view model's disposables are disposed, so if subscriptions to observable sequences are added to the disposables collection
			they are cancelled and freed in a determinstic manner that corresponds directly to the lifetime of the UI.
		</para>
        <para>
			Another common occurence when authoring view models is to subscribe to new observable sequences when the UI element first loads.
			<see cref="T:Rxx.ViewModel" /> facilitates this by providing an <see cref="M:Rxx.ViewModel.Attaching" /> method that derived classes can override.
			<see cref="M:Rxx.ViewModel.Attaching" /> returns a sequence of <see cref="T:System.IDisposable" /> objects that are automatically added to the composited
			disposables collection of the view model.  This makes it possible to subscribe to one or more observable sequences in an iterator
			block by simply yielding each subscription as a result.  The subscriptions yielded are automatically disposed when the UI is unloaded.
		</para>
        <alert type="tip">
			To attach a <see cref="T:Rxx.ViewModel" /> to a <see cref="T:System.Windows.FrameworkElement" /> object, first define a class that derives from
			<see cref="T:Rxx.ViewModel" />.  Then use the <see cref="M:System.Windows.FrameworkElementExtensions.SetViewModel(System.Windows.FrameworkElement,System.Func{System.Object})" /> method and
			return a new instance of your class within the factory argument.
		</alert>
      </remarks>
      <threadsafety instance="false" static="true" />
      <invariant>disposables != null</invariant>
      <invariant>!IsAttached || element != null</invariant>
    </member>
    <member name="M:Rxx.ViewModel.#ctor">
      <summary>
            Constructs a new instance of the <see cref="T:Rxx.ViewModel" /> class for derived classes.
            </summary>
    </member>
    <member name="M:Rxx.ViewModel.Attaching">
      <summary>
            Called after the <see cref="T:Rxx.ViewModel" /> is attached to the <see cref="P:Rxx.ViewModel.Element" />, providing an opportunity to create a set 
            of disposable resources that must be associated with the lifetime of the <see cref="P:Rxx.ViewModel.Element" />.
            </summary>
      <returns>A sequence of <see cref="T:System.IDisposable" /> objects to be associated with the lifetime of the <see cref="P:Rxx.ViewModel.Element" /> 
            to which this <see cref="T:Rxx.ViewModel" /> is attached.  This method can return <see langword="null" />.</returns>
      <requires>IsAttached</requires>
      <ensures>IsAttached</ensures>
    </member>
    <member name="M:Rxx.ViewModel.Detaching">
      <summary>
            Called immediately before the <see cref="T:Rxx.ViewModel" /> is detached from the <see cref="P:Rxx.ViewModel.Element" />.
            </summary>
      <requires>IsAttached</requires>
    </member>
    <member name="M:Rxx.ViewModel.AddDisposables(System.IDisposable[])">
      <summary>
            Adds the specified <paramref name="disposables" /> to the <see cref="T:Rxx.ViewModel" />, associating their lifetime with the lifetime 
            of the view model.
            </summary>
      <param name="disposables">An array of <see cref="T:System.IDisposable" /> objects to be added.</param>
      <requires>disposables != null</requires>
    </member>
    <member name="M:Rxx.ViewModel.RemoveDisposables(System.IDisposable[])">
      <summary>
            Removes and immediately disposes of the specified <paramref name="disposables" />.
            </summary>
      <param name="disposables">An array of <see cref="T:System.IDisposable" /> objects to be removed.</param>
      <requires>disposables != null</requires>
    </member>
    <member name="M:Rxx.ViewModel.ContainsDisposable(System.IDisposable)">
      <summary>
            Returns whether the <see cref="T:Rxx.ViewModel" /> contains the specified <paramref name="disposable" />.
            </summary>
      <param name="disposable">The disposable to search for.</param>
      <returns>
        <see langword="True" /> if the specified <paramref name="disposable" /> is contained by the <see cref="T:Rxx.ViewModel" />; otherwise, 
            <see langword="false" />.</returns>
    </member>
    <member name="M:Rxx.ViewModel.ClearDisposables">
      <summary>
            Removes and immediately disposes of all disposable resources that are currently contained in the view model.
            </summary>
    </member>
    <member name="M:Rxx.ViewModel.Dispose">
      <summary>
            Releases all resources used by an instance of the <see cref="T:Rxx.ViewModel" /> class, including all composited disposables that 
            were added by the <see cref="M:Rxx.ViewModel.AddDisposables(System.IDisposable[])" /> method or returned by the <see cref="M:Rxx.ViewModel.Attaching" /> method.
            </summary>
      <remarks>
            This method calls the virtual <see cref="M:Rxx.ViewModel.Dispose(System.Boolean)" /> method, passing in <see langword="true" />, and then suppresses 
            finalization of the instance.
            </remarks>
    </member>
    <member name="M:Rxx.ViewModel.Dispose(System.Boolean)">
      <summary>
            Releases the unmanaged resources used by an instance of the <see cref="T:Rxx.ViewModel" /> class and optionally releases the managed resources.
            </summary>
      <param name="disposing">
        <see langword="True" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
    </member>
    <member name="P:Rxx.ViewModel.IsAttached">
      <summary>
            Gets a value indicating whether the view model is currently attached to a <see cref="T:System.Windows.FrameworkElement" />.
            </summary>
      <value>
        <see langword="True" /> if the view model is attached; otherwise, <see langword="false" />.</value>
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == (Element != null)</ensures>
      </getter>
    </member>
    <member name="P:Rxx.ViewModel.IsInDesignMode">
      <summary>
            Gets a value indicating whether this view model instance is currently being used in a designer.
            </summary>
    </member>
    <member name="P:Rxx.ViewModel.Element">
      <summary>
            Gets the <see cref="T:System.Windows.FrameworkElement" /> to which this view model is attached.
            </summary>
      <value>The <see cref="T:System.Windows.FrameworkElement" /> to which this view model is attached when <see cref="P:Rxx.ViewModel.IsAttached" />
            is <see langword="true" />; otherwise, <see langword="null" />.</value>
      <getter>
        <ensures>(Contract.Result&lt;FrameworkElement&gt;() == null) == !IsAttached</ensures>
        <ensures>Contract.Result&lt;FrameworkElement&gt;() == element</ensures>
      </getter>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,`1},System.Collections.Generic.IEnumerable{`1}},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`1},System.Func{`0,`1},System.Func{System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.OperationalEnumerable{`1}})">
      <requires>source != null</requires>
      <requires>resultSelector != null</requires>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.DefaultBinaryOperation(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,`1})">
      <requires>first != null</requires>
      <requires>second != null</requires>
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.BinaryOperation(System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,`1})">
      <requires>second != null</requires>
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.UnaryOperation(System.Func{`0,`1})">
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`2.BinaryOperation(`0,System.Func{`0,`0,`1})">
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Collections.Generic.OperationalEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,`0},System.Collections.Generic.IEnumerable{`0}},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0},System.Func{`0,`0})">
      <requires>source != null</requires>
    </member>
    <member name="M:System.UriExtensions.EnsureNoCache(System.Uri)">
      <requires>uri != null</requires>
      <ensures>Contract.Result&lt;Uri&gt;() != null</ensures>
    </member>
    <member name="M:System.Windows.FrameworkElementExtensions.SetViewModel(System.Windows.FrameworkElement,System.Type)">
      <requires>element != null</requires>
      <requires>type != null</requires>
    </member>
    <member name="M:System.Windows.FrameworkElementExtensions.RemoveDataContextChangedHandler(System.Windows.FrameworkElement,System.Windows.DependencyPropertyChangedEventHandler)">
      <requires>element != null</requires>
      <requires>handler != null</requires>
    </member>
    <member name="M:System.Windows.FrameworkElementExtensions.AddDataContextChangedHandler(System.Windows.FrameworkElement,System.Windows.DependencyPropertyChangedEventHandler)">
      <requires>element != null</requires>
      <requires>handler != null</requires>
    </member>
    <member name="M:System.Windows.FrameworkElementExtensions.Detach(System.Windows.FrameworkElement,System.Object@,System.Windows.Reactive.IViewModel@,System.Boolean@)">
      <requires>element != null</requires>
    </member>
    <member name="M:System.Windows.FrameworkElementExtensions.Attach(System.Windows.FrameworkElement,System.Func{System.Object},System.Boolean@,System.Boolean@,System.Windows.Reactive.IViewModel@)">
      <requires>element != null</requires>
      <requires>viewModelFactory != null</requires>
      <requires>!attached</requires>
      <ensures>Contract.ValueAtReturn(out attached)</ensures>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionExtensions.GetOwner(System.Linq.Expressions.MemberExpression)">
      <requires>property != null</requires>
      <ensures>Contract.Result&lt;object&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.UInt64},System.Func{System.Collections.Generic.IEnumerable{System.UInt64},System.Collections.Generic.IEnumerable{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64},System.Collections.Generic.IEnumerable{System.UInt64}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Collections.Generic.IEnumerable{System.Int16},System.Collections.Generic.IEnumerable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.Collections.Generic.IEnumerable{System.UInt16},System.Collections.Generic.IEnumerable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Single},System.Func{System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Single},System.Func{System.Single,System.Single,System.Single},System.Collections.Generic.IEnumerable{System.Single}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Collections.Generic.IEnumerable{System.Char},System.Collections.Generic.IEnumerable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Decimal},System.Func{System.Collections.Generic.IEnumerable{System.Decimal},System.Collections.Generic.IEnumerable{System.Decimal},System.Func{System.Decimal,System.Decimal,System.Decimal},System.Collections.Generic.IEnumerable{System.Decimal}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Double},System.Func{System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Func{System.Double,System.Double,System.Double},System.Collections.Generic.IEnumerable{System.Double}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.Collections.Generic.IEnumerable{System.SByte},System.Collections.Generic.IEnumerable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Collections.Generic.IEnumerable{System.Byte},System.Collections.Generic.IEnumerable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}},System.Func{System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.Collections.Generic.IEnumerable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.UInt32},System.Func{System.Collections.Generic.IEnumerable{System.UInt32},System.Collections.Generic.IEnumerable{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32},System.Collections.Generic.IEnumerable{System.UInt32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.OperationalEnumerable.AsOperationalInternal(System.Collections.Generic.IEnumerable{System.Int64},System.Func{System.Collections.Generic.IEnumerable{System.Int64},System.Collections.Generic.IEnumerable{System.Int64},System.Func{System.Int64,System.Int64,System.Int64},System.Collections.Generic.IEnumerable{System.Int64}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalEnumerable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.Enumerable2.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <requires>source != null</requires>
      <requires>onNext != null</requires>
    </member>
    <member name="T:System.Linq.Cursor`1">
      <invariant>disposables != null</invariant>
      <invariant>source != null</invariant>
      <invariant>sourceEnumerator != null</invariant>
      <invariant>elements != null</invariant>
      <invariant>branches != null</invariant>
      <invariant>currentIndex &gt;= 0</invariant>
      <invariant>currentIndex &gt;= firstElementIndex</invariant>
      <invariant>latestIndex &gt;= -1</invariant>
      <invariant>firstElementIndex &gt;= 0</invariant>
      <invariant>isForwardOnly || firstElementIndex == 0</invariant>
      <invariant>latestIndex == -1 || firstElementIndex &gt; 0 || elements.Count &gt; 0</invariant>
      <invariant>currentIndex &gt; latestIndex || elements.Count &gt;= latestIndex - currentIndex</invariant>
      <invariant>stopped || latestIndex &lt; firstElementIndex + elements.Count</invariant>
      <invariant>!stopped || latestIndex &lt; firstElementIndex + (elements.Count - oneForTerminationNotification)</invariant>
      <invariant>!stopped || firstElementIndex &lt;= latestIndex + oneForTerminationNotification</invariant>
      <invariant>!stopped || currentIndex &lt;= latestIndex + oneForTerminationNotification</invariant>
      <invariant description="Completion must enqueue an OnError or OnCompleted notification in addition to any memoized OnNext notifications.">!stopped || elements.Count &gt; 0</invariant>
    </member>
    <member name="M:System.Linq.Cursor`1.Branch">
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
      <requires>source != null</requires>
      <ensures>IsForwardOnly == isForwardOnly</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.Move(System.Int32)">
      <ensures>elements.Count &lt;= Contract.OldValue(elements.Count)</ensures>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="T:System.Linq.Cursor`1.CursorBranch">
      <invariant>disposables != null</invariant>
      <invariant>cursor != null</invariant>
      <invariant>cursor.branches != null</invariant>
      <invariant>cursor.elements != null</invariant>
      <invariant>cursor.latestIndex &gt;= -1</invariant>
      <invariant>IsForwardOnly == cursor.IsForwardOnly</invariant>
      <invariant>LatestIndex == cursor.LatestIndex</invariant>
      <invariant>IsSequenceTerminated == cursor.IsSequenceTerminated</invariant>
      <invariant>currentIndex &gt;= 0</invariant>
      <invariant>currentIndex &gt;= cursor.firstElementIndex</invariant>
      <invariant>currentIndex &gt; cursor.latestIndex || cursor.elements.Count &gt;= cursor.latestIndex - currentIndex</invariant>
      <invariant>!cursor.stopped || currentIndex &lt;= cursor.latestIndex + oneForTerminationNotification</invariant>
    </member>
    <member name="P:System.Linq.Cursor`1.CursorBranch.IsSequenceTerminated">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.stopped</ensures>
      </getter>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.Branch">
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.#ctor(System.Linq.Cursor{`0},System.Int32,System.Reactive.Disposables.CompositeDisposable)">
      <requires>cursor != null</requires>
      <requires>cursor.branches != null</requires>
      <requires>cursor.elements != null</requires>
      <requires>cursor.latestIndex &gt;= -1</requires>
      <requires>currentIndex &gt;= 0</requires>
      <requires>currentIndex &gt;= cursor.firstElementIndex</requires>
      <requires>currentIndex &gt; cursor.latestIndex || cursor.elements.Count &gt;= cursor.latestIndex - currentIndex</requires>
      <requires>!cursor.stopped || currentIndex &lt;= cursor.latestIndex + 1</requires>
      <requires>parentDisposables != null</requires>
      <ensures>this.cursor == cursor</ensures>
      <ensures>this.currentIndex == currentIndex</ensures>
      <ensures>IsForwardOnly == cursor.IsForwardOnly</ensures>
      <ensures>IsSequenceTerminated == cursor.IsSequenceTerminated</ensures>
      <ensures>LatestIndex == cursor.latestIndex</ensures>
      <ensures>CurrentIndex == currentIndex</ensures>
      <ensures>AtEndOfSequence == (cursor.IsSequenceTerminated &amp;&amp; currentIndex == cursor.latestIndex + 1)</ensures>
      <ensures>cursor.AtEndOfSequence == Contract.OldValue(cursor.AtEndOfSequence)</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.EnsureNotDisposed">
      <ensures>!disposed</ensures>
      <ensures>currentIndex == Contract.OldValue(currentIndex)</ensures>
      <ensures>cursor.latestIndex == Contract.OldValue(cursor.latestIndex)</ensures>
      <ensures>cursor.elements.Count == Contract.OldValue(cursor.elements.Count)</ensures>
      <ensures>cursor.stopped == Contract.OldValue(cursor.stopped)</ensures>
      <ensures>cursor.firstElementIndex == Contract.OldValue(cursor.firstElementIndex)</ensures>
      <ensures>AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
    </member>
    <member name="P:System.Linq.Cursor`1.CursorBranch.IsForwardOnly">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.isForwardOnly</ensures>
      </getter>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="P:System.Linq.Cursor`1.CursorBranch.CurrentIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == currentIndex</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_CurrentIndex" inheritedFromTypeName="ICursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_CurrentIndex" inheritedFromTypeName="ICursor">!IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
      <setter>
        <requires>value &gt;= 0</requires>
        <requires>value &lt;= LatestIndex + 1</requires>
      </setter>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:System.Linq.Cursor`1.CursorBranch.AtEndOfSequence">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == (cursor.stopped &amp;&amp; currentIndex == cursor.latestIndex + 1)</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_AtEndOfSequence" inheritedFromTypeName="ICursor">Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.Dispose">
      <ensures>disposed</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.Reset">
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">CurrentIndex == 0</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">LatestIndex == -1</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">!IsSequenceTerminated</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.CursorBranch.Move(System.Int32)">
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="P:System.Linq.Cursor`1.CursorBranch.LatestIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == cursor.latestIndex</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_LatestIndex" inheritedFromTypeName="ICursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="P:System.Linq.Cursor`1.CurrentIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == currentIndex</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_CurrentIndex" inheritedFromTypeName="ICursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_CurrentIndex" inheritedFromTypeName="ICursor">!IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
    </member>
    <member name="M:System.Linq.Cursor`1.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:System.Linq.Cursor`1.IsSequenceTerminated">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == stopped</ensures>
      </getter>
    </member>
    <member name="M:System.Linq.Cursor`1.Terminated">
      <requires>!stopped</requires>
      <ensures>stopped</ensures>
      <ensures>latestIndex == Contract.OldValue(latestIndex)</ensures>
      <ensures>currentIndex &lt;= latestIndex + oneForTerminationNotification</ensures>
      <ensures>firstElementIndex &lt;= latestIndex + oneForTerminationNotification</ensures>
      <ensures>elements.Count == Contract.OldValue(elements.Count)</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.GetLowestIndex">
      <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      <ensures>Contract.Result&lt;int&gt;() &lt;= currentIndex</ensures>
      <ensures>IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures>CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures>LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>firstElementIndex == Contract.OldValue(firstElementIndex)</ensures>
      <ensures>elements.Count == Contract.OldValue(elements.Count)</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.RemovePassedElements">
      <requires>isForwardOnly</requires>
      <ensures>CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures>LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>firstElementIndex &gt;= Contract.OldValue(firstElementIndex)</ensures>
      <ensures>elements.Count &lt;= Contract.OldValue(elements.Count)</ensures>
      <ensures>(Contract.OldValue(elements.Count) - elements.Count) &lt;= (firstElementIndex - Contract.OldValue(firstElementIndex))</ensures>
    </member>
    <member name="P:System.Linq.Cursor`1.AtEndOfSequence">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == (stopped &amp;&amp; currentIndex == latestIndex + oneForTerminationNotification)</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_AtEndOfSequence" inheritedFromTypeName="ICursor">Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="M:System.Linq.Cursor`1.Dispose">
      <ensures>disposed</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.Reset(System.Boolean)">
      <ensures>!stopped</ensures>
      <ensures>currentIndex == 0</ensures>
      <ensures>latestIndex == -1</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.OnError(System.Exception)">
      <requires>error != null</requires>
    </member>
    <member name="P:System.Linq.Cursor`1.LatestIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == latestIndex</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_LatestIndex" inheritedFromTypeName="ICursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:System.Linq.Cursor`1.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.GetExistingElements(System.Int32,System.Int32)">
      <requires>startIndex &gt;= -1</requires>
      <requires>!stopped || startIndex &lt;= latestIndex + oneForTerminationNotification</requires>
      <requires>stopped || startIndex &lt;= latestIndex</requires>
      <requires>count &gt; 0</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;Notification&lt;T&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Linq.Cursor`1.EnsureNotDisposed">
      <ensures>!disposed</ensures>
      <ensures>CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures>LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures>firstElementIndex == Contract.OldValue(firstElementIndex)</ensures>
      <ensures>elements.Count == Contract.OldValue(elements.Count)</ensures>
    </member>
    <member name="P:System.Linq.Cursor`1.IsForwardOnly">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == isForwardOnly</ensures>
      </getter>
    </member>
    <member name="M:System.Linq.Cursor`1.ToString(System.Int32,System.String)">
      <requires>index &gt;= 0</requires>
      <ensures>Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Tuple`3.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.ServiceModel.Syndication.SyndicationFeedFormatterExtensions.GetFeed(System.IO.Stream,System.ServiceModel.Syndication.SyndicationFeedFormatter)">
      <requires>stream != null</requires>
      <requires>formatter != null</requires>
      <ensures>Contract.Result&lt;SyndicationFeed&gt;() != null</ensures>
    </member>
    <member name="T:System.Lazy`1">
      <invariant>valueFactory != null</invariant>
    </member>
    <member name="M:System.Lazy`1.#ctor(System.Func{`0})">
      <requires>valueFactory != null</requires>
    </member>
    <member name="M:System.IO.StreamExtensions.ReadToEndObservable(System.IO.Stream,System.Byte[])">
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>buffer != null</requires>
      <requires>buffer.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.IO.StreamExtensions.ReadObservable(System.IO.Stream,System.Byte[])">
      <requires>stream != null</requires>
      <requires>stream.CanRead</requires>
      <requires>buffer != null</requires>
      <requires>buffer.Length &gt; 0</requires>
      <ensures>Contract.Result&lt;IObservable&lt;byte[]&gt;&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.SynchronizedObservableCursor`1">
      <invariant>gate != null</invariant>
      <invariant>cursor != null</invariant>
    </member>
    <member name="M:System.Reactive.SynchronizedObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">observer != null</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">count &gt;= 0</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="P:System.Reactive.SynchronizedObservableCursor`1.IsSynchronized">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;()</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.SynchronizedObservableCursor`1.#ctor(System.Reactive.IObservableCursor{`0},System.Object)">
      <requires>cursor != null</requires>
      <ensures>IsSynchronized</ensures>
      <ensures>IsForwardOnly == cursor.IsForwardOnly</ensures>
    </member>
    <member name="M:System.Reactive.SynchronizedObservableCursor`1.Move(System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="P:System.Reactive.SynchronizedObservableCursor`1.CurrentIndex">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.SynchronizedObservableCursor`1.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:System.Reactive.SynchronizedObservableCursor`1.AtEndOfSequence">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">!Contract.Result&lt;bool&gt;() || IsSequenceTerminated</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.SynchronizedObservableCursor`1.Branch">
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSynchronized == IsSynchronized</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="P:System.Reactive.SynchronizedObservableCursor`1.LatestIndex">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_LatestIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.UInt64},System.Func{System.IObservable{System.UInt64},System.IObservable{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64},System.IObservable{System.UInt64}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ulong&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Int16},System.Func{System.IObservable{System.Int16},System.IObservable{System.Int16},System.Func{System.Int16,System.Int16,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;short, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.UInt16},System.Func{System.IObservable{System.UInt16},System.IObservable{System.UInt16},System.Func{System.UInt16,System.UInt16,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;ushort, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Single},System.Func{System.IObservable{System.Single},System.IObservable{System.Single},System.Func{System.Single,System.Single,System.Single},System.IObservable{System.Single}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;float&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Char},System.Func{System.IObservable{System.Char},System.IObservable{System.Char},System.Func{System.Char,System.Char,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;char, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Decimal},System.Func{System.IObservable{System.Decimal},System.IObservable{System.Decimal},System.Func{System.Decimal,System.Decimal,System.Decimal},System.IObservable{System.Decimal}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;decimal&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Int32},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Double},System.Func{System.IObservable{System.Double},System.IObservable{System.Double},System.Func{System.Double,System.Double,System.Double},System.IObservable{System.Double}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;double&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.SByte},System.Func{System.IObservable{System.SByte},System.IObservable{System.SByte},System.Func{System.SByte,System.SByte,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;sbyte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Byte},System.Func{System.IObservable{System.Byte},System.IObservable{System.Byte},System.Func{System.Byte,System.Byte,System.Int32},System.IObservable{System.Int32}},System.Func{System.IObservable{System.Int32},System.IObservable{System.Int32},System.Func{System.Int32,System.Int32,System.Int32},System.IObservable{System.Int32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;byte, int&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.UInt32},System.Func{System.IObservable{System.UInt32},System.IObservable{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32},System.IObservable{System.UInt32}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;uint&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.OperationalObservable.AsOperationalInternal(System.IObservable{System.Int64},System.Func{System.IObservable{System.Int64},System.IObservable{System.Int64},System.Func{System.Int64,System.Int64,System.Int64},System.IObservable{System.Int64}})">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;long&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.ZipNext``1(System.Collections.Generic.IList{System.Collections.Generic.Queue{System.Reactive.Notification{``0}}},System.Boolean@,System.Reactive.Notification{``0},System.Int32)">
      <requires>queues != null</requires>
      <requires>(current != null) == (currentQueueIndex &gt; -1)</requires>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.GetDefaultMaxConcurrent">
      <ensures>Contract.Result&lt;int&gt;() &gt; 0</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.UsingHot``2(``1,System.Func{``1,System.IObservable{``0}})">
      <requires>resource != null</requires>
      <requires>hotObservableFactory != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.Collect``5(System.Func{System.IDisposable,``0},System.IObservable{``1},System.IObservable{System.Reactive.CollectionModification{``3}},System.Func{``1,``2},System.Func{``3,``2},System.Func{``2,``1,System.Reactive.CollectionNotification{``3}},System.Func{System.IObservable{System.Reactive.CollectionNotification{``3}},System.IObservable{System.Reactive.CollectionModification{``4}}},System.Collections.Generic.IEqualityComparer{``2})">
      <requires>subjectFactory != null</requires>
      <requires>existing != null</requires>
      <requires>changes != null</requires>
      <requires>existingKeySelector != null</requires>
      <requires>changeKeySelector != null</requires>
      <requires>existsNotificationFactory != null</requires>
      <requires>selector != null</requires>
      <requires>comparer != null</requires>
      <ensures>Contract.Result&lt;TSubject&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromAsyncPattern``4(System.FuncExtended{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3})">
      <requires>begin != null</requires>
      <requires>end != null</requires>
      <ensures>Contract.Result&lt;Func&lt;T1, T2, T3, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.While``1(System.Func{System.Boolean},System.IObservable{``0})">
      <requires>condition != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromPropertyChangedPattern(System.Object,System.Reflection.PropertyInfo)">
      <requires>source != null</requires>
      <requires>propertyInfo != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;PropertyChangedEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromEventBasedAsyncPattern``2(System.Func{System.EventHandler{``1},``0},System.Action{``0},System.Action{``0},System.Action{System.Object},System.Action,System.Action)">
      <requires>conversion != null</requires>
      <requires>addHandler != null</requires>
      <requires>removeHandler != null</requires>
      <requires>start != null</requires>
      <requires>cancel != null</requires>
      <requires>canceledOrCompleted != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;EventPattern&lt;TEventArgs&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.Linq.Observable2.FromAsyncPattern``3(System.FuncExtended{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
      <requires>begin != null</requires>
      <requires>end != null</requires>
      <ensures>Contract.Result&lt;Func&lt;T1, T2, T3, IObservable&lt;Unit&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Add.Value">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionModification`1.get_Value" inheritedFromTypeName="CollectionModification">HasValue</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Add.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Add.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">add != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">remove != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">clear != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Add.Accept(System.Action{`0},System.Action{`0},System.Action)">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">add != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">remove != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">clear != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Add.Accept(System.Collections.Generic.ICollection{`0})">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Collections.Generic.ICollection{`0})" inheritedFromTypeName="CollectionModification">collection != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Add.Kind">
      <getter>
        <ensures>Contract.Result&lt;CollectionModificationKind&gt;() == CollectionModificationKind.Add</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Add.HasValue">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.CollectionModification`1.get_HasValue" inheritedFromTypeName="CollectionModification">Contract.Result&lt;bool&gt;() == (Kind != CollectionModificationKind.Clear)</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Clear.Value">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionModification`1.get_Value" inheritedFromTypeName="CollectionModification">HasValue</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Clear.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Clear.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">add != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">remove != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">clear != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Clear.Accept(System.Action{`0},System.Action{`0},System.Action)">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">add != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">remove != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">clear != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Clear.Accept(System.Collections.Generic.ICollection{`0})">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Collections.Generic.ICollection{`0})" inheritedFromTypeName="CollectionModification">collection != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Clear.Kind">
      <getter>
        <ensures>Contract.Result&lt;CollectionModificationKind&gt;() == CollectionModificationKind.Clear</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Clear.HasValue">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.CollectionModification`1.get_HasValue" inheritedFromTypeName="CollectionModification">Contract.Result&lt;bool&gt;() == (Kind != CollectionModificationKind.Clear)</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Remove.Value">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionModification`1.get_Value" inheritedFromTypeName="CollectionModification">HasValue</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Remove.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Remove.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">add != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">remove != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionModification">clear != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Remove.Accept(System.Action{`0},System.Action{`0},System.Action)">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">add != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">remove != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionModification">clear != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionModification`1.Remove.Accept(System.Collections.Generic.ICollection{`0})">
      <requires inheritedFrom="M:System.Reactive.CollectionModification`1.Accept(System.Collections.Generic.ICollection{`0})" inheritedFromTypeName="CollectionModification">collection != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Remove.Kind">
      <getter>
        <ensures>Contract.Result&lt;CollectionModificationKind&gt;() == CollectionModificationKind.Remove</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionModification`1.Remove.HasValue">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.CollectionModification`1.get_HasValue" inheritedFromTypeName="CollectionModification">Contract.Result&lt;bool&gt;() == (Kind != CollectionModificationKind.Clear)</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex + this.Count  &lt;= array.Length</requires>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.#ctor(System.IDisposable)">
      <requires>compositedDisposable != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection">!Contract.Result&lt;bool&gt;() || this.Count &gt; 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.#ctor(System.IDisposable,System.Collections.Generic.IEqualityComparer{`0})">
      <requires>compositedDisposable != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
      <requires>e != null</requires>
    </member>
    <member name="P:System.Reactive.Subjects.DictionarySubject`2.IndexedDictionary.Values">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;TValue&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.IndexedDictionary.IndexOf(`0)">
      <ensures>Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      <ensures>Contract.Result&lt;int&gt;() &lt; Count</ensures>
    </member>
    <member name="P:System.Reactive.Subjects.DictionarySubject`2.IndexedDictionary.Keys">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;TKey&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection">this.Count &gt;= Contract.OldValue(this.Count)</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.DictionarySubject`2.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
      <requires>e != null</requires>
    </member>
    <member name="T:System.Reactive.Subjects.ReconnectableObservable`2">
      <invariant>gate != null</invariant>
      <invariant>source != null</invariant>
      <invariant>factory != null</invariant>
    </member>
    <member name="P:System.Reactive.Subjects.ReconnectableObservable`2.Subject">
      <getter>
        <ensures>Contract.Result&lt;ISubject&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.Subjects.ReconnectableObservable`2.#ctor(System.IObservable{`0},System.Func{System.Reactive.Subjects.ISubject{`0,`1}})">
      <requires>source != null</requires>
      <requires>factory != null</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection">this.Count &gt;= Contract.OldValue(this.Count)</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex + this.Count  &lt;= array.Length</requires>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyDictionarySubject`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection">!Contract.Result&lt;bool&gt;() || this.Count &gt; 0</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ReadOnlyListSubject`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:System.Reactive.Subjects.ListSubject`1.#ctor(System.IDisposable)">
      <requires>compositedDisposable != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnAdded.Value">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_Value" inheritedFromTypeName="CollectionNotification">HasValue</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnAdded.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnAdded.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnAdded.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnAdded.Kind">
      <getter>
        <ensures>Contract.Result&lt;CollectionNotificationKind&gt;() == CollectionNotificationKind.OnAdded</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnAdded.HasValue">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.CollectionNotification`1.get_HasValue" inheritedFromTypeName="CollectionNotification">Contract.Result&lt;bool&gt;() == (Kind != CollectionNotificationKind.OnCleared)</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnAdded.ReplacedValue">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_ReplacedValue" inheritedFromTypeName="CollectionNotification">Kind == CollectionNotificationKind.OnReplaced</requires>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnCleared.Value">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_Value" inheritedFromTypeName="CollectionNotification">HasValue</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnCleared.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnCleared.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnCleared.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnCleared.Kind">
      <getter>
        <ensures>Contract.Result&lt;CollectionNotificationKind&gt;() == CollectionNotificationKind.OnCleared</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnCleared.HasValue">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.CollectionNotification`1.get_HasValue" inheritedFromTypeName="CollectionNotification">Contract.Result&lt;bool&gt;() == (Kind != CollectionNotificationKind.OnCleared)</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnCleared.ReplacedValue">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_ReplacedValue" inheritedFromTypeName="CollectionNotification">Kind == CollectionNotificationKind.OnReplaced</requires>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.Exists.Value">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_Value" inheritedFromTypeName="CollectionNotification">HasValue</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.Exists.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.Exists.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.Exists.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.Exists.Kind">
      <getter>
        <ensures>Contract.Result&lt;CollectionNotificationKind&gt;() == CollectionNotificationKind.Exists</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.Exists.HasValue">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.CollectionNotification`1.get_HasValue" inheritedFromTypeName="CollectionNotification">Contract.Result&lt;bool&gt;() == (Kind != CollectionNotificationKind.OnCleared)</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.Exists.ReplacedValue">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_ReplacedValue" inheritedFromTypeName="CollectionNotification">Kind == CollectionNotificationKind.OnReplaced</requires>
      </getter>
    </member>
    <member name="T:System.Reactive.CollectionNotification`1.OnReplaced">
      <invariant>Kind == CollectionNotificationKind.OnReplaced</invariant>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnReplaced.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnReplaced.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnReplaced.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnReplaced.Kind">
      <getter>
        <ensures>Contract.Result&lt;CollectionNotificationKind&gt;() == CollectionNotificationKind.OnReplaced</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnReplaced.HasValue">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.CollectionNotification`1.get_HasValue" inheritedFromTypeName="CollectionNotification">Contract.Result&lt;bool&gt;() == (Kind != CollectionNotificationKind.OnCleared)</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnReplaced.Value">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_Value" inheritedFromTypeName="CollectionNotification">HasValue</requires>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnReplaced.ReplacedValue">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_ReplacedValue" inheritedFromTypeName="CollectionNotification">Kind == CollectionNotificationKind.OnReplaced</requires>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnRemoved.Value">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_Value" inheritedFromTypeName="CollectionNotification">HasValue</requires>
      </getter>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnRemoved.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnRemoved.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept``1(System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{`0,``0},System.Func{``0})" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="M:System.Reactive.CollectionNotification`1.OnRemoved.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)">
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">exists != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onAdded != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onReplaced != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onRemoved != null</requires>
      <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.Accept(System.Action{`0},System.Action{`0},System.Action{`0},System.Action{`0},System.Action)" inheritedFromTypeName="CollectionNotification">onCleared != null</requires>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnRemoved.Kind">
      <getter>
        <ensures>Contract.Result&lt;CollectionNotificationKind&gt;() == CollectionNotificationKind.OnRemoved</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnRemoved.HasValue">
      <getter>
        <ensures inheritedFrom="M:System.Reactive.CollectionNotification`1.get_HasValue" inheritedFromTypeName="CollectionNotification">Contract.Result&lt;bool&gt;() == (Kind != CollectionNotificationKind.OnCleared)</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.CollectionNotification`1.OnRemoved.ReplacedValue">
      <getter>
        <requires inheritedFrom="M:System.Reactive.CollectionNotification`1.get_ReplacedValue" inheritedFromTypeName="CollectionNotification">Kind == CollectionNotificationKind.OnReplaced</requires>
      </getter>
    </member>
    <member name="T:System.Reactive.AnonymousPairedObserver`2">
      <invariant>observer != null</invariant>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.#ctor(System.IObservable{`0},System.Func{System.IObservable{`0},System.IObservable{`0},System.Func{`0,`0,`1},System.IObservable{`1}},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`0,`1},System.Func{`0,`1},System.Func{`0,`1},System.Func{System.IObservable{`1},System.Reactive.OperationalObservable{`1}})">
      <requires>source != null</requires>
      <requires>resultSelector != null</requires>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.DefaultBinaryOperation(System.IObservable{`0},System.IObservable{`0},System.Func{`0,`0,`1})">
      <requires>first != null</requires>
      <requires>second != null</requires>
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.BinaryOperation(`0,System.Func{`0,`0,`1})">
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.UnaryOperation(System.Func{`0,`1})">
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`2.BinaryOperation(System.IObservable{`0},System.Func{`0,`0,`1})">
      <requires>second != null</requires>
      <requires>operation != null</requires>
      <ensures>Contract.Result&lt;OperationalObservable&lt;TOut&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.OperationalObservable`1.#ctor(System.IObservable{`0},System.Func{System.IObservable{`0},System.IObservable{`0},System.Func{`0,`0,`0},System.IObservable{`0}},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0,`0},System.Func{`0,`0},System.Func{`0,`0})">
      <requires>source != null</requires>
    </member>
    <member name="T:System.Reactive.ObservableCursor`1">
      <invariant>disposables != null</invariant>
      <invariant>!IsSynchronized</invariant>
      <invariant>subscriptions != null</invariant>
      <invariant>elements != null</invariant>
      <invariant>branches != null</invariant>
      <invariant>!connected || sourceSubscription != null</invariant>
      <invariant>currentIndex &gt;= 0</invariant>
      <invariant>currentIndex &gt;= firstElementIndex</invariant>
      <invariant>latestIndex &gt;= -1</invariant>
      <invariant>firstElementIndex &gt;= 0</invariant>
      <invariant>isForwardOnly || firstElementIndex == 0</invariant>
      <invariant>latestIndex == -1 || firstElementIndex &gt; 0 || elements.Count &gt; 0</invariant>
      <invariant>currentIndex &gt; latestIndex || elements.Count &gt;= latestIndex - currentIndex</invariant>
      <invariant>stopped || latestIndex &lt; firstElementIndex + elements.Count</invariant>
      <invariant>!stopped || latestIndex &lt; firstElementIndex + (elements.Count - oneForTerminationNotification)</invariant>
      <invariant>!stopped || firstElementIndex &lt;= latestIndex + oneForTerminationNotification</invariant>
      <invariant>!stopped || currentIndex &lt;= latestIndex + oneForTerminationNotification</invariant>
      <invariant description="Completion must enqueue an OnError or OnCompleted notification in addition to any memoized OnNext notifications.">!stopped || elements.Count &gt; 0</invariant>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.Connect">
      <ensures>latestIndex &gt;= -1</ensures>
    </member>
    <member name="T:System.Reactive.ObservableCursor`1.ObservableCursorSubscription">
      <invariant>cursor != null</invariant>
      <invariant>observer != null</invariant>
      <invariant>index &gt;= 0</invariant>
      <invariant>take &gt;= subscribeUnlimited</invariant>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorSubscription.Take">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= subscribeUnlimited</ensures>
      </getter>
      <setter>
        <requires>value &gt;= 0</requires>
      </setter>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorSubscription.Index">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorSubscription.#ctor(System.Reactive.ObservableCursor{`0},System.Int32,System.Int32,System.IObserver{`0})">
      <requires>cursor != null</requires>
      <requires>index &gt;= 0</requires>
      <requires>take == subscribeUnlimited || take &gt; 0</requires>
      <requires>observer != null</requires>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorSubscription.Observer">
      <getter>
        <ensures>Contract.Result&lt;IObserver&lt;T&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.Reset">
      <ensures>!stopped</ensures>
      <ensures>currentIndex == 0</ensures>
      <ensures>latestIndex == -1</ensures>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.IsSynchronized">
      <getter>
        <ensures>!Contract.Result&lt;bool&gt;()</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.#ctor(System.Boolean)">
      <ensures>IsForwardOnly == isForwardOnly</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.Move(System.Int32)">
      <ensures>elements.Count &lt;= Contract.OldValue(elements.Count)</ensures>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.CurrentIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == currentIndex</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.IsDisposed">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == disposed</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ToString(System.Int32,System.String)">
      <requires>index &gt;= 0</requires>
      <ensures>Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.IsSequenceTerminated">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == stopped</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.Terminated">
      <requires>!stopped</requires>
      <ensures>stopped</ensures>
      <ensures>latestIndex == Contract.OldValue(latestIndex)</ensures>
      <ensures>currentIndex &lt;= latestIndex + oneForTerminationNotification</ensures>
      <ensures>firstElementIndex &lt;= latestIndex + oneForTerminationNotification</ensures>
      <ensures>elements.Count == Contract.OldValue(elements.Count)</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.GetLowestIndex">
      <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      <ensures>Contract.Result&lt;int&gt;() &lt;= currentIndex</ensures>
      <ensures>IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures>CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures>LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>firstElementIndex == Contract.OldValue(firstElementIndex)</ensures>
      <ensures>elements.Count == Contract.OldValue(elements.Count)</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.RemovePassedElements">
      <requires>isForwardOnly</requires>
      <ensures>CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures>LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>firstElementIndex &gt;= Contract.OldValue(firstElementIndex)</ensures>
      <ensures>elements.Count &lt;= Contract.OldValue(elements.Count)</ensures>
      <ensures>(Contract.OldValue(elements.Count) - elements.Count) &lt;= (firstElementIndex - Contract.OldValue(firstElementIndex))</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32,System.Int32)">
      <requires>observer != null</requires>
      <requires>index &gt;= -1</requires>
      <requires>index == -1 || index &gt;= firstElementIndex</requires>
      <requires>index &gt; latestIndex || elements.Count &gt;= latestIndex - index</requires>
      <requires>!stopped || index &lt;= latestIndex + oneForTerminationNotification</requires>
      <requires>count &gt;= subscribeUnlimited</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
      <ensures>latestIndex &gt;= -1</ensures>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.AtEndOfSequence">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == (stopped &amp;&amp; currentIndex == latestIndex + oneForTerminationNotification)</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">!Contract.Result&lt;bool&gt;() || IsSequenceTerminated</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.Dispose">
      <ensures>disposed</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.OnError(System.Exception)">
      <requires>error != null</requires>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.LatestIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == latestIndex</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_LatestIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">observer != null</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">count &gt;= 0</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="T:System.Reactive.ObservableCursor`1.ObservableCursorBranch">
      <invariant>!IsSynchronized</invariant>
      <invariant>disposables != null</invariant>
      <invariant>cursor != null</invariant>
      <invariant>cursor.branches != null</invariant>
      <invariant>cursor.elements != null</invariant>
      <invariant>cursor.latestIndex &gt;= -1</invariant>
      <invariant>IsForwardOnly == cursor.IsForwardOnly</invariant>
      <invariant>disposed || LatestIndex == cursor.LatestIndex</invariant>
      <invariant>disposed || IsSequenceTerminated == cursor.IsSequenceTerminated</invariant>
      <invariant>currentIndex &gt;= 0</invariant>
      <invariant>disposed || currentIndex &gt;= cursor.firstElementIndex</invariant>
      <invariant>disposed || currentIndex &gt; cursor.latestIndex || cursor.elements.Count &gt;= cursor.latestIndex - currentIndex</invariant>
      <invariant>disposed || !cursor.stopped || currentIndex &lt;= cursor.latestIndex + oneForTerminationNotification</invariant>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorBranch.IsSynchronized">
      <getter>
        <ensures>!Contract.Result&lt;bool&gt;()</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorBranch.SubscribeInternal(System.IObserver{`0},System.Int32)">
      <requires>observer != null</requires>
      <requires>count &gt;= subscribeUnlimited</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorBranch.#ctor(System.Reactive.ObservableCursor{`0},System.Int32,System.Reactive.Disposables.CompositeDisposable)">
      <requires>cursor != null</requires>
      <requires>cursor.branches != null</requires>
      <requires>cursor.elements != null</requires>
      <requires>cursor.latestIndex &gt;= -1</requires>
      <requires>currentIndex &gt;= 0</requires>
      <requires>currentIndex &gt;= cursor.firstElementIndex</requires>
      <requires>currentIndex &gt; cursor.latestIndex || cursor.elements.Count &gt;= cursor.latestIndex - currentIndex</requires>
      <requires>!cursor.stopped || currentIndex &lt;= cursor.latestIndex + 1</requires>
      <requires>parentDisposables != null</requires>
      <ensures>this.cursor == cursor</ensures>
      <ensures>this.currentIndex == currentIndex</ensures>
      <ensures>!IsSynchronized</ensures>
      <ensures>IsForwardOnly == cursor.IsForwardOnly</ensures>
      <ensures>IsSequenceTerminated == cursor.IsSequenceTerminated</ensures>
      <ensures>LatestIndex == cursor.latestIndex</ensures>
      <ensures>CurrentIndex == currentIndex</ensures>
      <ensures>AtEndOfSequence == (cursor.IsSequenceTerminated &amp;&amp; currentIndex == cursor.latestIndex + 1)</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorBranch.EnsureNotDisposed">
      <ensures>!disposed</ensures>
      <ensures>currentIndex == Contract.OldValue(currentIndex)</ensures>
      <ensures>cursor.latestIndex == Contract.OldValue(cursor.latestIndex)</ensures>
      <ensures>cursor.elements.Count == Contract.OldValue(cursor.elements.Count)</ensures>
      <ensures>cursor.stopped == Contract.OldValue(cursor.stopped)</ensures>
      <ensures>cursor.firstElementIndex == Contract.OldValue(cursor.firstElementIndex)</ensures>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorBranch.IsForwardOnly">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.isForwardOnly</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorBranch.Dispose">
      <ensures>disposed</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorBranch.Move(System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorBranch.CurrentIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == currentIndex</ensures>
        <ensures>!disposed</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
      <setter>
        <requires>value &gt;= 0</requires>
        <requires>value &lt;= LatestIndex + 1</requires>
      </setter>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorBranch.IsDisposed">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == disposed</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorBranch.Subscribe(System.IObserver{`0},System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">observer != null</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">count &gt;= 0</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorBranch.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorBranch.AtEndOfSequence">
      <getter>
        <ensures>!disposed</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">!Contract.Result&lt;bool&gt;() || IsSequenceTerminated</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.ObservableCursorBranch.Branch">
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSynchronized == IsSynchronized</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorBranch.IsSequenceTerminated">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.stopped</ensures>
        <ensures>!disposed</ensures>
      </getter>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.ObservableCursorBranch.LatestIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == cursor.latestIndex</ensures>
        <ensures>!disposed</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_LatestIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.EnsureNotDisposed">
      <ensures>!disposed</ensures>
      <ensures>CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures>LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures>IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures>AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures>firstElementIndex == Contract.OldValue(firstElementIndex)</ensures>
      <ensures>elements.Count == Contract.OldValue(elements.Count)</ensures>
    </member>
    <member name="P:System.Reactive.ObservableCursor`1.IsForwardOnly">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == isForwardOnly</ensures>
      </getter>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.#ctor(System.IObservable{`0},System.Boolean)">
      <requires>source != null</requires>
      <ensures>IsForwardOnly == isForwardOnly</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.CopyExistingElementsTo(System.Reactive.Notification{`0}[],System.Int32,System.Int32)">
      <ensures>currentIndex == Contract.OldValue(currentIndex)</ensures>
      <ensures>latestIndex == Contract.OldValue(latestIndex)</ensures>
      <ensures>firstElementIndex == Contract.OldValue(firstElementIndex)</ensures>
      <ensures>elements.Count == Contract.OldValue(elements.Count)</ensures>
      <ensures>stopped == Contract.OldValue(stopped)</ensures>
    </member>
    <member name="M:System.Reactive.ObservableCursor`1.Branch">
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSynchronized == IsSynchronized</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="T:System.Reactive.AnonymousPairedObservable`2">
      <invariant>observable != null</invariant>
    </member>
    <member name="M:System.Reactive.AnonymousPairedObservable`2.Subscribe(System.Reactive.IPairedObserver{`0,`1})">
      <requires inheritedFrom="M:System.Reactive.IPairedObservable`2.Subscribe(System.Reactive.IPairedObserver{`0,`1})" inheritedFromTypeName="IPairedObservable">observer != null</requires>
      <ensures inheritedFrom="M:System.Reactive.IPairedObservable`2.Subscribe(System.Reactive.IPairedObserver{`0,`1})" inheritedFromTypeName="IPairedObservable">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:System.Tuple.Create``3(``0,``1,``2)">
      <ensures>Contract.Result&lt;Tuple&lt;T1, T2, T3&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Tuple.Create``2(``0,``1)">
      <ensures>Contract.Result&lt;Tuple&lt;T1, T2&gt;&gt;() != null</ensures>
    </member>
    <member name="P:System.ComponentModel.MemberDescriptor.Name">
      <getter>
        <ensures>!string.IsNullOrEmpty(Contract.Result&lt;string&gt;())</ensures>
      </getter>
    </member>
    <member name="T:System.ComponentModel.PropertyDescriptor">
      <invariant>property != null</invariant>
    </member>
    <member name="P:System.ComponentModel.PropertyDescriptor.PropertyType">
      <getter>
        <ensures>Contract.Result&lt;Type&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:System.ComponentModel.PropertyDescriptor.Name">
      <getter>
        <ensures inheritedFrom="M:System.ComponentModel.MemberDescriptor.get_Name" inheritedFromTypeName="MemberDescriptor">!string.IsNullOrEmpty(Contract.Result&lt;string&gt;())</ensures>
      </getter>
    </member>
    <member name="M:System.ComponentModel.PropertyDescriptor.EnsureChangeEvent">
      <ensures>Contract.Result&lt;bool&gt;() == (changeEvent != null)</ensures>
    </member>
    <member name="M:System.ComponentModel.PropertyDescriptor.#ctor(System.Reflection.PropertyInfo)">
      <requires>property != null</requires>
    </member>
    <member name="T:System.ComponentModel.EventDescriptor">
      <invariant>@event != null</invariant>
    </member>
    <member name="P:System.ComponentModel.EventDescriptor.Name">
      <getter>
        <ensures inheritedFrom="M:System.ComponentModel.MemberDescriptor.get_Name" inheritedFromTypeName="MemberDescriptor">!string.IsNullOrEmpty(Contract.Result&lt;string&gt;())</ensures>
      </getter>
    </member>
    <member name="M:System.ComponentModel.EventDescriptor.#ctor(System.Reflection.EventInfo)">
      <requires>@event != null</requires>
    </member>
    <member name="P:System.ComponentModel.EventDescriptor.EventType">
      <getter>
        <ensures>Contract.Result&lt;Type&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object)">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;PropertyDescriptor&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object)">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;EventDescriptor&gt;&gt;() != null</ensures>
    </member>
    <member name="M:System.Tuple`2.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.ComponentReflection.GetProperty(System.Object,System.String,System.StringComparison)">
      <requires>source != null</requires>
      <requires>propertyName != null</requires>
    </member>
    <member name="M:Rxx.ComponentReflection.GetProperties(System.Object)">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;PropertyDescriptor&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.ComponentReflection.GetMembers(System.Object)">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;MemberDescriptor&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.ComponentReflection.GetEvent(System.Object,System.String,System.StringComparison)">
      <requires>source != null</requires>
      <requires>eventName != null</requires>
    </member>
    <member name="M:Rxx.ComponentReflection.GetEvents(System.Object)">
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;EventDescriptor&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.AsyncResult`1">
      <invariant>gate != null</invariant>
    </member>
    <member name="P:Rxx.AsyncResult`1.IsCompleted">
      <getter>
        <requires>gate != null</requires>
      </getter>
      <setter>
        <requires>gate != null</requires>
      </setter>
    </member>
    <member name="P:Rxx.AsyncResult`1.OutOfBandData">
      <getter>
        <requires>gate != null</requires>
      </getter>
      <setter>
        <requires>gate != null</requires>
      </setter>
    </member>
    <member name="P:Rxx.AsyncResult`1.AsyncWaitHandle">
      <getter>
        <ensures>Contract.Result&lt;WaitHandle&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.AsyncResult`1.CompletedSynchronously">
      <getter>
        <requires>gate != null</requires>
      </getter>
      <setter>
        <requires>gate != null</requires>
      </setter>
    </member>
    <member name="T:Rxx.Parsers.InlineStringParser`1">
      <invariant>start != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#Character(System.Char)">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Char)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Parse(System.Linq.ICursor{System.Char},Rxx.Parsers.IParser{System.Char,`0})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#get_AnyCharacter">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_AnyCharacter" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineStringParser`1.Start">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Parser`2.get_Start" inheritedFromTypeName="Parser">Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#AnyCharacterUntil(System.String[])">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#WhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_WhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#Character(System.Globalization.UnicodeCategory)">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#AnyCharacterUntil(System.Char[])">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#AnyCharacter">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_AnyCharacter" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#InsignificantWhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#get_WhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_WhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#Parse(System.Linq.ICursor{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#get_InsignificantWhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#Character(System.Func{System.Char,System.Boolean})">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineStringParser`1.Rxx#Parsers#IStringParser{System#Char}#Word(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.InlineParser`2">
      <invariant>start != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.InlineParser`2.Rxx#Parsers#IParser{TSource@TSource}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineParser`2.Rxx#Parsers#IParser{TSource@TSource}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineParser`2.Parse(System.Linq.ICursor{`0},Rxx.Parsers.IParser{`0,`1})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineParser`2.Start">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Parser`2.get_Start" inheritedFromTypeName="Parser">Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineParser`2.Rxx#Parsers#IParser{TSource@TSource}#Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.AllParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.AllParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{`0,`1}})">
      <requires>parsers != null</requires>
    </member>
    <member name="P:Rxx.Parsers.AllParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AllParser`2.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.AllParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IParser&lt;TSource, TResult&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#CData">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_CData" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#AnyAttribute">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Content(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}})">
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, IEnumerable&lt;XObject&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Comment">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Comment" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_AnyElement">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyElement" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_AnyContent">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyContent" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_Text">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Text" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_Comment">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Comment" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.Func{System.String,System.Boolean},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires>name != null</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Text">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Text" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#AnyContent">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyContent" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_CData">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_CData" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Content(System.Func{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XText},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XText}},System.Boolean)">
      <requires>textSelector != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Attribute(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#AnyElement">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyElement" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#get_AnyAttribute">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Element(System.Func{System.String,System.Boolean},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}})">
      <requires>name != null</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParser`1.Rxx#Parsers#IXmlParser{TResult}#Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserStartBase`2.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserStartBase`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserStartBase`2.CreateCursor(System.Linq.ICursor{`0})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <ensures>Contract.Result&lt;ParserCursor&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserStartBase`2.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserStartBase`2.Parse">
      <requires>Cursor != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserStartBase`2.Cursor">
      <getter>
        <ensures>Contract.Result&lt;ParserCursor&lt;TSource&gt;&gt;() == cursor</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.AllManyUnorderedParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.AllManyUnorderedParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AllManyUnorderedParser`2.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.AllManyUnorderedParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AllManyUnorderedParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{`0,System.Collections.Generic.IEnumerable{`1}}})">
      <requires>parsers != null</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.CreateCursor(System.Reactive.IObservableCursor{`0})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <ensures>Contract.Result&lt;ObservableParserCursor&lt;TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Parse">
      <requires>Cursor != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Cursor">
      <getter>
        <ensures>Contract.Result&lt;ObservableParserCursor&lt;TSource&gt;&gt;() == cursor</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectManyInternal``4(System.Reactive.IObservableCursor{``0},Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,System.IObservable{``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},``2,System.Int32})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>parser != null</requires>
      <requires>collectionSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.SelectManyInternal``4(System.Reactive.IObservableCursor{``0},Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Func{``1,Rxx.Parsers.Reactive.IObservableParser{``0,``2}},System.Func{``1,``2,``3},System.Func{Rxx.Parsers.IParseResult{``1},Rxx.Parsers.IParseResult{``2},System.Int32})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>firstParser != null</requires>
      <requires>secondSelector != null</requires>
      <requires>resultSelector != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AtLeast``3(Rxx.Parsers.Reactive.IObservableParser{``0,``2},System.String,System.Int32,System.Int32,Rxx.Parsers.Reactive.IObservableParser{``0,``1},System.Boolean)">
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>count &gt;= 0</requires>
      <requires>maximum == -1 || maximum &gt;= count</requires>
      <requires>maximum != 0</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.Linq.ObservableParserExtensions.AmbiguousGroupInternal``1(System.Reactive.IObservableCursor{``0},Rxx.Parsers.Reactive.IObservableParser{``0,``0},Rxx.Parsers.Reactive.IObservableParser{``0,``0})">
      <requires>source != null</requires>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;IObservable&lt;TSource&gt;&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AmbiguousObservableParser`3.#ctor(Rxx.Parsers.Reactive.IObservableParser{`0,`2})">
      <requires>parser != null</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AmbiguousObservableParser`3.#ctor(Rxx.Parsers.Reactive.IObservableParser{`0,`2},System.Int32)">
      <requires>parser != null</requires>
      <requires>untilCount &gt;= 0</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AmbiguousObservableParser`3.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AmbiguousObservableParser`3.#ctor(Rxx.Parsers.Reactive.IObservableParser{`0,`2},Rxx.Parsers.Reactive.IObservableParser{`0,`1})">
      <requires>parser != null</requires>
      <requires>untilParser != null</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AmbiguousObservableParser`3.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AllManyObservableParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllManyObservableParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllManyObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllManyObservableParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllManyObservableParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{`0,System.IObservable{`1}}})">
      <requires>parsers != null</requires>
    </member>
    <member name="T:Rxx.Parsers.Reactive.InlineObservableParser`2">
      <invariant>start != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineObservableParser`2.Rxx#Parsers#Reactive#IObservableParser{TSource@TSource}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineObservableParser`2.Rxx#Parsers#Reactive#IObservableParser{TSource@TSource}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineObservableParser`2.Rxx#Parsers#Reactive#IObservableParser{TSource@TSource}#Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineObservableParser`2.Parse(System.Reactive.IObservableCursor{`0},Rxx.Parsers.Reactive.IObservableParser{`0,`1})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineObservableParser`2.Start">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParser`2.get_Start" inheritedFromTypeName="ObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AnyObservableParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnyObservableParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{`0,`1}})">
      <requires>parsers != null</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AnyObservableParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnyObservableParser`2.Parse(System.Collections.Generic.ICollection{Rxx.Parsers.Reactive.IObservableParser{`0,`1}},System.Reactive.IObservableCursor{`0})">
      <requires>except != null</requires>
      <requires>!except.IsReadOnly</requires>
      <requires>source != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnyObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AnyObservableParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IObservableParser&lt;TSource, TResult&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.ObservableParserCursor`1">
      <invariant>cursor != null</invariant>
      <invariant>cursor.IsForwardOnly</invariant>
      <invariant>branches != null</invariant>
      <invariant>IsSynchronized == cursor.IsSynchronized</invariant>
      <invariant>IsForwardOnly == cursor.IsForwardOnly</invariant>
      <invariant>IsSynchronized || CurrentIndex == cursor.CurrentIndex</invariant>
      <invariant>IsSynchronized || LatestIndex == cursor.LatestIndex</invariant>
      <invariant>IsSynchronized || AtEndOfSequence == cursor.AtEndOfSequence</invariant>
      <invariant>IsSynchronized || IsSequenceTerminated == cursor.IsSequenceTerminated</invariant>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.IsSequenceTerminated">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;bool&gt;() == cursor.IsSequenceTerminated</ensures>
        <ensures>!cursor.IsSequenceTerminated || Contract.Result&lt;bool&gt;() == true</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.IsSynchronized">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.IsSynchronized</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.#ctor(System.Reactive.IObservableCursor{`0})">
      <requires>cursor != null</requires>
      <requires>cursor.IsForwardOnly</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.IsForwardOnly">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.IsForwardOnly</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.CurrentIndex">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;int&gt;() == cursor.CurrentIndex</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
        <ensures inheritedFrom="M:Rxx.Parsers.IParserCursor`1.get_CurrentIndex" inheritedFromTypeName="IParserCursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.IsDisposed">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;bool&gt;() == cursor.IsDisposed</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.Subscribe(System.IObserver{`0},System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">observer != null</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">count &gt;= 0</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.AtEndOfSequence">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;bool&gt;() == cursor.AtEndOfSequence</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">!Contract.Result&lt;bool&gt;() || IsSequenceTerminated</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.Branch">
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSynchronized == IsSynchronized</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch">
      <invariant>branch != null</invariant>
      <invariant>branch.IsForwardOnly</invariant>
      <invariant>branches != null</invariant>
      <invariant>dispose != null</invariant>
      <invariant>IsSynchronized == branch.IsSynchronized</invariant>
      <invariant>IsForwardOnly == branch.IsForwardOnly</invariant>
      <invariant>IsSynchronized || branch.IsDisposed || CurrentIndex == branch.CurrentIndex</invariant>
      <invariant>IsSynchronized || branch.IsDisposed || LatestIndex == branch.LatestIndex</invariant>
      <invariant>IsSynchronized || branch.IsDisposed || AtEndOfSequence == branch.AtEndOfSequence</invariant>
      <invariant>IsSynchronized || branch.IsDisposed || IsSequenceTerminated == branch.IsSequenceTerminated</invariant>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.IsSynchronized">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == branch.IsSynchronized</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.#ctor(System.Reactive.IObservableCursor{`0},System.Action)">
      <requires>branch != null</requires>
      <requires>branch.IsForwardOnly</requires>
      <requires>dispose != null</requires>
      <ensures>IsSynchronized == branch.IsSynchronized</ensures>
      <ensures>IsForwardOnly == branch.IsForwardOnly</ensures>
      <ensures>IsSynchronized || CurrentIndex == branch.CurrentIndex</ensures>
      <ensures>IsSynchronized || LatestIndex == branch.LatestIndex</ensures>
      <ensures>IsSynchronized || AtEndOfSequence == branch.AtEndOfSequence</ensures>
      <ensures>IsSynchronized || IsSequenceTerminated == branch.IsSequenceTerminated</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.IsForwardOnly">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == branch.IsForwardOnly</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.Move(System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.CurrentIndex">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;int&gt;() == branch.CurrentIndex</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_CurrentIndex" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.IsDisposed">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;bool&gt;() == branch.IsDisposed</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.IsSequenceTerminated">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;bool&gt;() == branch.IsSequenceTerminated</ensures>
        <ensures>!branch.IsSequenceTerminated || Contract.Result&lt;bool&gt;() == true</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.Subscribe(System.IObserver{`0},System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">observer != null</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">count &gt;= 0</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Subscribe(System.IObserver{`0},System.Int32)" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.AtEndOfSequence">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;bool&gt;() == branch.AtEndOfSequence</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">!Contract.Result&lt;bool&gt;() || IsSequenceTerminated</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_AtEndOfSequence" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.Branch">
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSynchronized == IsSynchronized</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Branch" inheritedFromTypeName="IObservableCursor">IsSynchronized || Contract.Result&lt;IObservableCursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.ObservableParserCursorBranch.LatestIndex">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;int&gt;() == branch.LatestIndex</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_LatestIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserCursor`1.Move(System.Int32)">
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || !IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized == Contract.OldValue(IsSynchronized)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.Move(System.Int32)" inheritedFromTypeName="IObservableCursor">IsSynchronized || CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserCursor`1.LatestIndex">
      <getter>
        <ensures>IsSynchronized || Contract.Result&lt;int&gt;() == cursor.LatestIndex</ensures>
        <ensures inheritedFrom="M:System.Reactive.IObservableCursor`1.get_LatestIndex" inheritedFromTypeName="IObservableCursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserQueryContext`3.Parser">
      <getter>
        <ensures>Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.ObservableParserQueryContext`3.Rxx#Parsers#Reactive#IObservableParser{TSource@TResult}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserQueryContext`3.Rxx#Parsers#Reactive#IObservableParser{TSource@TResult}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserQueryContext`3.#ctor(Rxx.Parsers.Reactive.IObservableParser{`0,`1},`2)">
      <requires>parser != null</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserQueryContext`3.Rxx#Parsers#Reactive#IObservableParser{TSource@TResult}#Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AllUnorderedObservableParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllUnorderedObservableParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllUnorderedObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllUnorderedObservableParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IObservableParser&lt;TSource, TResult&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllUnorderedObservableParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{`0,`1}})">
      <requires>parsers != null</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Rxx#Parsers#Reactive#IObservableParser{System#Char@TResult}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Rxx#Parsers#Reactive#IObservableParser{System#Char@TResult}#Parse(System.Reactive.IObservableCursor{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.#ctor(Rxx.Parsers.Reactive.IXmlObservableParser{`0},`1)">
      <requires>parser != null</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Parser">
      <getter>
        <ensures>Contract.Result&lt;IXmlObservableParser&lt;TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParserQueryContext`2.Rxx#Parsers#Reactive#IObservableParser{System#Char@TResult}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Rxx#Parsers#Reactive#IObservableParser{System#Char@TResult}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Rxx#Parsers#Reactive#IObservableParser{System#Char@TResult}#Parse(System.Reactive.IObservableCursor{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.#ctor(Rxx.Parsers.Reactive.IStringObservableParser{`0},`1)">
      <requires>parser != null</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Parser">
      <getter>
        <ensures>Contract.Result&lt;IStringObservableParser&lt;TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParserQueryContext`2.Rxx#Parsers#Reactive#IObservableParser{System#Char@TResult}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.InlineStringObservableParser`1">
      <invariant>start != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#get_WhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_WhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#get_AnyCharacter">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_AnyCharacter" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IObservableParser{System#Char@System#Char}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#InsignificantWhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#AnyCharacterUntil(System.String[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Parse(System.Reactive.IObservableCursor{System.Char},Rxx.Parsers.Reactive.IObservableParser{System.Char,`0})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Start">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParser`2.get_Start" inheritedFromTypeName="ObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#Character(System.Char)">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Char)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IObservableParser{System#Char@System#Char}#Parse(System.Reactive.IObservableCursor{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#Word(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#AnyCharacterUntil(System.Char[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#get_InsignificantWhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#AnyCharacter">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_AnyCharacter" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#WhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_WhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IObservableParser{System#Char@System#Char}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#Character(System.Func{System.Char,System.Boolean})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineStringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{System#Char}#Character(System.Globalization.UnicodeCategory)">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.InlineXmlObservableParser`1">
      <invariant>schema != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#AnyContent">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyContent" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Comment">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Comment" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#AnyAttribute">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IObservableParser{System#Char@System#Char}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IObservableParser{System#Char@System#Char}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Parse(System.Reactive.IObservableCursor{System.Char},Rxx.Parsers.Reactive.IObservableParser{System.Char,`0})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IObservable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#get_Text">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Text" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XText&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#get_AnyAttribute">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#get_CData">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_CData" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XCData&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IObservableParser{System#Char@System#Char}#Parse(System.Reactive.IObservableCursor{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Text">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Text" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#get_Comment">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Comment" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XComment&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#AnyElement">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyElement" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#CData">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_CData" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Schema">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.XmlObservableParser`1.get_Schema" inheritedFromTypeName="XmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#Attribute(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#get_AnyContent">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyContent" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XObject&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.InlineXmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{System#Char}#get_AnyElement">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyElement" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AllManyUnorderedObservableParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllManyUnorderedObservableParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllManyUnorderedObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllManyUnorderedObservableParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IObservableParser&lt;TSource, IObservable&lt;TResult&gt;&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllManyUnorderedObservableParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{`0,System.IObservable{`1}}})">
      <requires>parsers != null</requires>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserStart`2.Parse">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Parse" inheritedFromTypeName="ObservableParserStartBase">Cursor != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.ObservableParserStartBase`2.Parse" inheritedFromTypeName="ObservableParserStartBase">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParserStart`2.#ctor(System.Func{Rxx.Parsers.Reactive.IObservableParser{`0,`0},Rxx.Parsers.Reactive.IObservableParser{`0,`1}})">
      <requires>grammar != null</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Text">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Text" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Attribute(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#get_Comment">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Comment" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XComment&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#get_Text">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Text" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XText&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#AnyContent">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyContent" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(System.Func{System.String,System.Boolean},System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}})">
      <requires>name != null</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Comment">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_Comment" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Content(System.Func{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XText},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XText}},System.Boolean)">
      <requires>textSelector != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XObject&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#AnyAttribute">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Element(System.Func{System.String,System.Boolean},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires>name != null</requires>
      <requires>attributes != null</requires>
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#AnyElement">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyElement" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#get_AnyElement">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyElement" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#get_CData">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_CData" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XCData&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#CData">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_CData" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Content(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}})">
      <requires>content != null</requires>
      <ensures>Contract.Result&lt;IObservableParser&lt;char, IObservable&lt;XObject&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#get_AnyContent">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyContent" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XObject&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(System.String,Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#get_AnyAttribute">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.XmlObservableParser`1.Rxx#Parsers#Reactive#IXmlObservableParser{TResult}#Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IXmlObservableParser`1.Element(Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XAttribute}},Rxx.Parsers.Reactive.IObservableParser{System.Char,System.IObservable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlObservableParser">Contract.Result&lt;IObservableParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.ObservableParser`2.Rxx#Parsers#Reactive#IObservableParser{TSource@TResult}#Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#get_AnyCharacter">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_AnyCharacter" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.InsignificantWhiteSpaceCached">
      <getter>
        <ensures>Contract.Result&lt;ICollection&lt;char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#get_InsignificantWhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#Character(System.Globalization.UnicodeCategory)">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#get_WhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_WhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#Word(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Word(System.String)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#Character(System.Func{System.Char,System.Boolean})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#AnyCharacterUntil(System.String[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#AnyCharacter">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_AnyCharacter" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#AnyCharacterUntil(System.Char[])">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#WhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_WhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#InsignificantWhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.StringObservableParser`1.Rxx#Parsers#Reactive#IStringObservableParser{TResult}#Character(System.Char)">
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IStringObservableParser`1.Character(System.Char)" inheritedFromTypeName="IStringObservableParser">Contract.Result&lt;IObservableParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AllObservableParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllObservableParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.Reactive.IObservableParser{`0,`1}})">
      <requires>parsers != null</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllObservableParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AllObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AllObservableParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IObservableParser&lt;TSource, TResult&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.Reactive.AnonymousObservableParser`2">
      <invariant>name == null || name.Length &gt; 0</invariant>
      <invariant>parse != null || parserFactory != null</invariant>
      <invariant>getNext != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnonymousObservableParser`2.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnonymousObservableParser`2.#ctor(System.String,System.Func{Rxx.Parsers.Reactive.IObservableParser{`0,`1}})">
      <requires>name == null || name.Length &gt; 0</requires>
      <requires>parserFactory != null</requires>
    </member>
    <member name="P:Rxx.Parsers.Reactive.AnonymousObservableParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.get_Next" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservableParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnonymousObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.Reactive.IObservableParser`2.Parse(System.Reactive.IObservableCursor{`0})" inheritedFromTypeName="IObservableParser">Contract.Result&lt;IObservable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Reactive.AnonymousObservableParser`2.#ctor(System.String,System.Func{Rxx.Parsers.Reactive.IObservableParser{`0,`0}},System.Func{System.Reactive.IObservableCursor{`0},System.IObservable{Rxx.Parsers.IParseResult{`1}}})">
      <requires>name == null || name.Length &gt; 0</requires>
      <requires>getNext != null</requires>
      <requires>parse != null</requires>
    </member>
    <member name="T:Rxx.Parsers.ParserCursor`1">
      <invariant>cursor != null</invariant>
      <invariant>cursor.IsForwardOnly</invariant>
      <invariant>branches != null</invariant>
      <invariant>IsForwardOnly == cursor.IsForwardOnly</invariant>
      <invariant>CurrentIndex == cursor.CurrentIndex</invariant>
      <invariant>LatestIndex == cursor.LatestIndex</invariant>
      <invariant>AtEndOfSequence == cursor.AtEndOfSequence</invariant>
      <invariant>IsSequenceTerminated == cursor.IsSequenceTerminated</invariant>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.IsSequenceTerminated">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.IsSequenceTerminated</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.Branch">
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="T:Rxx.Parsers.ParserCursor`1.ParserCursorBranch">
      <invariant>branch != null</invariant>
      <invariant>branch.IsForwardOnly</invariant>
      <invariant>branches != null</invariant>
      <invariant>dispose != null</invariant>
      <invariant>IsForwardOnly == branch.IsForwardOnly</invariant>
      <invariant>CurrentIndex == branch.CurrentIndex</invariant>
      <invariant>LatestIndex == branch.LatestIndex</invariant>
      <invariant>AtEndOfSequence == branch.AtEndOfSequence</invariant>
      <invariant>IsSequenceTerminated == branch.IsSequenceTerminated</invariant>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.Branch">
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">CurrentIndex == Contract.OldValue(CurrentIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">AtEndOfSequence == Contract.OldValue(AtEndOfSequence)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsForwardOnly == IsForwardOnly</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().IsSequenceTerminated == IsSequenceTerminated</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().LatestIndex == LatestIndex</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().CurrentIndex == CurrentIndex</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Branch" inheritedFromTypeName="ICursor">Contract.Result&lt;ICursor&lt;T&gt;&gt;().AtEndOfSequence == AtEndOfSequence</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.Reset">
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">CurrentIndex == 0</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">LatestIndex == -1</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">!IsSequenceTerminated</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.#ctor(System.Linq.ICursor{`0},System.Action)">
      <requires>branch != null</requires>
      <requires>branch.IsForwardOnly</requires>
      <requires>dispose != null</requires>
      <ensures>IsForwardOnly == branch.IsForwardOnly</ensures>
      <ensures>CurrentIndex == branch.CurrentIndex</ensures>
      <ensures>LatestIndex == branch.LatestIndex</ensures>
      <ensures>AtEndOfSequence == branch.AtEndOfSequence</ensures>
      <ensures>IsSequenceTerminated == branch.IsSequenceTerminated</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.IsForwardOnly">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == branch.IsForwardOnly</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.Move(System.Int32)">
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.IsSequenceTerminated">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == branch.IsSequenceTerminated</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.CurrentIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == branch.CurrentIndex</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_CurrentIndex" inheritedFromTypeName="ICursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_CurrentIndex" inheritedFromTypeName="ICursor">!IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.AtEndOfSequence">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == branch.AtEndOfSequence</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_AtEndOfSequence" inheritedFromTypeName="ICursor">Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.ParserCursorBranch.LatestIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == branch.LatestIndex</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_LatestIndex" inheritedFromTypeName="ICursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.#ctor(System.Linq.ICursor{`0})">
      <requires>cursor != null</requires>
      <requires>cursor.IsForwardOnly</requires>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.IsForwardOnly">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.IsForwardOnly</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.Move(System.Int32)">
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!IsForwardOnly || count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!AtEndOfSequence || count &lt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">CurrentIndex + count &gt;= 0</requires>
      <requires inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">!IsSequenceTerminated || CurrentIndex + count &lt;= LatestIndex + 1</requires>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">IsSequenceTerminated == Contract.OldValue(IsSequenceTerminated)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">LatestIndex == Contract.OldValue(LatestIndex)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Move(System.Int32)" inheritedFromTypeName="ICursor">CurrentIndex == Contract.OldValue(CurrentIndex) + count</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.CurrentIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == cursor.CurrentIndex</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_CurrentIndex" inheritedFromTypeName="ICursor">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_CurrentIndex" inheritedFromTypeName="ICursor">!IsSequenceTerminated || Contract.Result&lt;int&gt;() &lt;= LatestIndex + 1</ensures>
        <ensures inheritedFrom="M:Rxx.Parsers.IParserCursor`1.get_CurrentIndex" inheritedFromTypeName="IParserCursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.AtEndOfSequence">
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == cursor.AtEndOfSequence</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_AtEndOfSequence" inheritedFromTypeName="ICursor">Contract.Result&lt;bool&gt;() == (IsSequenceTerminated &amp;&amp; CurrentIndex == LatestIndex + 1)</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserCursor`1.Reset">
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">IsForwardOnly == Contract.OldValue(IsForwardOnly)</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">CurrentIndex == 0</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">LatestIndex == -1</ensures>
      <ensures inheritedFrom="M:System.Linq.ICursor`1.Reset" inheritedFromTypeName="ICursor">!IsSequenceTerminated</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserCursor`1.LatestIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == cursor.LatestIndex</ensures>
        <ensures inheritedFrom="M:System.Linq.ICursor`1.get_LatestIndex" inheritedFromTypeName="ICursor">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.#ctor(Rxx.Parsers.IStringParser{`0},`1)">
      <requires>parser != null</requires>
    </member>
    <member name="P:Rxx.Parsers.StringParserQueryContext`2.Parser">
      <getter>
        <ensures>Contract.Result&lt;IStringParser&lt;TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#Parse(System.Linq.ICursor{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserQueryContext`3.Rxx#Parsers#IParser{TSource@TResult}#Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.ParserQueryContext`3.Parser">
      <getter>
        <ensures>Contract.Result&lt;IParser&lt;TSource, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.ParserQueryContext`3.Rxx#Parsers#IParser{TSource@TResult}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParserQueryContext`3.Rxx#Parsers#IParser{TSource@TResult}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserQueryContext`3.#ctor(Rxx.Parsers.IParser{`0,`1},`2)">
      <requires>parser != null</requires>
    </member>
    <member name="T:Rxx.Parsers.LookAheadParseResult`1">
      <invariant>subject != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.LookAheadParseResult`1.#ctor(System.Int32)">
      <requires>length &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.LookAheadParseResult`1.#ctor(`0,System.Int32)">
      <requires>length &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.ParserStart`2.Parse">
      <requires inheritedFrom="M:Rxx.Parsers.ParserStartBase`2.Parse" inheritedFromTypeName="ParserStartBase">Cursor != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.ParserStartBase`2.Parse" inheritedFromTypeName="ParserStartBase">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParserStart`2.#ctor(System.Func{Rxx.Parsers.IParser{`0,`0},Rxx.Parsers.IParser{`0,`1}})">
      <requires>grammar != null</requires>
    </member>
    <member name="T:Rxx.Parsers.AllUnorderedParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.AllUnorderedParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AllUnorderedParser`2.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.AllUnorderedParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IParser&lt;TSource, TResult&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AllUnorderedParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{`0,`1}})">
      <requires>parsers != null</requires>
    </member>
    <member name="M:Rxx.Parsers.AmbiguousParser`2.#ctor(Rxx.Parsers.IParser{`0,`1})">
      <requires>parser != null</requires>
    </member>
    <member name="M:Rxx.Parsers.AmbiguousParser`2.#ctor(Rxx.Parsers.IParser{`0,`1},System.Int32)">
      <requires>parser != null</requires>
      <requires>untilCount &gt;= 0</requires>
    </member>
    <member name="P:Rxx.Parsers.AmbiguousParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AmbiguousParser`2.#ctor(Rxx.Parsers.IParser{`0,`1},System.Func{System.Linq.ICursor{`0},System.Boolean})">
      <requires>parser != null</requires>
      <requires>untilPredicate != null</requires>
    </member>
    <member name="M:Rxx.Parsers.AmbiguousParser`2.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AtLeast``3(Rxx.Parsers.IParser{``0,``2},System.String,System.Int32,System.Int32,Rxx.Parsers.IParser{``0,``1},System.Boolean)">
      <requires>parser != null</requires>
      <requires>!string.IsNullOrEmpty(name)</requires>
      <requires>count &gt;= 0</requires>
      <requires>maximum == -1 || maximum &gt;= count</requires>
      <requires>maximum != 0</requires>
      <ensures>Contract.Result&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.Linq.ParserExtensions.AmbiguousGroupRun``1(System.Int32@,System.Linq.ICursor{``0},Rxx.Parsers.IParser{``0,``0},Rxx.Parsers.IParser{``0,``0},System.Collections.Generic.List{System.Action{Rxx.Parsers.IParseResult{``0}}},System.Collections.Generic.List{System.Action{Rxx.Parsers.IParseResult{``0}}},System.Collections.Generic.List{System.Action{Rxx.Parsers.IParseResult{``0}}})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>open != null</requires>
      <requires>close != null</requires>
      <requires>openSinks != null</requires>
      <requires>closeSinks != null</requires>
      <requires>contentSinks != null</requires>
    </member>
    <member name="T:Rxx.Parsers.InlineXmlParser`1">
      <invariant>schema != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#AnyAttribute">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{System.String},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#CData">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_CData" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">attributes != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_AnyAttribute">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyAttribute" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_Text">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Text" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_AnyElement">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyElement" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(Rxx.Parsers.IParser{System.Char,System.Collections.Generic.IEnumerable{System.Xml.Linq.XObject}})" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Text">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Text" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XText&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.String,System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_AnyContent">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyContent" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_Comment">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Comment" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#AnyElement">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyElement" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IParser{System#Char@System#Char}#Parse(System.Linq.ICursor{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Parse(System.Linq.ICursor{System.Char},Rxx.Parsers.IParser{System.Char,`0})">
      <requires>source != null</requires>
      <requires>source.IsForwardOnly</requires>
      <requires>grammar != null</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TResult&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Attribute(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">!string.IsNullOrEmpty(name)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Attribute(System.String)" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XAttribute&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Comment">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_Comment" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XComment&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Schema">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.XmlParser`1.get_Schema" inheritedFromTypeName="XmlParser">Contract.Result&lt;IParser&lt;char, TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#AnyContent">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_AnyContent" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XObject&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])">
      <requires inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">content != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.Element(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XAttribute}},Rxx.Parsers.IParser{System.Char,System.Xml.Linq.XObject}[])" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XElement&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.InlineXmlParser`1.Rxx#Parsers#IXmlParser{System#Char}#get_CData">
      <ensures inheritedFrom="M:Rxx.Parsers.IXmlParser`1.get_CData" inheritedFromTypeName="IXmlParser">Contract.Result&lt;IParser&lt;char, XCData&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#get_Next">
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.#ctor(Rxx.Parsers.IXmlParser{`0},`1)">
      <requires>parser != null</requires>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.Parser">
      <getter>
        <ensures>Contract.Result&lt;IXmlParser&lt;TResult&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.XmlParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#Parse(System.Linq.ICursor{System.Char})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.XmlParserQueryContext`2.Rxx#Parsers#IParser{System#Char@TResult}#Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#Character(System.Globalization.UnicodeCategory)">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Globalization.UnicodeCategory)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#AnyCharacterUntil(System.String[])">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">stopWords.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.String[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#AnyCharacter">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_AnyCharacter" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#Character(System.Func{System.Char,System.Boolean})">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">predicate != null</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Func{System.Char,System.Boolean})" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#get_WhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_WhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.InsignificantWhiteSpaceCached">
      <getter>
        <ensures>Contract.Result&lt;ICollection&lt;char&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#Character(System.Char)">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Character(System.Char)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#get_InsignificantWhiteSpace">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#get_AnyCharacter">
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_AnyCharacter" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, char&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#WhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_WhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#InsignificantWhiteSpace">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.get_InsignificantWhiteSpace" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#AnyCharacterUntil(System.Char[])">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">stops.Length &gt; 0</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.AnyCharacterUntil(System.Char[])" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.StringParser`1.Rxx#Parsers#IStringParser{TResult}#Word(System.String)">
      <requires inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">!string.IsNullOrEmpty(value)</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IStringParser`1.Word(System.String)" inheritedFromTypeName="IStringParser">Contract.Result&lt;IParser&lt;char, string&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.AnonymousParser`2">
      <invariant>name == null || name.Length &gt; 0</invariant>
      <invariant>parse != null || parserFactory != null</invariant>
      <invariant>getNext != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.AnonymousParser`2.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.AnonymousParser`2.#ctor(System.String,System.Func{Rxx.Parsers.IParser{`0,`1}})">
      <requires>name == null || name.Length &gt; 0</requires>
      <requires>parserFactory != null</requires>
    </member>
    <member name="P:Rxx.Parsers.AnonymousParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AnonymousParser`2.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.AnonymousParser`2.#ctor(System.String,System.Func{Rxx.Parsers.IParser{`0,`0}},System.Func{System.Linq.ICursor{`0},System.Collections.Generic.IEnumerable{Rxx.Parsers.IParseResult{`1}}})">
      <requires>name == null || name.Length &gt; 0</requires>
      <requires>getNext != null</requires>
      <requires>parse != null</requires>
    </member>
    <member name="P:Rxx.Parsers.IParserCursor`1.CurrentIndex">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= -1</ensures>
      </getter>
    </member>
    <member name="T:Rxx.Parsers.AllManyParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="M:Rxx.Parsers.AllManyParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{`0,System.Collections.Generic.IEnumerable{`1}}})">
      <requires>parsers != null</requires>
    </member>
    <member name="P:Rxx.Parsers.AllManyParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AllManyParser`2.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.AllManyParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IParser&lt;TSource, IEnumerable&lt;TResult&gt;&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.Parser`2.Rxx#Parsers#IParser{TSource@TResult}#Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.ParseResult`1">
      <invariant>length &gt;= 0</invariant>
    </member>
    <member name="M:Rxx.Parsers.ParseResult`1.#ctor(System.Int32)">
      <requires>length &gt;= 0</requires>
    </member>
    <member name="M:Rxx.Parsers.ParseResult`1.#ctor(`0,System.Int32)">
      <requires>length &gt;= 0</requires>
    </member>
    <member name="P:Rxx.Parsers.ParseResult`1.Length">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParseResult`1.get_Length" inheritedFromTypeName="IParseResult">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.YieldMany``1(Rxx.Parsers.IParseResult{``0},``0,System.Int32)">
      <requires>result != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;IEnumerable&lt;TValue&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Rxx.Parsers.ParseResult.Yield``2(Rxx.Parsers.IParseResult{``0},``1,System.Int32)">
      <requires>result != null</requires>
      <requires>length &gt;= 0</requires>
      <ensures>Contract.Result&lt;IParseResult&lt;TNewValue&gt;&gt;() != null</ensures>
    </member>
    <member name="T:Rxx.Parsers.AnyParser`2">
      <invariant>parsers != null</invariant>
    </member>
    <member name="P:Rxx.Parsers.AnyParser`2.Next">
      <getter>
        <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.get_Next" inheritedFromTypeName="IParser">Contract.Result&lt;IParser&lt;TSource, TSource&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AnyParser`2.Parse(System.Linq.ICursor{`0})">
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source != null</requires>
      <requires inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">source.IsForwardOnly</requires>
      <ensures inheritedFrom="M:Rxx.Parsers.IParser`2.Parse(System.Linq.ICursor{`0})" inheritedFromTypeName="IParser">Contract.Result&lt;IEnumerable&lt;IParseResult&lt;TResult&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="P:Rxx.Parsers.AnyParser`2.Parsers">
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IParser&lt;TSource, TResult&gt;&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Rxx.Parsers.AnyParser`2.#ctor(System.Collections.Generic.IEnumerable{Rxx.Parsers.IParser{`0,`1}})">
      <requires>parsers != null</requires>
    </member>
    <member name="M:Rxx.ViewModel.System#Windows#Reactive#IViewModel#Attach(System.Windows.FrameworkElement)">
      <requires inheritedFrom="M:System.Windows.Reactive.IViewModel.Attach(System.Windows.FrameworkElement)" inheritedFromTypeName="IViewModel">element != null</requires>
      <requires inheritedFrom="M:System.Windows.Reactive.IViewModel.Attach(System.Windows.FrameworkElement)" inheritedFromTypeName="IViewModel">!IsAttached</requires>
      <ensures inheritedFrom="M:System.Windows.Reactive.IViewModel.Attach(System.Windows.FrameworkElement)" inheritedFromTypeName="IViewModel">IsAttached</ensures>
    </member>
    <member name="M:Rxx.ViewModel.System#Windows#Reactive#IViewModel#Detach">
      <requires inheritedFrom="M:System.Windows.Reactive.IViewModel.Detach" inheritedFromTypeName="IViewModel">IsAttached</requires>
      <ensures inheritedFrom="M:System.Windows.Reactive.IViewModel.Detach" inheritedFromTypeName="IViewModel">!IsAttached</ensures>
    </member>
    <member name="M:Rxx.ViewModel.EnsureNotDisposed">
      <ensures>IsAttached == Contract.OldValue(IsAttached)</ensures>
    </member>
  </members>
</doc>